{"meta":{"title":"Damo Blog","subtitle":"","description":"业精于勤荒于嬉，行成于思毁于随。","author":"Damo","url":"http://www.lidamo.cn"},"pages":[{"title":"分类","date":"2021-05-10T09:50:03.000Z","updated":"2021-05-10T11:05:05.638Z","comments":true,"path":"categories/index.html","permalink":"http://www.lidamo.cn/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"标签","date":"2021-05-10T11:04:30.000Z","updated":"2021-05-10T11:04:55.147Z","comments":true,"path":"tags/index.html","permalink":"http://www.lidamo.cn/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Puerts","date":"2022-01-26T16:13:41.000Z","updated":"2022-02-03T02:44:37.557Z","comments":true,"path":"puerts/index.html","permalink":"http://www.lidamo.cn/puerts/index.html","excerpt":"","text":"配置环境相关 Puerts接入Unity (一) 基本接入 Puerts接入Unity (二) 搭建Ts环境 Puerts接入Unity (三) 搭建调试环境(VSCode) 导入插件相关 Puerts 支持 DOTween 工作流程相关 Puerts 自动导入命名空间 Puerts 双击打印日志跳转代码","raw":null,"content":null},{"title":"XLua","date":"2022-01-26T16:37:55.000Z","updated":"2022-02-03T02:39:01.163Z","comments":true,"path":"xlua/index.html","permalink":"http://www.lidamo.cn/xlua/index.html","excerpt":"","text":"配置环境相关 XLua接入Unity (一) 基本接入 XLua接入Unity (二) EmmyLua接入(VSCode) XLua接入Unity (三) 搭建调试环境(VSCode) 工作流程相关 XLua 双击打印日志跳转代码","raw":null,"content":null},{"title":"资源管理","date":"2022-01-26T15:26:48.000Z","updated":"2022-02-01T15:24:29.092Z","comments":true,"path":"resourceManage/index.html","permalink":"http://www.lidamo.cn/resourceManage/index.html","excerpt":"","text":"Unity资源管理相关 Unity资源管理 (一) 内存理解 Unity资源管理 (二) Asset Unity资源管理 (三) Unity默认路径 Unity资源管理 (四) Resources目录","raw":null,"content":null},{"title":"UI管理","date":"2022-01-26T16:28:42.000Z","updated":"2022-02-01T15:24:20.988Z","comments":true,"path":"uiManage/index.html","permalink":"http://www.lidamo.cn/uiManage/index.html","excerpt":"","text":"框架设计 UI管理-PureMVC","raw":null,"content":null}],"posts":[{"title":"Puerts接入Unity (三) 搭建调试环境(VSCode)","slug":"Puerts接入Unity-(三)-搭建调试环境(VSCode)","date":"2022-02-02T15:59:41.000Z","updated":"2022-02-04T14:47:19.214Z","comments":true,"path":"Puerts接入Unity-(三)-搭建调试环境(VSCode)/","link":"","permalink":"http://www.lidamo.cn/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/","excerpt":"","text":"创建launch.json 在项目根目录下创建.vscode/launch.json写入如下内容 12345678910&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [&#123; &quot;name&quot;: &quot;Puerts Debug&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;protocol&quot;: &quot;inspector&quot;, &quot;port&quot;: 18080 &#125;]&#125; 这里需要关注 port：监听的端口号 Puerts调试类型 Puerts调试一共分三种类型： AnyTime(任意时候): 项目启动后任意时候都可以启动调试器进行监听调试 Sync(同步阻塞): 只有先启动调试器才会执行Ts(Js)代码和C#代码 Async(异步): 只有先启动调试器才会执行Ts(Js)代码，但是不会影响C#代码 注意Sync和Async的区别在于是否会影响C#代码，Async的意义在于调试器刚起来几百毫秒内是没有办法打断点的，只有借助Async才能帮助调试项目最开始的启动代码，可以参考官方文档vscode debug指引 调整入口代码 根据三种类型，为了项目中方便使用，我们可以调整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public enum EJavaScriptDebugStyle&#123; AnyTime, //任何时候 Sync, //同步 Async, //异步&#125;public class JavaScript : MonoBehaviour&#123; private JsEnv mJsEnv; private JavaScriptLoader mJsLoader; public int JavaScriptDebugPort = 18080; public EJavaScriptDebugStyle JavaScriptDebugStyle = EJavaScriptDebugStyle.AnyTime; public void Start() &#123; Application.runInBackground = true; mJsLoader = new JavaScriptLoader(); mJsEnv = new JsEnv(mJsLoader, JavaScriptDebugPort); gameStart(); &#125; async private void gameStart() &#123; // 异步 if (JavaScriptDebugStyle == EJavaScriptDebugStyle.Sync) &#123; mJsEnv.WaitDebugger(); &#125; // 同步 else if (JavaScriptDebugStyle == EJavaScriptDebugStyle.Async) &#123; await mJsEnv.WaitDebuggerAsync(); &#125; mJsEnv.Eval(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;test&quot;)); &#125; public void Update() &#123; mJsEnv?.Tick(); &#125;&#125; 这样即可以启动Puerts Debug前方的小箭头连接打断点进行调试了 无法调试原因 debugPath配置不正确：Puerts借助VSCode调试的原理为将Js文件完整路径告诉VSCode，由VSCode自行根据对应地址寻找Ts代码，所以之前JsLoader中ReadFile的debugPath地址必须为直接地址，形式必须为D:\\BlogTest-TypeScript\\JavaScript\\ownts\\test.js类似D:\\BlogTest-TypeScript\\Assets\\..\\JavaScript\\ownts\\test.js带有..字样都是不可以的并且注意Windows下需要修改”/“为”\\“ 端口号不一致或者被占用：注意JsEnv传入的端口号需要与launch.json中端口号一致，并且需要检查是否存在端口号被占用的情况 未设置Application.runInBackground = true：未设置runInBackground有可能会导致点击VSCode的时候Unity停止运行，进而无法调试 未在Update中调用Tick：需要在Update中调用JsEnv的Tick函数，才能保证连接上 参考链接：https://www.jianshu.com/p/0980e2c50049","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"Puerts接入Unity (二) 搭建Ts环境","slug":"Puerts接入Unity-(二)-搭建Ts环境","date":"2022-02-02T15:58:21.000Z","updated":"2022-02-04T04:11:37.766Z","comments":true,"path":"Puerts接入Unity-(二)-搭建Ts环境/","link":"","permalink":"http://www.lidamo.cn/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-%E6%90%AD%E5%BB%BATs%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言 在前面章节中，脚本文件内容都是Js，实际项目开发过程中，我们是编写Ts的，但是Ts是不能直接运行的，在V8中的运行形式还是Js，所以，我们需要搭建Ts到Js的编译环境。Ts到Js的编译器有很多，本文主要介绍tsc编译。 准备工作 安装VSCode(对TypeScript有很好的支持) 安装Node.js(编译环境) 安装npm, npm为Node.js自带的包管理工具，上面安装Node时就已经安装上了 安装TypeScript到系统环境(在 项目根目录)下打开控制台(下同) 输入 npm install typescript -g 安装 重启VSCode后输入 tsc看是否运行成功，如果失败参考tsc执行脚本失败的解决方案 项目目录下创建下列文件 TypeScript空文件夹，用于存放项目中的所有Ts文件 package.json文件，用于保存项目中要用到的模块依赖、构建命令 终端输入npm init，一直回车直到结束 tsconfig.json文件，用于配置项目中Ts的配置项， 一开始可以是{} 全部准备完以后，项目的整体情况如图所示: 修改package.json 可以将以下内容，复制到初始化好的package.json中。 123456789101112&#123; &quot;name&quot;: &quot;puerts&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;watch&quot;: &quot;tsc -b tsconfig.json -w&quot;, &quot;build&quot;: &quot;node ./Build.js clear &amp;&amp; tsc -b tsconfig.json&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;fs-extra&quot;: &quot;^9.1.0&quot;, &quot;uglify-js&quot;: &quot;^3.13.1&quot; &#125;&#125; 这里我们需要关注几个内容： scripts: 定义的构建脚本，可以定义任意工作流，通过npm run 任务名来执行某个任务 如npm run watch代表执行 tsc -b tsconfig.json -w dependencies: 定义了项目中要用到的依赖。如目前有的依赖 fs-extra，一个 node 文件操作模块增强版本 uglify-js，一个 Js 代码压缩模块 在项目目录下运行npm install来拉取依赖到本地，拉取到的所有的依赖都将保存在项目/node_modules目录中。 此外可以通过npm install 依赖名 --save安装依赖，并将依赖注册到dependencies中 如npm install source-map-support -- save代表安装source-map-support依赖，并会在dependencies中注册source-map-support的版本，方便项目中其他人直接安装 参考npm install的几种方式区别 修改tsconfig.json tsconfig参考配置 123456789101112131415161718&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ESNext&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;jsx&quot;: &quot;react-jsx&quot;, &quot;lib&quot;: [&quot;ESNext&quot; ,&quot;DOM&quot;], &quot;inlineSourceMap&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;experimentalDecorators&quot;: true, &quot;baseUrl&quot;: &quot;./TypeScript/&quot;, &quot;typeRoots&quot;: [ &quot;./Assets/Puerts/Typing&quot;, &quot;./Assets/Gen/Typing&quot;, &quot;./node_modules/@types&quot; ], &quot;outDir&quot;: &quot;./JavaScript/ownts/&quot; &#125;&#125; 这里我们需要关注几个内容： baseUrl: 基本目录即放置ts代码的目录 typeRoots: 指定哪些文件默认需要引入 ./Assets/Puerts/Typing: Puerts自带的文件 ./Assets/Gen/Typing: csharp导出的文件 ./node_modules/@types: 安装的依赖带有的文件 outDir: 编译输出目录即编译生成的js代码目录 创建Puerts配置文件 官方文档 需要根据官网要求加上一定的标签，并且放在Unity的Editor目录下 这里我们在Editor下创建MyPuertsCfg统一管理，这里贴出一部分代码供参考 完整代码可以下载MyPuertsCfg 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// &lt;summary&gt;/// puerts工具配置/// &lt;/summary&gt;[Puerts.Configure]public class MyPuertsCfg&#123; /// &lt;summary&gt; /// 部分C# System接口绑定与导出（到ts） /// &lt;/summary&gt; [Puerts.Binding] public static IEnumerable&lt;Type&gt; CsharpBindings &#123; get &#123; return new List&lt;Type&gt;() &#123; typeof(System.Array), typeof(System.Object), typeof(System.Type), typeof(System.Delegate), typeof(System.Collections.Generic.ICollection&lt;UnityEngine.Object&gt;), typeof(System.Collections.Generic.IList&lt;UnityEngine.Object&gt;), // ... &#125;; &#125; &#125; /// &lt;summary&gt; /// 部分Unity Engine接口绑定与导出（到ts） /// &lt;/summary&gt; [Puerts.Binding] public static IEnumerable&lt;Type&gt; UnityBindings &#123; get &#123; return new List&lt;Type&gt;() &#123; typeof(UnityEngine.Color), typeof(UnityEngine.Debug), typeof(UnityEngine.Time), typeof(UnityEngine.Rect), typeof(UnityEngine.Vector2), typeof(UnityEngine.Vector3), // ... &#125;; &#125; &#125; [Puerts.Filter] public static bool FilterMethods(System.Reflection.MemberInfo mb) &#123; if (mb.DeclaringType == typeof(UnityEngine.MonoBehaviour) &amp;&amp; mb.Name == &quot;runInEditMode&quot;) &#123;// 排除 MonoBehaviour.runInEditMode, 在 Editor 环境下可用发布后不存在 return true; &#125; if (mb.DeclaringType == typeof(UnityEngine.UI.Text) &amp;&amp; mb.Name == &quot;OnRebuildRequested&quot;) &#123;// 排除 Text.OnRebuildRequested, 在 Editor 环境下可用发布后不存在 return true; &#125; if (mb.DeclaringType == typeof(UnityEngine.UI.Graphic) &amp;&amp; mb.Name == &quot;OnRebuildRequested&quot;) &#123;// 排除 Graphic.OnRebuildRequested, 在 Editor 环境下可用发布后不存在 return true; &#125; //默认不过滤 return false; &#125;&#125; 创建完成以后可以点击Generate Code就可以看到Assets/Gen目录下生成的Puerts导出文件 创建辅助脚本Build.js 可以看到我们的package.json中的&quot;build&quot;: &quot;node ./Build.js clear &amp;&amp; tsc -b tsconfig.json&quot;，我们可以用node做出脚本辅助我们项目中一些文件处理，这里我做了一个清理脚本Build.js(因为tsc编译时候不会自动清除已经删除的文件)有需要可以根据项目拓展 12345678910111213141516171819202122232425262728293031323334353637const path = require(&#x27;path&#x27;), fs = require(&#x27;fs-extra&#x27;), // 获取传入的参数模式 mode = (() =&gt; &#123; let argv = require(&#x27;process&#x27;).argv; return argv[argv.length - 1]; &#125;)();class Build &#123; constructor(mode) &#123; var configPath = path.join(__dirname, &#x27;tsconfig.json&#x27;); console.log(configPath) if (fs.existsSync(configPath)) &#123; this.config = require(configPath); &#125; else &#123; throw new Error(&#x27;tsconfig.json 配置文件不存在&#x27;); &#125;; this.srcDir = path.join(__dirname, this.config.compilerOptions.baseUrl); this.outDir = path.join(__dirname, this.config.compilerOptions.outDir); this.timer = &#123;&#125;; // 文件监听计时器 switch (mode) &#123; case &#x27;clear&#x27;: this.clear(); break; &#125; &#125; // 清除目录 Js clear() &#123; fs.emptyDirSync(this.outDir); console.log(`目录清除成功：$&#123;this.outDir&#125;`); &#125;&#125;new Build(mode); 创建Ts代码测试 完成了上面所有操作以后，我们就可以编写Ts代码了，如图我们可以创建test.ts，然后运行npm run build(删除原有Js代码重新编译)，或者npm run watch(实时监听编译，TypeScript目录下所有的 ts 文件有任何改动，都会实时编译)，就可以看到编译生成的Js代码了，运行Unity就可以成功读取生成的Js代码了 参考链接：https://www.jianshu.com/p/007be135eb92","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"Puerts接入Unity (一) 基本接入","slug":"Puerts接入Unity-(一)-基本接入","date":"2022-02-02T14:18:00.000Z","updated":"2022-02-03T16:05:21.902Z","comments":true,"path":"Puerts接入Unity-(一)-基本接入/","link":"","permalink":"http://www.lidamo.cn/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/","excerpt":"","text":"导入项目 从Puerts官网下载对应版本的 Puerts ，并解压 Sources_code(zip): Puerts源码 将源码puerts-Unity_Plugin_xxx.zip解压出来的unity/Assets/Puerts/拷贝到项目/Assets/下。 Plugins_V8_verx.tgz: 编译好的V8文件 将V8文件Plugins_V8_verx.tgz解压出来的Plugins/拷贝到项目/Assets/下。 这样就完成对Puerts的导入。如图所示： 简单测试 创建一个C#脚本写下如下代码： 12345678910public void Start()&#123; mJsEnv = new JsEnv(); mJsEnv.Eval(@&quot; const CS = require(&#x27;csharp&#x27;); console.log(&#x27;hello world&#x27;); console.log(1 + 1); CS.UnityEngine.Debug.Log(&#x27;Hello World&#x27;); &quot;);&#125; 可以看到Unity的console下可以输出对应日志，代表Puerts已经成功导入项目了。 加载独立Js文件 目前代码还是以字符串的形式存在C#代码之中，在实际项目中，所有的Js代码一定都是以独立文件的形式存在。 考虑到放在Unity的Asset下产生无用的meta文件，我们直接将所有Js文件放在根目录下，在根目录下创建JavaScript文件夹，这里我们将Puerts\\Src\\Resources\\puerts下puerts的js文件拷贝至JavaScript文件夹下统一管理，并创建ownts文件夹用于存放我们项目中自己的Js文件，这里我们创建一个test.js用于测试。 下面我们需要定制loader类让Puerts识别到我们自己的Js文件，创建一个JavaScriptLoader实现Puerts的ILoader接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using Puerts;using System.IO;public class JavaScriptLoader : ILoader&#123; private string mPuertsRoot; private string mOwntsRoot; public JavaScriptLoader() &#123; mPuertsRoot = &quot;&quot;; mOwntsRoot = &quot;ownts/&quot;; &#125; /// &lt;summary&gt; /// 纠正路径（Windows下路径斜杠不正确的问题） /// &lt;/summary&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;纠正之后的路径&lt;/returns&gt; private string pathUnified(params string[] args) &#123; return Path.Combine(args).Replace(&quot;\\\\&quot;, &quot;/&quot;); &#125; /// &lt;summary&gt; /// 判断模块是否为 Puerts自带模块 /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;模块名称&lt;/param&gt; /// &lt;returns&gt;true/false&lt;/returns&gt; private bool isPuertsModule(string filePath) &#123; return filePath.StartsWith(&quot;puerts/&quot;); &#125; /// &lt;summary&gt; /// * 接口要求实现 /// 判断文件是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;文件路径&lt;/param&gt; /// &lt;returns&gt;true/false&lt;/returns&gt; public bool FileExists(string filePath) &#123; string rootpath = isPuertsModule(filePath) ? mPuertsRoot : mOwntsRoot; var fileRealPath = pathUnified(JavaScriptPathHelper.RuntimePath, rootpath, filePath); return File.Exists(fileRealPath); &#125; /// &lt;summary&gt; /// * 接口要求实现 /// 文件内容读取 /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;模块路径&lt;/param&gt; /// &lt;param name=&quot;debugPath&quot;&gt;文件完整路径&lt;/param&gt; /// &lt;returns&gt;文本内容&lt;/returns&gt; public string ReadFile(string filePath, out string debugPath) &#123; string rootpath = isPuertsModule(filePath) ? mPuertsRoot : mOwntsRoot; var fileRealPath = pathUnified(JavaScriptPathHelper.RuntimePath, rootpath, filePath); var txt = File.ReadAllText(fileRealPath);#if UNITY_EDITOR_WIN debugPath = fileRealPath.Replace(&quot;/&quot;, &quot;\\\\&quot;);#else debugPath = jsPath;#endif return txt; &#125;&#125; 注意这里需要判断是否为puerts自身的模块，debugPathwindows下需要修改”/“为”\\“，具体作用我们留到调试环节再阐述。 新建JavaScriptPathHelper用于管理JavaScript相关的路径 123456789101112131415161718public class JavaScriptPathHelper&#123; public static string RuntimePath &#123; get &#123; if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.LinuxEditor || Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.OSXPlayer || Application.platform == RuntimePlatform.LinuxPlayer) &#123; return System.Environment.CurrentDirectory + &quot;/JavaScript/&quot;; &#125; else &#123; return Application.persistentDataPath + &quot;/&quot;; &#125; &#125; &#125;&#125; 我们再调整入口文件 123456789private JsEnv mJsEnv;private JavaScriptLoader mJsLoader;public void Start()&#123; mJsLoader = new JavaScriptLoader(); mJsEnv = new JsEnv(mJsLoader); mJsEnv.Eval(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;test&quot;));&#125; 最后，回到游戏场景中再次运行游戏，可以看到Js文件被执行。 参考链接:https://www.jianshu.com/p/4eb6fd5e0b4c https://www.jianshu.com/p/5537996c4c33","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"XLua接入Unity (三) 搭建调试环境(VSCode)","slug":"XLua接入Unity-(三)-搭建调试环境(VSCode)","date":"2022-02-01T06:26:25.000Z","updated":"2022-02-03T16:04:56.401Z","comments":true,"path":"XLua接入Unity-(三)-搭建调试环境(VSCode)/","link":"","permalink":"http://www.lidamo.cn/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/","excerpt":"","text":"前言 Lua调试需要借助EmmyLua，EmmyLua调试可以直接attach到unity进程进行调试（官方不太建议），安装JDK后并设置JAVA_HOME环境变量即可，也可以使用tcp连接进行远程调试，下面介绍如何使用tcp连接调试。 调试配置 在VSCode中创建或添加新的调试配置，选择EmmyLua new Debug 会产生如下的配置（也可以直接粘贴进launch.json中） 123456789101112131415161718&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;emmylua_new&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;EmmyLua IDEConnectDebugger&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 9978, &quot;ext&quot;: [ &quot;.lua&quot;, &quot;.lua.txt&quot;, &quot;.lua.bytes&quot; ], &quot;ideConnectDebugger&quot;: true &#125; ]&#125; 这里我们需要关注两个变量 port ：调试端口号（这个端口号需要跟emmyluaService中端口号不一样） ideConnectDebugger： 是否由ide连接Debugger(即Unity) true 需要先启动Unity后启动IDE调试 false 需要先启动IDE调试后启动Unity 调试代码 在lua代码最开始初，我们在VSCode中ctrl + shift + p 输入EmmyLua选择Insert Emmy Debugger Code 可以生成如下的代码： 123package.cpath = package.cpath .. &quot;;c:/Users/用户名/.vscode/extensions/tangzx.emmylua-0.3.49/debugger/emmy/windows/x86/?.dll&quot;local dbg = require(&quot;emmy_core&quot;)dbg.tcpListen(&quot;localhost&quot;, 9978) 默认是ideConnectDebugger：true形式的，我们将端口号修改为和launch.json中端口号一致即可以启动项目开始调试了 项目封装 我们可以将上面的过程封装一下，将上面dll路径中的emmy_core.dll提取出来放入项目的Lua\\EmmyLua下然后生成一个新文件EmmyLuaDebuger.lua写入如下代码： 12345678910function StartEmmyLuaDebuger(isUnityConnectIDE) package.cpath = package.cpath .. &quot;;Lua/EmmyLua/?.dll&quot; CS.UnityEngine.Debug.Log(package.cpath) local dbg = require(&#x27;emmy_core&#x27;) if isUnityConnectIDE then dbg.tcpConnect(&#x27;localhost&#x27;, 9977) else dbg.tcpListen(&#x27;localhost&#x27;, 9978) endend 在项目挂载的脚本上增加LuaDebugEnabled和LuaDebugUnityConnectIDE两个参数，并在项目运行所有lua代码前执行上面的Lua代码： 12345678910111213141516171819202122public class LuaScript : MonoBehaviour&#123; public bool LuaDebugEnabled = false; public bool LuaDebugUnityConnectIDE = false; public void Start() &#123; mLuaEnv = new LuaEnv(); mLuaEnv.AddLoader(handleLoad);#if UNITY_EDITOR if (LuaDebugEnabled) &#123; mLuaEnv.DoString(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;Lua.EmmyLua.EmmyLuaDebuger&quot;)); var startDebugerFunc = mLuaEnv.Global.Get&lt;LuaFunction&gt;(&quot;StartEmmyLuaDebuger&quot;); startDebugerFunc.Call(LuaDebugUnityConnectIDE); startDebugerFunc.Dispose(); startDebugerFunc = null;#endif &#125; mLuaEnv.DoString(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;Lua.Main&quot;)); &#125;&#125; 这样便可以在项目中通过Unity界面灵活使用，方便项目开发过程中使用","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"XLua","slug":"技术/XLua","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/XLua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://www.lidamo.cn/tags/lua/"}]},{"title":"XLua接入Unity (二) EmmyLua接入(VSCode)","slug":"XLua接入Unity-(二)-EmmyLua接入(VSCode)","date":"2022-02-01T06:25:25.000Z","updated":"2022-02-06T16:30:10.457Z","comments":true,"path":"XLua接入Unity-(二)-EmmyLua接入(VSCode)/","link":"","permalink":"http://www.lidamo.cn/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/","excerpt":"","text":"准备工作 安装VSCode vscode插件栏安装lua插件安装完成以后，便可以打开项目中的Lua文件夹进行Lua代码编写了 Lua代码引用关联 正常情况下，Lua这种弱类型代码是没办法像强类型代码查看代码引用关系的，需要借助emmylua来帮助建议lua代码之间的引用关联。在vscode插件商店中找到EmmyLua插件，安装好即可以使用了 参考EmmyLua官方文档 如图在设置中设置好显示引用计数，即可以在代码中显示代码引用计数 Lua显示UnityAPI提示 安装Emmylua-unity插件，这款插件在应用商店中找不到，可以点击链接下载EmmyLua-Unity 在EmmyLua官网找到EmmyLuaService文件放到项目Editor目录下 修改EmmyLuaService中的端口号 以及VSCode中的端口号 在Unity标签栏中找到EmmyLuaService开启(注意每次改完端口号，都需要重新Disable，Enable一下) 在VSCode工作区中右键点击pull unity api 即可以看到导入的emmyLualib 编写代码时即可以看到UnityAPI的提示","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"XLua","slug":"技术/XLua","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/XLua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://www.lidamo.cn/tags/lua/"}]},{"title":"XLua接入Unity (一) 基本接入","slug":"XLua接入Unity-(一)-基本接入","date":"2022-02-01T06:24:25.000Z","updated":"2022-02-03T16:04:58.750Z","comments":true,"path":"XLua接入Unity-(一)-基本接入/","link":"","permalink":"http://www.lidamo.cn/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/","excerpt":"","text":"导入项目 从XLua官网下载XLua项目，将Assets/Plugins/和Assets/XLua/拷贝到项目/Assets/下，这样就完成对XLua的导入。如图所示： 简单测试 创建一个C#脚本写下如下代码： 1234567public void Start()&#123; mLuaEnv = new LuaEnv(); mLuaEnv.DoString(&quot;print(&#x27;hello world&#x27;)&quot;); mLuaEnv.DoString(&quot;print(1 + 1)&quot;); mLuaEnv.DoString(&quot;CS.UnityEngine.Debug.Log(&#x27;hello world&#x27;)&quot;);&#125; 可以看到Unity的console下可以输出对应日志，代表XLua已经成功导入项目了。 加载独立Lua文件 目前代码还是以字符串的形式存在C#代码之中，在实际项目中，所有的Lua代码一定都是以独立文件的形式存在。 考虑到放在Unity的Asset下产生无用的meta文件，我们直接将所有Lua文件放在根目录下，在根目录下创建Lua文件夹，并新建test.lua文件，如图所示： 下面我们需要定制loader函数让XLua识别到我们自己的Lua文件， 1234567891011121314151617public void Start()&#123; mLuaEnv = new LuaEnv(); mLuaEnv.AddLoader(handleLoad); mLuaEnv.DoString(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;Lua.test&quot;));&#125;private byte[] handleLoad(ref string filePath)&#123; filePath = filePath.Replace(&#x27;.&#x27;, &#x27;/&#x27;); string newPath = LuaPathHelper.RuntimePath + filePath + &quot;.lua&quot;; if(File.Exists(newPath)) &#123; return File.ReadAllBytes(newPath); &#125; return null;&#125; 注意这里handleLoad中需要加上File.Exists判断，不然require非自己编写的lua文件会报错。 新建LuaPathHelper用于管理Lua相关的路径 123456789101112131415161718public class LuaPathHelper&#123; public static string RuntimePath &#123; get &#123; if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.LinuxEditor || Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.OSXPlayer || Application.platform == RuntimePlatform.LinuxPlayer) &#123; return Path.Combine(Application.dataPath, &quot;../&quot;); &#125; else &#123; return Application.persistentDataPath + &quot;/&quot;; &#125; &#125; &#125;&#125; 可以看到XLua成功识别到了我们在Lua文件夹下的test.lua文件 配置GenConfig 在Lua中使用C#的方法，和在C#中使用Lua的方法都需要对相应方法打上[LuaCallCSharp]和[CSharpCallLua]标签，为了统一管理，可以将他们放到一个C#文件中 1234567891011121314151617181920212223242526272829303132//配置的详细介绍请看Doc下《XLua的配置.doc》public static class GenConfig&#123; //lua中要使用到C#库的配置，比如C#标准库，或者Unity API，第三方库等。 [LuaCallCSharp] public static List&lt;Type&gt; LuaCallCSharp = new List&lt;Type&gt;() &#123; typeof(System.Object), typeof(UnityEngine.Object), typeof(Vector2), typeof(Vector3), typeof(Vector4), typeof(Quaternion) // ... &#125;; //C#静态调用Lua的配置（包括事件的原型），仅可以配delegate，interface [CSharpCallLua] public static List&lt;Type&gt; CSharpCallLua = new List&lt;Type&gt;() &#123; typeof(Action), typeof(Action&lt;bool&gt;), typeof(Func&lt;double, double, double&gt;), typeof(Action&lt;string&gt;) //... &#125;; //黑名单 [BlackList] public static List&lt;List&lt;string&gt;&gt; BlackList = new List&lt;List&lt;string&gt;&gt;() &#123; new List&lt;string&gt;()&#123;&quot;System.Xml.XmlNodeList&quot;, &quot;ItemOf&quot;&#125;, new List&lt;string&gt;()&#123;&quot;UnityEngine.WWW&quot;, &quot;movie&quot;&#125;, &#125;;&#125; 通过调用Unity标签栏下的Generate Code 和 Clear Generate Code即可以生成对应的Wrap文件，Wrap文件的原理和作用可以参考这篇文章Wrap文件原理和作用","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"XLua","slug":"技术/XLua","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/XLua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://www.lidamo.cn/tags/lua/"}]},{"title":"XLua 双击打印日志跳转代码","slug":"XLua-双击打印日志跳转代码","date":"2022-01-26T17:28:16.000Z","updated":"2022-02-03T16:04:51.223Z","comments":true,"path":"XLua-双击打印日志跳转代码/","link":"","permalink":"http://www.lidamo.cn/XLua-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/","excerpt":"","text":"前言 Unity项目中用了XLua这种热更方式以后，Unity的console下输出的日志是不能双击跳到对应lua代码模块的，这样在开发过程中调试时候只能人工去寻找对应代码，非常的不方便以及影响开发效率，利用Unity的OnOpenAsset和正则匹配可以实现一个调试工具达到双击打印日志跳转到对应lua代码的效果，方便项目中的调试。 输出lua堆栈 如图所示，lua输出的日志是没有lua堆栈的，所以先要想办法让代码输出lua堆栈信息，这里我们可以 封装一个Debug.lua文件 1234567891011121314151617181920212223local csDebug = CS.UnityEngine.Debuglocal LogPreFix = &quot;LUA: &quot;Debug = &#123;&#125;function Debug.Log(msg) csDebug.Log(Debug.FormatTraceback(msg))endfunction Debug.LogWarning(msg) csDebug.LogWarning(Debug.FormatTraceback(msg))endfunction Debug.LogError(msg) csDebug.LogError(Debug.FormatTraceback(msg))end--- 显示第三层堆栈的信息，过滤掉前面两层function Debug.FormatTraceback(msg) return LogPreFix .. debug.traceback(msg, 3)endDebug.Log(&quot;test&quot;) 可以看到项目中的代码已经可以输出lua堆栈信息了。 绑定IDE 在做代码跳转之前，需要让Unity绑定对应的IDE，一般的开发IDE中，VSCode和IDEA居多，有需要也可以拓展，在Unity Editor目录下新建文件，写入如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 using UnityEditor; using UnityEngine;public enum LuaIDEType&#123; IDEA = 0, VSCode&#125;public class LuaIDESetting : EditorWindow&#123; [MenuItem(&quot;程序工具/Lua/LuaIDE路径配置&quot;)] public static void SetIdeaIDEPath() &#123; LuaIDESetting editor = CreateInstance&lt;LuaIDESetting&gt;(); editor.Show(); &#125; public string[] luaIDETypes = new string[] &#123; &quot;IDEA&quot;, &quot;VSCode&quot; &#125;; void OnGUI() &#123; int luaIDETypeIndex = EditorPrefs.GetInt(&quot;LUA_IDE_TYPE&quot;); luaIDETypeIndex = EditorGUILayout.Popup(luaIDETypeIndex, luaIDETypes); EditorPrefs.SetInt(&quot;LUA_IDE_TYPE&quot;, luaIDETypeIndex); LuaIDEType luaIDEType = (LuaIDEType)luaIDETypeIndex; if (luaIDEType == LuaIDEType.IDEA) &#123; GUILayout.Label(&quot;IDEA IDE路径:&quot;); string ideaPath = EditorPrefs.GetString(&quot;IDEA_IDE_Path&quot;); GUILayout.TextField(ideaPath); if (GUILayout.Button(&quot;Browse&quot;)) &#123; ideaPath = UnityEditor.EditorUtility.OpenFilePanel(&quot;选择路径&quot;, &quot;&quot;, &quot;exe&quot;); EditorPrefs.SetString(&quot;IDEA_IDE_Path&quot;, ideaPath); &#125; &#125; else if (luaIDEType == LuaIDEType.VSCode) &#123; GUILayout.Label(&quot;VSCode IDE路径:&quot;); string vscodePath = EditorPrefs.GetString(&quot;VSCode_IDE_Path&quot;); GUILayout.TextField(vscodePath); if (GUILayout.Button(&quot;Browse&quot;)) &#123; vscodePath = UnityEditor.EditorUtility.OpenFilePanel(&quot;选择路径&quot;, &quot;&quot;, &quot;exe&quot;); EditorPrefs.SetString(&quot;VSCode_IDE_Path&quot;, vscodePath); &#125; &#125; &#125;&#125;在Unity标签栏寻找对应的标签，这里我放到了”程序工具/Lua/LuaIDE路径配置”下，打开后跳出如上界面即可以绑定对应的IDE地址 双击跳转这里利用Unity的OnOpenAssetAttribute在Editor目录下新建文件写入如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Diagnostics;using System.IO;using System.Reflection;using System.Text.RegularExpressions;using UnityEditor;public class LuaLogLocation&#123; [UnityEditor.Callbacks.OnOpenAssetAttribute(1)] static bool OnOpenAsset(int instanceID, int line) &#123; string stackTrace = GetStackTrace(); // 这里正则解析 Match match = Regex.Match(stackTrace, &quot;stack traceback:\\n.*:\\\\d+:&quot;); return OpenLuaLocation(match); &#125; // 获取输出堆栈 static string GetStackTrace() &#123; System.Type consoleWindowType = typeof(EditorWindow).Assembly.GetType(&quot;UnityEditor.ConsoleWindow&quot;); FieldInfo ms_ConsoleWindow_fieldInfo = consoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic); EditorWindow consoleWindowInstance = ms_ConsoleWindow_fieldInfo.GetValue(null) as EditorWindow; if (null != consoleWindowInstance) &#123; if (EditorWindow.focusedWindow == consoleWindowInstance) &#123; FieldInfo m_ActiveText_fieldInfo = consoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic); return m_ActiveText_fieldInfo.GetValue(consoleWindowInstance).ToString(); &#125; &#125; return string.Empty; &#125; // 打开IDE static bool OpenLuaLocation(Match match) &#123; if (!match.Success) &#123; return false; &#125; int luaIDETypeIndex = EditorPrefs.GetInt(&quot;LUA_IDE_TYPE&quot;); LuaIDEType luaIDEType = (LuaIDEType)luaIDETypeIndex; string idePath = string.Empty; if (luaIDEType == LuaIDEType.IDEA) &#123; idePath = EditorPrefs.GetString(&quot;IDEA_IDE_Path&quot;); &#125; else if (luaIDEType == LuaIDEType.VSCode) &#123; idePath = EditorPrefs.GetString(&quot;VSCode_IDE_Path&quot;); &#125; if (string.IsNullOrEmpty(idePath) || !System.IO.File.Exists(idePath)) &#123; return false; &#125; // 这里处理正则匹配后的结构，需要根据项目实际情况具体分析 string pathLine = match.Groups[0].Value; pathLine = pathLine.Substring(pathLine.IndexOf(&quot;\\t&quot;) + 1); pathLine = pathLine.Substring(0, pathLine.Length - 1); int spliteIndex = pathLine.LastIndexOf(&#x27;:&#x27;); string filePath = pathLine.Substring(0, spliteIndex); int line = System.Convert.ToInt32(pathLine.Substring(spliteIndex + 1)); // 这里需要根据项目中lua文件的位置以及补充后缀等 string luaCodePath = Path.Combine(LuaManager.LUA_FILE_PATH, filePath + LuaManager.LUA_FILE_EXTENSION); filePath = System.Environment.CurrentDirectory + &quot;/&quot; + luaCodePath; string args = string.Empty; if (luaIDEType == LuaIDEType.IDEA) &#123; args = string.Format(&quot;&#123;0&#125;:&#123;1&#125;&quot;, filePath.Replace(&quot;\\\\&quot;, &quot;/&quot;), line); &#125; else if (luaIDEType == LuaIDEType.VSCode) &#123; args = string.Format(&quot;-g &#123;0&#125;:&#123;1&#125;&quot;, filePath.Replace(&quot;\\\\&quot;, &quot;/&quot;), line); &#125; Process process = new Process(); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = idePath; startInfo.Arguments = args; startInfo.UseShellExecute = false; startInfo.CreateNoWindow = false; startInfo.RedirectStandardOutput = false; process.StartInfo = startInfo; process.Start(); return true; &#125;&#125; 上面这些代码都调整好以后，双击Unity对应console下输出日志，即可在对应IDE中跳转到对应的lua代码行数注意中间解析字符串的过程以及获取目录的过程，需要自己根据项目目录调整一下，注意使用绝对路径，windows下注意文件目录左右斜杠的问题 思考 目前工具只做了windows版本，其他如mac版本可能需要在绑定和打开IDE中做出一定调整。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"XLua","slug":"技术/XLua","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/XLua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://www.lidamo.cn/tags/lua/"}]},{"title":"放置类卡牌战斗(二十四) 完结","slug":"放置类卡牌战斗-(二十四)-完结","date":"2022-01-11T08:03:59.000Z","updated":"2022-01-26T18:19:15.244Z","comments":true,"path":"放置类卡牌战斗-(二十四)-完结/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E5%9B%9B)-%E5%AE%8C%E7%BB%93/","excerpt":"","text":"点我回到首页 前言 到这里，对于放置类卡牌战斗的开发记录也算告一段落了，当然其中的很多模块也主要集中在设计思想和机制层面，对于很多表现层面的开发还没有做到精细，这些都是需要在后面项目迭代过程中不断优化的。 个人总结 回看这两年来的学习，从一开始代码堆砌在一个文件一个类到后来慢慢接触设计模式，再到花时间思考，慢慢将项目中的一些代码整理重构，并在过程中学习和运用设计模式，也算这一路的收获和成长吧。 个人心得 代码能力和接口设计能力是开发中必不可少的一部分，这部分的能力说实话不是看书或者看视频看资料就能一下学会的，这个需要在日常开发中不断积累，就算看完二十三种设计模式，也是需要在不断的实战中才能逐步理解的。在我们每一个需求到来时，如果我们都花上一天时间或者更多时间，不写代码，先做分析和设计，理清其中的需求点，再分析需求点中通用部分，在我看来，面向对象的精髓就是抽象和多态，把代码做成一个相对通用的框架结构绝对是开发中最爽的事情，当策划每扔过来一个需求，你都可以通过建一个子类，加一两行代码，或者干脆可以通过配置文件灵活配置，这个时候，你会有满满的成就感，因为你的代码是一个通用的代码。相反，任何时候，你看到那些一大堆if else代码的时候，都会很烦躁，因为每次加需求，你都需要把原先代码的逻辑整个捋一遍，才知道要怎么加，不仅影响心情，也影响工作效率。在我看来，用好继承和多态，在代码设计层面来说是必不可少的一项技能。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(二十三) 相机管理","slug":"放置类卡牌战斗-(二十三)-相机管理","date":"2022-01-11T07:35:12.000Z","updated":"2022-02-01T14:11:01.567Z","comments":true,"path":"放置类卡牌战斗-(二十三)-相机管理/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%89)-%E7%9B%B8%E6%9C%BA%E7%AE%A1%E7%90%86/","excerpt":"","text":"点我回到首页 前言 相机算是这类战斗的表现部分，市面上目前也提供了很多插件工具，直接导入项目调用API即可，这里主要介绍一下设计思想，项目当中对于相机使用比较轻量的话，也可以参照这种思想进行设计。 CameraAction设计 在游戏中对于会有很多行为，如改变相机Fov，改变相机角度，改变相机位置，相机跟随目标，相机震动等等，这些行为有时候会单独使用，有时候会组合使用，如果不能有效设计，将会造成大量代码冗余。这里我们可以通过设计一个CameraAction代表所有相机行为的基类: 12345678910111213141516171819202122232425262728293031export class BattleCameraAction &#123; protected cameraSP: BattleCameraSP; constructor(cameraSP: BattleCameraSP) &#123; this.cameraSP = cameraSP; &#125; public init(...args: any[]) &#123; this.onInit.apply(this, args); &#125; public update(dt: number) &#123; this.onUpdate(dt); &#125; public complete() &#123; this.cameraSP.cancelCameraAction(this, false); &#125; /** * 取消 * @param interrupt 是否强制取消 */ public cancel(interrupt: boolean): void &#123; this.onDestroy(); &#125; protected onInit(...args: any[]) &#123; &#125; protected onUpdate(dt: number) &#123; &#125; protected onDestroy() &#123; &#125;&#125; CameraAction管理 通过CameraSP对所有的CameraAction进行管理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778export class BattleCameraSP extends SceneProcessorBase&lt;BattleScene&gt; &#123; private _cameraActions: BattleCameraAction[]; private _cameraObj: GameObject; private _cameraTrans: Transform; private _camera: Camera; protected override onInit(): void &#123; this._cameraActions = []; // 初始化获取地图上的相机 （省略细节） &#125; protected override onUpdate(dt: number): void &#123; for (let cameraAction of this._cameraActions) &#123; cameraAction.update(dt); &#125; &#125; /** 跟随目标 */ public followTarget(target: ICameraTarget, followSpeed: number = 1, offset: Vector3 = Vector3.zero) &#123; this._createCameraAction(BattleCameraFollowAciton, target, followSpeed, offset); &#125; /** 改变fov */ public changeFov(targetFov: number, speed: number = 1): void &#123; this._createCameraAction(BattleCameraFovAciton, targetFov, speed); &#125; /** 改变角度 */ public changeRotation(targetRot: Quaternion, speed: number = 1): void &#123; this._createCameraAction(BattleCameraRotateAction, targetRot, speed); &#125; /** 相机震动 */ public shake(intensity: number, duration: number = 0, disableX: boolean = false, disableY: boolean = false, delayTime: number = 0): void &#123; this._createCameraAction(BattleCameraShakeAction, intensity, duration, disableX, disableY, delayTime); &#125; /** 同类型action只能存在一个 */ private _createCameraAction&lt;T extends BattleCameraAction&gt;(type: new (BattleCameraSP) =&gt; T&gt;, ...args: any[]): T &#123; let action = this.getCameraAction(type); if (!action) &#123; action = new type(this); this._cameraActions.push(action); &#125; action.init(...args); return action; &#125; public getCameraAction&lt;T extends BattleCameraAction&gt;(type: new (BattleCameraSP) =&gt; T): T &#123; for (let action of this._cameraActions) &#123; if (action instanceof type) &#123; return action; &#125; &#125; &#125; public cancelCameraAction(action: BattleCameraAction, interrupt: boolean = true) &#123; ArrayUtil.removeFirstIf(this._cameraActions, (ac) =&gt; &#123; return ac === action; &#125;); action &amp;&amp; action.cancel(interrupt); &#125; public cancelAllAction(interrupt: boolean = true) &#123; for (let i = 0; i &lt; this._cameraActions.length; ++i) &#123; this._cameraActions[i].cancel(interrupt); &#125; this._cameraActions.length = 0; &#125; public get camera(): Camera &#123; return this._camera; &#125; public get position(): Vector3 &#123; return this._cameraTrans.position; &#125; public set position(pos: Vector3) &#123; this._cameraTrans.position = pos; &#125; public get rotation(): Quaternion &#123; return this._cameraTrans.rotation; &#125; public set rotation(rat: Quaternion) &#123; this._cameraTrans.rotation = rat; &#125; public set fov(fov: number) &#123; this._camera.fov = fov; &#125; public get fov(): number &#123; return this._camera.fov; &#125;&#125; CameraAction具体实现 这样就可以在对应的CameraAction实现相应功能，下面举几个例子： 改变FOV 一个比较简单的改变FOV的实现 1234567891011121314151617export class BattleCameraFovAciton extends BattleCameraAction &#123; private _targetFov: number; private _speed: number; protected override onInit(targetFov: number, speed: number = 1) &#123; this._targetFov = targetFov; this._speed = speed; &#125; protected override onUpdate(dt: number): void &#123; if (Math.is_equal(this.cameraSP.fov, this._targetFov, 0.01)) &#123; this.complete(); return; &#125; this.cameraSP.fov = Math.lerp(this.cameraSP.fov, this._targetFov, this._speed * dt); &#125;&#125; 相机跟随 对于相机跟随，这里要注意，相机是一个通用模块，不能指定目标，所以需要一个接口ICameraTarget 1234export interface ICameraTarget &#123; /** 目标位置 */ position: Vector3;&#125; 这样再去实现相机跟随 123456789101112131415export class BattleCameraFollowAciton extends BattleCameraAction &#123; private _target: ICameraTarget; private _targetOffset: Vector3; private _followSpeed: number; protected override onInit(target: ICameraTarget, followSpeed: number = 1, offset: Vector3 = Vector3.zero) &#123; this._target = target; this._followSpeed = followSpeed; this._targetOffset = Vector3.create(offset.x, offset.y, offset.z); &#125; protected override onUpdate(dt: number) &#123; this.cameraSP.position = Vector3.lerp(this.cameraSP.position, Vector3.add(this._target.position, this._targetOffset), dt * this._followSpeed); &#125;&#125; 其他拓展 可以参照上面的写法将很多相机的行为进行包装成对应的CameraAction，这里相机所采用的Action思想同样可以运用于地图模块等其他模块，这里就不再一一赘述了。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(二十二) 技能设计-总结","slug":"放置类卡牌战斗-(二十二)-技能设计-总结","date":"2022-01-11T06:58:21.000Z","updated":"2022-02-01T14:10:49.382Z","comments":true,"path":"放置类卡牌战斗-(二十二)-技能设计-总结/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%BA%8C)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-%E6%80%BB%E7%BB%93/","excerpt":"","text":"点我回到首页 前言 前面我们将技能拆分成了Action和ActionEvent，并对其中的每一个构成部分进行了详解，下面结合样例进行一下总结。 样例分析配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &quot;EventList&quot; : [ &#123; &quot;TriggerTime&quot; : 0, &quot;EventType&quot; : &quot;PlayAnim&quot;, &quot;EventData&quot; : &#123; &quot;AnimName&quot; : &quot;BattleAttack&quot;, &quot;AnimSpeed&quot; : 1.0, &quot;FadeTime&quot; : 0.0 &#125; &#125;, &#123; &quot;TriggerTime&quot; : 20, &quot;EventType&quot; : &quot;PlayEffect&quot;, &quot;EventData&quot; : &#123; &quot;EffectName&quot; : &quot;XXX&quot;, &quot;IsLoop&quot; : false, &#125; &#125; ], &quot;ActionList&quot; : [ &#123; &quot;EmitType&quot; : &quot;Normal&quot;, &quot;EmitProperty&quot; : &#123; &quot;TargetSideType&quot; : &quot;MySide&quot;, &quot;TargetSummonType&quot; : &quot;None&quot;, &quot;IncludeSelf&quot; : true, &quot;CondsSortType&quot; : &quot;Self&quot;, &quot;CondsSummonSortType&quot; : &quot;None&quot;, &quot;OrderNum&quot; : 1, &quot;Num&quot; : 1, &quot;Interval&quot; : 0.0, &quot;Type&quot; : &quot;Interval&quot;, &quot;DirType&quot; : &quot;SelfDir&quot;, &#125;, &quot;EntityType&quot; : &quot;FrameCircle&quot;, &quot;EntityProperty&quot; : &#123; &quot;TargetSideType&quot; : &quot;OtherSide&quot;, &quot;TargetSummonType&quot; : &quot;None&quot;, &quot;IncludeSelf&quot; : false, &quot;CondsSortType&quot; : &quot;NearToMe&quot;, &quot;CondsSummonSortType&quot; : &quot;None&quot;, &quot;Delay&quot; : 0.0, &quot;Nums&quot; : 1, &quot;Radius&quot; : 3.6 &#125;, &quot;HitFeedbackProperty&quot; : &#123; &quot;SkillActionID&quot; : 101101001, &quot;Sound&quot; : &quot;&quot;, &quot;Effect&quot; : &quot;YYY&quot; &#125;, &quot;TriggerTime&quot; : 391, &quot;Delay&quot; : 0.0, &quot;DeadActionChanged&quot; : true &#125; ]&#125;, 配置解析 如图中这样一个技能，可以看到会 在0ms时候PlayAnim，AnimName为BattleAttack， 在20m时候PlayEffect，EffectName为XXX， 在391ms时候启动一个Action，发射一个Normal发射器，发射器选择位置为我方（MySide）最终选择自己（Self），发射一个FrameCircle实体并搜集实体周围半径（Radius)3.6的敌方（OtherSide）离我最近（NearToMe）的一个（1）单位，对该单位进行SkillActionID = 101101001的反馈，受击特效为YYY。 打开SkillAction表找到对应行数，可以看到技能为造成伤害并加上300103（击退buff）的Buff 技能最终效果即为，对在我半径3.6范围内的最近的敌方单位造成一次伤害并使其被击退。 总结 通过样例和之前的介绍，可以发现各种组合搭配起来，可以设计出很多技能，这里列举几个游戏中常见技能 对攻击力最高的敌人造成大伤害，并使其沉默，持续5秒 （FrameFullEntity 排序选取攻击最高 伤害 并 加沉默Buff） 对最远处的敌人施放一个小范围区域，对区域内的敌人每0.5秒造成伤害，并中幅(30%)降低防御力，持续4秒 （MoveEntity 速度设为0，持续4秒，间隔0.5秒 造成伤害并增加减防Buff） 治疗生命值最低的队友并清除他们的异常效果 （FrameFullEntity 排序选取生命值最低 治疗并清除Debuff） 当然游戏中还有更多更复杂的技能，也需要根据项目慢慢迭代拓展。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(二十一) 技能设计-Action受击反馈","slug":"放置类卡牌战斗-(二十一)-技能设计-Action受击反馈","date":"2022-01-11T04:35:57.000Z","updated":"2022-02-01T14:11:21.384Z","comments":true,"path":"放置类卡牌战斗-(二十一)-技能设计-Action受击反馈/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%80)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%97%E5%87%BB%E5%8F%8D%E9%A6%88/","excerpt":"","text":"点我回到首页 前言 从前文中可以看出，HitFeedback（受击反馈）是对Entity搜集的目标施加的效果，下面主要讲一些HitFeedback的实现。 场景分析 和前面的设计一样，通过几个游戏中常见的技能，根据这些技能来设计HitFeedback 战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。 奶妈举起手上的权杖，给生命值最低的己方单位加了一次血。 辅助扔出手上的药剂，给敌方全体单位上了一层持续一定时间的破防效果。 魔法师挥舞手上的法杖，在己方最前排召唤了一个侍从。 从HitFeedback角度简单分析上面列举的几个技能，可以发现有些HitFeedback是对目标造成伤害，有些HitFeedback是给目标治疗，有些HitFeedback是给目标上Buff，有些HitFeedback是在目标位置召唤生物，下面我们来根据这些分析来设计HitFeedback。 受击反馈设计需求分析 我们似乎可以参照前面Emit和Entity写出如下这个基类 12345678export interface IHitFeedbackCfg &#123;&#125;export abstract class BaseHitFeedback&lt;THitFeedbackCfg extends IHitFeedbackCfg = IHitFeedbackCfg&gt; &#123; // 省略细节 public abstract onHit(target: BattleCharacter): void; // 省略细节&#125; 然后继承实现出HitDamage，HitAddBuff，HitHeal即可 123456789101112export interface IHitDamageCfg extends IHitFeedbackCfg &#123; /** 伤害数值 */ DamageValue: number; /** 伤害类型 */ DamageType: EDamageType;&#125;export class HitDamage extends BaseHitFeedback&lt;IHitDamageCfg&gt; &#123; public onHit(target: BattleCharacter): void &#123; // 省略细节 造成伤害 &#125;&#125; 这样看起来是一个比较合理的实现方式，但是做项目的话似乎不太合适，我们站在策划的角度思考一下这个需求，Emit和Entity的配置信息都是配置在技能的Json中的，一个技能的实际效果，比如在动作第20ms选择自身半径范围内最近的敌方目标造成xxx伤害，一般来说，一个技能设计完成以后第20ms选择自身半径范围内最近的敌方目标造成伤害这些内容在随着版本迭代过程中是不会更改的，需要更改的是XXX伤害，这里需要加入数值运算，技能等级等因素，所以如果跟随Emit和Entity的配置信息一起配在Json中会非常麻烦，并且对于策划来说，他们更青睐于Excel，所以有必要把&quot;不变&quot;（不会经常变）的技能信息放在Json中，讲&quot;易变&quot;（数值等容易改变）的信息放入Excel中 受击反馈配置表格部分 设计一张新表SkillAction 如图所示 DamageValue：技能固定伤害数值 DamageRatio：技能固定与属性计算伤害比例 DamageUpgradeRatio：技能每级提升与属性伤害比例 DamageType: 伤害类型 这里用位运算 -1 不造成伤害 0 普通攻击 1 必定暴击 2 不可闪避 4 必定不暴击 8 无视防御 3 = 1 + 2 必定暴击不可闪避 HealValue 技能固定治疗数值 HealRatio：技能固定与属性计算治疗比例 HealUpgradeRatio: 技能每级提升与属性治疗比例 HealType: 治疗类型 这里用位运算 -1 不产生治疗 0 普通治疗 1 必定暴击 BuffIDs：所加Buff列表 1001|1002 表示 1001和1002两个Buff SummonID: 召唤物ID SummonOverlay: 召唤物叠加层数 SummonRatio: 召唤物属性比例 SummonOffset: 召唤物与选定位置的偏移 ClearBuffType: 驱散Buff类型 1 Buff 2 Debuff 3 所有Buff Json配置部分 1234567export interface IHitFeedbackCfg &#123; readonly SkillActionID: number; /** 受击音效 */ readonly Sound: string; /** 受击特效 */ readonly Effect: string;&#125; 受击反馈实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export class HitFeedback &#123; private _action: BaseBattleAction; private _hitFeedbackCfg: IHitFeedbackCfg; private _attackerAttr: BaseAttr; constructor(action: BaseBattleAction) &#123; this._action = action; this._hitFeedbackCfg = action.actionCfg.HitFeedbackProperty; // 子弹类伤害，在发射时就记录释放者的属性 this._attackerAttr = action.actionOwner.attrComp.attr.clone(); &#125; public hitApply(target: BattleCharacter) &#123; this._processDamage(); this._processHeal(); this._processBuff(); this._processClearBuff(); this._processSummon(); this._processPlaySound(); this._processPlayEffect(); &#125; private _processDamage() &#123; // 造成伤害（省略实现） &#125; private _processHeal() &#123; // 加治疗（省略实现） &#125; private _processBuff() &#123; // 加Buff（省略实现） &#125; private _processClearBuff(): void &#123; // 驱散Buff（省略实现） &#125; private _processSummon(): void &#123; // 召唤（省略实现） &#125; private _processPlaySound(): void &#123; // 播放声音 （省略实现） &#125; private _processPlayEffect() &#123; // 播放特效 （省略实现） &#125;&#125; 受击反馈拓展 以上列出的HitFeedback仅供参考，可以根据项目需求设计各种HitFeedback，了解整个机制流程之后，可以不拘泥于伤害治疗，例如召唤等都可以做到HitFeedback里面。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(二十) 技能设计-Action攻击实体","slug":"放置类卡牌战斗-(二十)-技能设计-Action攻击实体","date":"2022-01-11T03:03:04.000Z","updated":"2022-02-01T14:10:23.971Z","comments":true,"path":"放置类卡牌战斗-(二十)-技能设计-Action攻击实体/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%94%BB%E5%87%BB%E5%AE%9E%E4%BD%93/","excerpt":"","text":"点我回到首页 前言 从前文中可以看出，Entity（攻击实体）在Action中由Emit产生，用于搜集目标单位，下面主要讲一些Entity的实现。 场景分析 和Emit设计一样，通过几个游戏中常见的技能，根据这些技能来设计Entity 战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。 剑士用手上的剑，朝前方发射一道刀光，刀光向前推进，被刀光打中的敌方单位都会受到伤害。 刺客朝着生命值最低的敌方单位扔了一把匕首，匕首打到瞄准的单位后造成伤害。 弓箭手朝着前方射了一只箭，箭会击中最先碰到的敌方单位并造成伤害（没碰到则一定时间后消失）。 从Entity角度简单分析上面列举的几个技能，会发现有些Entity是在同一帧搜集目标单位（挥舞的刀碰到的敌人），有些Entity会移动并在移动过程中搜集敌人（移动的刀光碰到的敌人），有些Entity会朝着事先设定好的目标移动直到碰到敌人为止（刺客扔出指定目标的匕首），有些Entity会带有物理碰撞，可以碰到第一个可被视为目标的单位（弓箭手射出的箭）。当然还有很多其他的技能，根据这些信息下面来设计基础的Entity。 实体设计实体配置 战斗中，实体需要根据一些规则确定目标单位，同样继承IBattleTargetCfg 1234export interface IEntityCfg extends IBattleTargetCfg &#123; /** 实体生效的延迟时间，如定时炸弹 */ readonly Delay: number;&#125; 实体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export abstract class BaseEntity&lt;TEntityCfg extends IEntityCfg = IEntityCfg&gt; &#123; /** 实体所属Action */ private b_action: BaseBattleAction; /** 实体配置 */ private b_entityCfg: TEntityCfg; /** 实体延迟发射时间 */ private b_delayTime: number; /** 实体创建结束 */ private b_buildFinished: boolean; /** 实体死亡 */ private b_isEntityDead: boolean; /** 实体初始位置 */ protected startPosition: Vector3; /** 实体初始方向 */ protected startDirection: Vector3; constructor(action: BaseBattleAction) &#123; this.b_action = action; this.b_entityCfg = action.actionCfg.EntityProperty as TEntityCfg; this.b_isEntityDead = false; this.b_delayTime = this.entityCfg.Delay; this.b_buildFinished = false; &#125; public init(startPosition: Vector3, startDirection: Vector3): void &#123; this.startPosition = startPosition; this.startDirection = startDirection; this.onInit(); &#125; public dispose(): void &#123; this.setEntityDead(); &#125; public update(dt: number): void &#123; /** 延迟规定时间后创建实体 */ if (this.isEntityDead) &#123; return; &#125; if (this.b_delayTime &gt; dt) &#123; this.b_delayTime -= dt; return; &#125; if (!this.b_buildFinished) &#123; this.b_buildFinished = true; this.onBuildEntity(); &#125; this.onUpdate(dt); &#125; /** 寻找一组敌人 */ protected searchTargets(pos: Vector3, direction: Vector3, nums: number): Array&lt;BattleCharacter&gt; &#123; let searchFinder = this.onSearchFinder(this.allList, pos, direction); return this.owner.battleComp.filterTargetsByNums(searchFinder, nums, this.entityCfg);; &#125; /** 寻找单个敌人 */ protected searchTarget(pos: Vector3, direction: Vector3, orderNum: number): BattleCharacter &#123; let searchFinder = this.onSearchFinder(this.allList, pos, direction); return this.owner.battleComp.filterTargetByNum(searchFinder, orderNum, this.entityCfg);; &#125; /** 实体死亡 */ protected setEntityDead() &#123; this.onDestroyEntity(); this.b_isEntityDead = true; &#125; protected onInit(): void &#123; &#125; protected onBuildEntity(): void &#123; &#125; protected onDestroyEntity(): void &#123; &#125; protected onUpdate(dt: number): void &#123; &#125; /** 筛选敌人 to override */ protected onSearchFinder(finder: Array&lt;BattleCharacter&gt;, pos: Vector3, direction: Vector3): Array&lt;BattleCharacter&gt; &#123; return finder; &#125; protected get owner() &#123; return this.b_action.actionOwner; &#125; protected get allList() &#123; return this.owner.battleComp.allList; &#125; protected get entityCfg(): TEntityCfg &#123; return this.b_entityCfg; &#125;; protected get targetList() &#123; return this.b_action.targetList; &#125; public get isEntityDead() &#123; return this.b_isEntityDead; &#125;&#125; 实体分类 可以从之前的技能看出来，实体按功能分类可能有FrameEntity（在同一帧搜集目标单位），MoveEntity（移动并在移动过程中搜集敌人），FollowEntity（朝着事先设定好的目标移动直到碰到敌人为止），PhysicalEntity（带有物理碰撞，可以碰到第一个可被视为目标的单位）等等 按范围分类可能有CircleEntity（指定位置周围一圈圆形范围），QuadEntity（指定位置周围方形范围），FullEntity（从所有可能选择目标单位中选取） 这里将功能一样的放在一起，便于拓展： 12345678910111213141516171819export enum EEntityType &#123; None = &quot;None&quot;, /** 逐帧判定-&gt;全部范围 */ FrameFull = &quot;FrameFull&quot;, /** 逐帧判定-&gt;圆形范围 */ FrameCircle = &quot;FrameCircle&quot;, /** 逐帧判定-&gt;扇形范围 */ FrameFan = &quot;FrameFan&quot;, /** 逐帧判定-&gt;四边形范围 */ FrameQuad = &quot;FrameQuad&quot;, /** 物理实体-&gt;碰撞Trigger */ Physical = &quot;Physical&quot;, /** 带位移实体-&gt;圆形范围 */ MoveCircle = &quot;MoveCircle&quot;, /** 带位移实体-&gt;四边形范围 */ MoveQuad = &quot;MoveQuad&quot;, /** 追踪目标实体-&gt;全部范围 */ FollowFull = &quot;FollowFull&quot;,&#125; 实体实例FrameEntity FrameEntity在创建后第一帧搜集敌人并且直接结束 123456789101112export interface FrameEntityCfg extends IEntityCfg &#123; /** 帧实体搜集的目标数量 */ readonly Nums: number;&#125;export class FrameEntity&lt;TFrameEntity extends FrameEntityCfg = FrameEntityCfg&gt; extends BaseEntity&lt;TFrameEntity&gt; &#123; protected override onUpdate(dt: number): void &#123; let finder = this.searchTargets(this.startPosition, this.startDirection, this.entityCfg.Nums); this.targetList.contact(finder); this.setEntityDead(); &#125;&#125; FrameCircleEntity FrameCircleEntity在FrameEntity基础上根据半径筛选 12345678910111213141516export interface FrameCircleEntityCfg extends FrameEntityCfg &#123; /** 半径 */ readonly Radius: number;&#125;export class FrameCircleEntity extends FrameEntity&lt;FrameCircleEntityCfg&gt; &#123; protected override onSearchFinder(finder: Array&lt;BattleCharacter&gt;, pos: Vector3, direction: Vector3): Array&lt;BattleCharacter&gt; &#123; let retFinder: Array&lt;BattleCharacter&gt; = new Array&lt;BattleCharacter&gt;(); if (this.entityCfg.Radius &gt; 0) &#123; for (let i = 0; i &lt; this.allList.length; ++i) &#123; // 根据半径判断(省略) &#125; &#125; return retFinder; &#125;&#125; FrameQuadEntity FrameQuadEntity在FrameEntity基础上根据长和宽筛选 123456789101112131415161718export interface FrameQuadEntityCfg extends FrameEntityCfg &#123; /** 长 */ readonly Length: number; /** 宽 */ readonly Width: number;&#125;export class FrameQuadEntity extends FrameEntity&lt;FrameQuadEntityCfg&gt;&#123; protected override onSearchFinder(finder: Array&lt;BattleCharacter&gt;, pos: Vector3, direction: Vector3): Array&lt;BattleCharacter&gt; &#123; let retFinder: Array&lt;BattleCharacter&gt; = new Array&lt;BattleCharacter&gt;(); if (this.entityCfg.Length &gt; 0 &amp;&amp; this.entityCfg.Width &gt; 0) &#123; for (let i = 0; i &lt; finder.length; ++i) &#123; // 根据长和宽判断(省略) &#125; &#125; return retFinder; &#125;&#125; MoveEntity MoveEntity在移动中搜集敌人 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697export interface MoveEntityCfg extends IEntityCfg &#123; /** 搜集的目标数量 */ readonly Nums: number; /** 攻击体模型 */ readonly ModlePrefab: string; /** 攻击触发特效 */ readonly EntityTriggerEffect: string; /** 触发延迟[首次触发时间](s) */ readonly StartTime: number; /** 触发间隔(s) */ readonly Interval: number; /** 实体移动速度 */ readonly Speed: number; /** 实体移动时间(s) */ readonly Time: number; /** 每个目标只攻击一次 */ readonly HitOnlyOnce: boolean;&#125;export class MoveEntity&lt;TMoveCfg extends MoveEntityCfg = MoveEntityCfg&gt; extends BaseEntity&lt;TMoveCfg&gt; &#123; private _entity: GameObject; private _entityPosition: Vector3; private _firstTime: boolean = true; private _entityTimer: number = 0; private _delayTimer: number = 0; private _speed: number; private _time: number; /** 已受击的target */ private _hasHitTargetList: Array&lt;BattleCharacter&gt;; protected override onBuildEntity(): void &#123; this._entityPosition = this.startPosition; this._delayTimer = this.entityCfg.StartTime; this._speed = this.entityCfg.Speed; this._time = this.entityCfg.Time; this._hasHitTargetList = new Array&lt;BattleCharacter&gt;(); /** * 生成模型(省略) */ &#125; protected override onDestroyEntity(): void &#123; /** * 销毁模型(省略) */ &#125; protected override onUpdate(fTick: number): void &#123; if (this._time === 0) &#123; this.setEntityDead(); return; &#125; if (this._time &gt;= fTick) &#123; this._time -= fTick; &#125; else &#123; fTick = this._time; this._time = 0; &#125; if (this._delayTimer &gt; fTick) &#123; this._delayTimer -= fTick; &#125; else &#123; let offset: Vector3 = Vector3.mul(this.startDirection, this._speed * fTick); this._entityPosition = Vector3.add(this._entityPosition, offset); /** * 更新模型位置(省略) */ this._delayTimer = 0; if (this._firstTime || this._entityTimer &gt;= this.entityCfg.Interval) &#123; this._processEntity(); /** * 播放模型特效(省略) */ if (this._firstTime) this._firstTime = false; else this._entityTimer -= this.entityCfg.Interval; &#125; else &#123; this._entityTimer += fTick; &#125; &#125; &#125; private _processEntity(): void &#123; let finder = this.searchTargets(this._entityPosition, this.startDirection, this.entityCfg.Nums); /** * 判断是否每个目标只打一次（省略） */ this.targetList.contact(finder); &#125;&#125; MoveCircleEntity MoveCircleEntity在MoveEntity基础上根据半径筛选 12345678910111213141516export interface MoveEntityCircleCfg extends MoveEntityCfg &#123; /** 半径 */ readonly Radius: number;&#125;export class MoveCircleEntity extends MoveEntity&lt;MoveEntityCircleCfg&gt;&#123; protected override onSearchFinder(finder: Array&lt;BattleCharacter&gt;, pos: Vector3, direction: Vector3): Array&lt;BattleCharacter&gt; &#123; let retFinder: Array&lt;BattleCharacter&gt; = new Array&lt;BattleCharacter&gt;(); if (this.entityCfg.Radius &gt; 0) &#123; for (let i = 0; i &lt; this.allList.length; ++i) &#123; // 根据半径判断(省略) &#125; &#125; return retFinder; &#125;&#125; FollowEntity FollowEntity在创建时候确定目标，朝着目标移动，直到碰撞到目标单位为止 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export interface FollowEntityCfg extends IEntityCfg &#123; /** 实体按规则锁定的第几个敌人（从1开始计数） */ readonly OrderNum: number; /** 实体模型 */ readonly ModlePrefab: string; /** 实体速度 */ readonly Speed: number; /** 实体最大持续时间 */ readonly Time: number;&#125;export class FollowEntity&lt;TFollowEntity extends FollowEntityCfg = FollowEntityCfg&gt; extends BaseEntity&lt;TFollowEntity&gt; &#123; private _entity: GameObject; private _target: BattleCharacter; private _speed: number; private _time: number; private _entityPosition: Vector3; protected override onBuildEntity(): Promise&lt;void&gt; &#123; this._target = this.searchTarget(this.startPosition, this.startDirection, this.entityCfg.OrderNum); this._speed = this.entityCfg.Speed; this._time = this.entityCfg.Time; this._entityPosition = this.startPosition; /** * 生成模型(省略) */ &#125; protected override onDestroyEntity(): void &#123; /** * 销毁模型(省略) */ &#125; protected override onUpdate(dt: number): void &#123; if (this._time === 0) &#123; this.setEntityDead(); return; &#125; if (this._time &gt;= dt) &#123; this._time -= dt; &#125; else &#123; dt = this._time; this._time = 0; &#125; /** 没有敌人或者敌人死亡就朝着既定方向飞去 */ if (!this._target || this._target.battleHPComp.isDying) &#123; let offset: Vector3 = Vector3.mul(this.startDirection, this._speed * dt); this._entityPosition = Vector3.add(this._entityPosition, offset); &#125; else &#123; this._entityPosition = Vector3.moveTowards(this._entityPosition, this._target.animComp.hitPosition, this._speed * dt); &#125; /** * 更新模型位置(省略) */ this._processEntity(); &#125; private _processEntity(): void &#123; /** * 判断是否击中目标，途中可能目标死亡，或者无敌隐身等等 */ &#125;&#125; 实体拓展 以上列出了一些Entity供参考，可以根据技能需求设计各种实体，如BounceEntity（传播实体，子弹可以在目标之前传导），HookEntity（钩子实体，可以像绳索一样套住目标），每一种实体也可以根据形状，发射轨迹等等因素不断拓展，如FollowEntity可以有弧形轨迹，直线轨迹等等，具体可以根据项目不断拓展。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十九) 技能设计-Action发射器","slug":"放置类卡牌战斗-(十九)-技能设计-Action发射器","date":"2022-01-10T16:33:28.000Z","updated":"2022-02-01T14:12:36.037Z","comments":true,"path":"放置类卡牌战斗-(十九)-技能设计-Action发射器/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B9%9D)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%91%E5%B0%84%E5%99%A8/","excerpt":"","text":"点我回到首页 前言 从前文中可以看出，Emit（发射器）在Action初始化阶段就生成用于产生Entity（攻击实体），下面主要讲一些Emit的实现。 场景分析 下面通过几个游戏中常见的技能，根据这些技能来设计Emit 战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。 药师在我方阵形最中间的单位脚下播种一块治疗草，处于治疗草范围的友方单位每秒回血。 朝前方连续射三支箭，分别打向随机的敌人。 从Emit角度简单分析上面列举的几个技能，会发现Action需要先根据一定的规则选择一个目标单位，以该目标单位为基准点架设Emit（也可能会在该基准点周围一定偏移位置，如最近的友方单位前5米处释放xxx），并设置好发射的实体数量（一次伤害，5秒内每秒回血），按照某种规则，如每隔一段时间发射（治疗草每秒回血），一次性发射完（射三支箭）等等，并且需要给发射的实体设置位置，方向等信息。 发射器设计发射器配置 下面来实现一个通用的发射器，首先是发射器的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142/** 发射规则 */export enum EmitRuleType &#123; /** 间隔发射 */ Interval = &quot;Interval&quot;, /** 同时发射 */ SameTime = &quot;SameTime&quot;,&#125;/** 发射器方向类型 */export enum EEmitterDirType &#123; /** 自己朝向 */ SelfDir = &quot;SelfDir&quot;, /** 目标朝向 */ TargetDir = &quot;TargetDir&quot;, /** 自己和目标连线朝向 */ SelfAndTargetDir = &quot;SelfAndTargetDir&quot;, /** 目标和自己连线朝向 */ TargetAndSelfDir = &quot;TargetAndSelfDir&quot;,&#125;/** 发射器需要根据规则选择某一个单位 */export interface IEmitTargetCfg extends IBattleTargetCfg &#123; /** 第几个单位 */ readonly OrderNum: number;&#125;/** 简单的发射器规则 */export interface IEmitCfg extends IEmitTargetCfg &#123; /** 发射数量 */ readonly Num: number; /** 发射间隔 */ readonly Interval: number; /** 发射类型 */ readonly Type: EmitRuleType; /** 发射器初始方向类型 */ readonly DirType: EEmitterDirType; /** 发射器初始位置相对位置 */ readonly EmitOffset: Vector3; /** 发射器初始位置相对朝向 */ readonly EmitRotation: Vector3;&#125; 发射器实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export abstract class BaseEmit&lt;TCfg extends IEmitCfg = IEmitCfg&gt; &#123; /** 属于Action */ private b_action: BaseBattleAction; /** 发射器配置 */ private b_emitCfg: TCfg; /** 发射时间计数 */ private b_emitTimer: number = 0; /** 是否第一次发射 */ private b_firstTime: boolean = true; /** 发射数量计数 */ private b_curNum: number = 0; constructor(action: BaseBattleAction) &#123; this.b_action = action; this.b_emitCfg = action.actionCfg.EmitProperty as TCfg; &#125; public init(): void &#123; this.b_curNum = 0; this.b_emitTimer = 0; this.b_firstTime = true; this.onInit(); &#125; public update(dt: number): void &#123; if (this.isEmitDead) return; /** 第一次直接发射，有间隔则延迟间隔发射 */ if (this.b_firstTime || this.b_emitTimer &gt;= this.emitCfg.Interval) &#123; switch (this.emitCfg.Type) &#123; case EmitRuleType.Interval: this._createActionEntity(); break; case EmitRuleType.SameTime: for (let i = 0; i &lt; this.emitCfg.Num; ++i) &#123; this._createActionEntity(); &#125; break; &#125; if (this.b_firstTime) this.b_firstTime = false; else this.b_emitTimer -= this.emitCfg.Interval; &#125; else &#123; this.b_emitTimer += dt; &#125; this.onUpdate(dt); &#125; /** 创造攻击实体 */ private _createActionEntity(): void &#123; this.b_action.createActionEntity(this.calStartPosition(), this.calStartRotation()); this.b_curNum++; &#125; public dispose() &#123; this.onDispose(); &#125;; protected onInit(): void &#123; &#125;; protected onUpdate(dt: number): void &#123; &#125;; protected onDispose(): void &#123; &#125;; protected abstract calStartPosition(): Vector3; protected abstract calStartRotation(): Vector3; protected get emitCfg() &#123; return this.b_emitCfg; &#125; /** 发射完所有实体死亡 */ public get isEmitDead(): boolean &#123; return this.b_curNum === this.emitCfg.Num; &#125;&#125; 发射器分类 可以看到抽象出了三个计算位置方向信息的函数用于子类实现，实际运用中可以根据发射的类型，给发射器分类，如: 1234567export enum EEmitType &#123; None = &quot;None&quot;, /** 普通攻击 */ Normal = &quot;Normal&quot;, /** 弧状攻击 */ ARC = &quot;ARC&quot;&#125; 下面实现一个普通发射器NormalEmit，根据锁敌规则计算出target并得出方向信息 12345678910111213141516171819202122232425export interface INormalEmitCfg extends IEmitCfg &#123;&#125;export class NormalEmit extends BaseEmit&lt;INormalEmitCfg&gt; &#123; private _target: BattleCharacter; protected override onInit(): void &#123; // 根据规则计算出target this._target = this.owner.battleComp.filterTargetByNum(this.owner.battleComp.allList, this.emitCfg.OrderNum, this.emitCfg); &#125; /** * 计算初始的发射位置 */ protected calStartPosition(): Vector3 &#123; // 根据target 计算初始位置 &#125; /** * 计算初始的发射朝向 */ protected calStartRotation(isUseEmitRotation: boolean = true): Vector3 &#123; // 根据target 计算初始朝向 &#125;&#125; 发射器拓展 以上只是简单列举了一些思路，具体实现还需要结合实际表现进行调整，发射器的配置也是可以不断拓展的，如可以选择一块区域随机发射。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十八) 技能设计-Action整体","slug":"放置类卡牌战斗-(十八)-技能设计-Action整体","date":"2022-01-10T09:59:55.000Z","updated":"2022-02-01T14:12:08.123Z","comments":true,"path":"放置类卡牌战斗-(十八)-技能设计-Action整体/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AB)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%95%B4%E4%BD%93/","excerpt":"","text":"点我回到首页 前言 相对于无生命周期的ActionEvent，有生命周期的Action就会复杂很多，这里需要引入三个新概念Emit（发射器），Entity（攻击实体），HitFeedback（受击反馈），下面将会逐一介绍这些概念。 概念解析 在解释这些名词之前，先举几个例子帮助理解： 一名厨师手拿厨刀朝着砧板上的食物剁了一刀，食物被剁成两半。 一名猎人手拿猎枪朝着远方的猎物发射了一颗子弹，片刻之后，子弹击中猎物，猎物受伤倒下。 一名医生手拿针管朝着面前的病人注射了一针麻醉药，病人被打完针以后睡着了。 下面把这几个例子都当作Action，可以找寻他们的共同点，这些Action都有ActionOwner（厨师，猎人，医生），并且都用Emit发射器（厨师的刀，猎人的枪，医生的针）发射出了Entity攻击实体（厨刀挥出的一刀，猎枪发射的子弹，针管注射的一针），并且都依靠Entity攻击实体搜寻到了目标单位（厨刀剁到的食物，子弹击中的猎物，针管注射到的病人），并对这些目标单位施加了HitFeedback受击反馈（食物被剁成了两半，猎物中枪受伤了，病人被打完针睡着了）。 由上面的例子，可以看出一个Action会由ActionOwner执行，并且产生一个Emit发射器，Emit发射器会发射出Entity攻击实体，Entity攻击实体会依照一定条件搜寻目标，并对找寻的目标施加一定的受击反馈。 ActionOwner：Action执行者 Emit: Action的依托载体，用于按照一定规则产生Entity Entity: 由Emit发射出，用于按照一定规则搜集目标单位 HitFeedback: 对Entity搜集到的目标单位施加的一定反馈 战斗Action战斗Action选取目标规则 战斗中Action的规则可以有如下几个维度，目标站边类型，目标召唤物选取类型，按规则排序， 召唤物规则排序等等 1234567891011121314151617181920212223242526272829303132333435363738export enum ETargetSideType &#123; /** 我方 */ MySide = &quot;MySide&quot;, /** 敌方 */ OtherSide = &quot;OtherSide&quot;, /** 所有人 */ AllSide = &quot;AllSide&quot;&#125;export enum ECondsSortType &#123; /** 自己 */ Self = &quot;Self&quot;, /** 离我最近-&gt;离我最远 */ NearToMe = &quot;NearToMe&quot;, /** 离我最远-&gt;离我最近 */ FarToMe = &quot;FarToMe&quot;, /** 血量百分比低-&gt;高 */ HPPer_LowToHigh = &quot;HPPer_LowToHigh&quot;, /** 血量百分比高-&gt;低 */ HPPer_HighToLow = &quot;HPPer_HighToLow&quot;, /** 攻击力百分比低-&gt;高 */ ATK_LowToHigh = &quot;ATK_LowToHigh&quot;, /** 攻击力百分比高-&gt;低 */ ATK_HighToLow = &quot;ATK_HighToLow&quot;, /** 防御百分比低-&gt;高 */ DEF_LowToHigh = &quot;DEF_LowToHigh&quot;, /** 防御百分比高-&gt;低 */ DEF_HighToLow = &quot;DEF_HighToLow&quot;,&#125;export interface IBattleTargetCfg &#123; /** 目标站边类型 */ readonly TargetSideType: ETargetSideType; /** 是否包含我自己 */ readonly IncludeSelf: boolean; /** 按规则排序 */ readonly CondsSortType: ECondsSortType;&#125; 战斗Action释放者 由于战斗中的Action释放者可能由很多种（目前来说是角色和宝物），所以需要抽象一层接口 IBattleActionOwner，（这也是为什么宝物设计和角色设计高度相似的原因之一）。 123456789101112131415161718192021222324export interface IBattleActionOwner extends IActionOwner &#123; /** 站边类型 */ sideType: BattleSideType; battleComp: &#123; /** 所有目标单位 */ allList: Array&lt;BattleCharacter&gt;; /** 判断是否可以选中目标 */ judgeCanSelectTarget(target: BattleCharacter): boolean; /** 根据一定规则选择一群目标 */ filterTargetsByNums(toFilters: Array&lt;BattleCharacter&gt;, nums: number, battleTargetCfg: IBattleTargetCfg): Array&lt;BattleCharacter&gt;; /** 根据一定规则选择一个目标 */ filterTargetByNum(toFilters: Array&lt;BattleCharacter&gt;, orderNum: number, battleTargetCfg: IBattleTargetCfg): BattleCharacter; &#125;; /** 属性 */ attrComp: &#123; attr: BaseAttr; baseAttr: BaseAttr; &#125;;&#125;/** 战斗角色实现 IBattleActionOwner 接口 */export class BattleCharacter extends BaseCharacter implements IBattleActionOwner &#123;&#125;/** 战斗宝物实现 IBattleActionOwner 接口 */export class BattleTreasure implements IBattleActionOwner &#123;&#125; 战斗Action配置 战斗Action的配置可以分为三个模块，发射器配置模块，实体配置模块，受击反馈配置模块 1234567891011121314export interface IBattleActionCfg extends IActionCfg &#123; /** 发射器类型 */ readonly EmitType: EEmitType; /** 发射器配置 */ readonly EmitProperty: IEmitCfg; /** 发射的实体类型 */ readonly EntityType: EEntityType; /** 发射的实体配置 */ readonly EntityProperty: IEntityCfg; /** 受击反馈配置 */ readonly HitFeedbackProperty: IHitFeedbackCfg;&#125; 战斗Action实现 根据之前的剖析，可以将战斗Action轮廓给勾勒出来，具体的Emit，Entity，HitFeedback留在后文阐述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106export abstract class BaseBattleAction&lt;TOwner extends IBattleActionOwner = IBattleActionOwner, TCfg extends IBattleActionCfg = IBattleActionCfg&gt; extends BaseAction&lt;TOwner, TCfg&gt; &#123; /** 发射器 */ private _emit: BaseEmit; /** 攻击体 */ private _entityList: Array&lt;BaseEntity&gt;; /** 目标列表 */ private _targetList: Array&lt;BattleCharacter&gt;; /** 受击反馈 */ protected hitFeedback: HitFeedback; /** 延迟时间 */ protected delayTime: number = 0; protected override onInit(args?: any[]): void &#123; this._entityList = new Array&lt;BaseEntity&gt;(); this._targetList = new Array&lt;BattleCharacter&gt;(); /** * 初始化的时候根据EmitType类型创建发射器的类型 */ this._emit &amp;&amp; this._emit.init(); this.hitFeedback = new HitFeedback(this); this.onBattleInit(args); &#125; protected override onUpdate(dt: number): void &#123; if (this.delayTime &gt; dt) &#123; this.delayTime -= dt; &#125; else &#123; this._updateEmit(dt); this._updateEntity(dt); this.updateHit(); this.checkDead(); &#125; &#125; public createActionEntity(startPosition: Vector3, startDirection: Vector3): void &#123; let entity: BaseEntity = null; /** * 根据实体类型创建实体 */ if (entity) &#123; // 实体初始化位置方向信息 entity.init(startPosition, startDirection); this._entityList.push(entity); &#125; &#125; /** 发射器驱动，以创建新的实体 */ private _updateEmit(dt: number): void &#123; this._emit.update(dt); &#125; /** 实体驱动，以收集受到实体影响的目标单位 */ private _updateEntity(dt: number): void &#123; for (let i = 0; i &lt; this._entityList.length; ++i) &#123; this._entityList[i].update(dt); &#125; &#125; /** 对受到实体影响的目标单位 加以受击反馈 */ protected updateHit(): void &#123; for (let i = 0; i &lt; this._targetList.length; ++i) &#123; this.onHit(this._targetList[i]); &#125; this._targetList.length = 0; &#125; protected onHit(target: BattleCharacter): void &#123; this.hitFeedback.hitApply(target); &#125; /** 检查Action结束，发射器发射完所有实体，所有实体搜集完目标 则结束 */ protected checkDead(): void &#123; let dead: boolean = true; for (let i = 0; i &lt; this._entityList.length; ++i) &#123; if (!this._entityList[i].isEntityDead) &#123; dead = false; break; &#125; &#125; if (dead &amp;&amp; this._emit.isEmitDead) this.setActionEnd(); &#125; protected override onDispose(): void &#123; if (this._emit) &#123; this._emit.dispose(); this._emit = null; &#125; for (let i = 0; i &lt; this._entityList.length; ++i) &#123; this._entityList[i].dispose(); &#125; this._entityList.length = 0; this._targetList.length = 0; &#125; protected onBattleInit(...args: any[]) &#123; &#125; public get targetList() &#123; return this._targetList; &#125;&#125; 战斗Action应用角色Action 角色的Action主要考虑当角色技能被打断（眩晕，冰冻等）时，就终止整个技能中Action 123456789101112131415161718192021222324252627/** 角色战斗action */export interface ICharBattleActionCfg extends IBattleActionCfg, ICharActionCfg &#123; /** 是否在Action切换后消失 */ readonly DeadActionChanged: boolean; /** 事件的触发时间 */ readonly TriggerTime: number; /** 延迟时间发射 */ readonly Delay: number;&#125;export class CharBattleAction extends BaseBattleAction&lt;BattleCharacter, ICharBattleActionCfg&gt; &#123; private _aiState: string = &quot;&quot;; public override onBattleInit(aiState: string): void &#123; this._aiState = aiState; this.delayTime = this.actionCfg.Delay; &#125; protected override checkDead(): void &#123; /** 如果动作过程中被打断，则攻击也会被判定失效 */ if (this.actionCfg.DeadActionChanged &amp;&amp; this.actionOwner.aiComp.curAIState.aiStateConfig.AIState !== this._aiState) &#123; this.setActionEnd(); return; &#125; super.checkDead(); &#125;&#125; 宝物Action 宝物的Action主要是对于被动属性宝物需要记录一下搜集的目标列表，用于角色死亡时需要重新选择目标单位，并将之前的目标单位的属性Buff移除。 12345678910111213141516export interface ITreasureActionCfg extends IBattleActionCfg &#123;&#125;export class TreasureAction extends BaseBattleAction&lt;BattleTreasure, ITreasureActionCfg&gt; &#123; protected override updateHit() &#123; if (!this.actionOwner.isActive) &#123; let skillComp = this.actionOwner.skillComp; for (let i = 0; i &lt; this.targetList.length; ++i) &#123; if (skillComp.skillTargetList.indexOf(this.targetList[i]) &lt; 0) &#123; skillComp.skillTargetList.push(this.targetList[i]); &#125; &#125; &#125; super.updateHit(); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十七) 技能设计-ActionEvent","slug":"放置类卡牌战斗-(十七)-技能设计-ActionEvent","date":"2022-01-10T09:45:41.000Z","updated":"2022-01-26T18:18:42.982Z","comments":true,"path":"放置类卡牌战斗-(十七)-技能设计-ActionEvent/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%83)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-ActionEvent/","excerpt":"","text":"点我回到首页 前言 前面介绍了ActionEvent代表了技能中的无生命周期的行为，一般用来实现技能中例如播放动作，播放特效的行为，下面介绍几个简单的实现。 角色ActionEvent基类 12345678910111213141516171819202122export enum ECharActionEventType &#123; /** 播放动作 */ PlayAnim = &quot;PlayAnim&quot;, /** 播放特效 */ PlayEffect = &quot;PlayEffect&quot;,&#125;export interface ICharActionEventCfg extends IActionEventCfg &#123; /** 触发时间 */ TriggerTime: number; /** 事件类型 */ EventType: ECharActionEventType; /** 事件数据 */ EventData: ICharActionEventData;&#125;export interface ICharActionEventData &#123; &#125;export abstract class BaseCharActionEvent&lt;TData extends ICharActionEventData = ICharActionEventData, TOwner extends BaseCharacter = BaseCharacter&gt; extends BaseActionEvent&lt;TOwner, ICharActionEventCfg&gt; &#123; protected get data(): TData &#123; return this.cfg.EventData as TData; &#125;&#125; 样例 这里实现一个角色播放动作的样例： 1234567891011121314export interface EventPlayAnimData extends ICharActionEventData &#123; /** 动作 */ readonly AnimName: string; /** 播放速度 */ readonly AnimSpeed: number; /** 融合时间 */ readonly FadeTime: number;&#125;export class EventPlayAnim extends BaseCharActionEvent&lt;EventPlayAnimData&gt; &#123; protected override onExecute(): void &#123; this.owner.animComp.playAnimation(this.data.AnimName, this.data.AnimSpeed, this.data.FadeTime); &#125;&#125; 拓展 游戏中很多行为都可以是ActionEvent，如：释放技能中的播放声音，播放特效，镜头抖动等等，也可以修改角色位移参数，角色传送参数，角色方向参数等等","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十六) 技能基础和管理","slug":"放置类卡牌战斗-(十六)-技能基础和管理","date":"2022-01-10T08:20:20.000Z","updated":"2022-01-26T18:18:46.073Z","comments":true,"path":"放置类卡牌战斗-(十六)-技能基础和管理/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AD)-%E6%8A%80%E8%83%BD%E5%9F%BA%E7%A1%80%E5%92%8C%E7%AE%A1%E7%90%86/","excerpt":"","text":"点我回到首页 前言 前面的章节中讲述了角色和宝物的技能释放时机，接下来的几个章节会详细讲述技能的具体实现。 Action和ActionEvent 从前面角色AI相关的介绍中，我们可以看出来角色的技能是由若干Action（有生命周期行为，如发射一颗子弹，子弹是具有生命周期的）和若干ActionEvent（无生命周期行为，如播放一个动作，是没有生命周期的），这里先有个概念，后面会详细说明，例如一个简单的技能配置可能为： 123456789101112131415161718192021222324252627&#123; &quot;ActionEventList&quot;:[ &#123; &quot;TriggerTime&quot; : 0, &quot;EventType&quot; : &quot;PlayAnim&quot;, &quot;EventData&quot; : &#123; &quot;AnimName&quot; : &quot;BattleSkill&quot;, &#125; &#125;, &#123; &quot;TriggerTime&quot; : 40, &quot;EventType&quot; : &quot;PlayEffect&quot;, &quot;EventData&quot; : &#123; &quot;EffectName&quot; : &quot;XXX&quot;, &#125; &#125;, ], &quot;ActionList&quot; : [ &#123; &quot;TriggerTime&quot; : 40, &quot;TargetSideType&quot; : &quot;OtherSide&quot;, &quot;CondsSortType&quot; : &quot;NearToMe&quot;, &quot;Nums&quot; : 1, &quot;HitDamage&quot; : 10 &#125; ]&#125; 如图上的配置表示一个技能 在0ms时候播放一个”BattleSkill”的动作， 在40ms时候播放一个”XXX”的特效， 在40ms时候朝着敌方(OtherSide)离我最近(NearToMe)的一个(1)单位发射一颗子弹打出10点(10)伤害。 需求分析 有了对Action和ActionEvent大概印象，现在分析项目中的需求，如图所示： 需要一个基类BaseAction和BaseActionEvent，并且需要有一个Action和ActionEvent工厂，并对他们的生命周期进行管理。 ActionEvent实现 需要含有事件的拥有者和事件的配置： 123456789101112131415161718192021222324/** 事件拥有者 */export interface IActionEventOwner &#123; &#125;/** 事件配置 */export interface IActionEventCfg &#123; &#125;export abstract class BaseActionEvent&lt;TOwner extends IActionEventOwner = IActionEventOwner, TCfg extends IActionEventCfg = IActionEventCfg&gt; &#123; protected actionSP: ActionSP; protected owner: TOwner; protected cfg: TCfg; constructor(actionSP: ActionSP, owner: IActionEventOwner, cfg: IActionEventCfg) &#123; this.actionSP = actionSP; this.owner = owner as TOwner; this.cfg = cfg as TCfg; &#125; /** 事件执行 */ public execute(): void &#123; this.onExecute(); &#125; protected onExecute(): void &#123; &#125;&#125; Action实现 同样Action也需要拥有者和配置信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** Action基础配置 */export interface IActionCfg &#123; &#125;/** Action拥有者 */export interface IActionOwner &#123; &#125;export abstract class BaseAction&lt;TOwner extends IActionOwner = IActionOwner, TCfg extends IActionCfg = IActionCfg&gt; &#123; private b_actionSP: ActionSP; /** action拥有者 */ private b_actionOwner: TOwner; /** action配置 */ private b_actionCfg: TCfg; /** action结束 */ private b_isActionDead: boolean; constructor(actionSP: ActionSP, owner: IActionOwner, actionCfg: IActionCfg) &#123; this.b_actionSP = actionSP; this.b_actionOwner = owner as TOwner; this.b_actionCfg = actionCfg as TCfg; &#125; public init(args?: any[]): void &#123; this.b_isActionDead = false; this.onInit.apply(this, args); &#125; public update(dt: number): void &#123; this.onUpdate(dt); &#125; public dispose(): void &#123; this.b_actionCfg = null; this.b_actionOwner = null; this.onDispose(); &#125; protected setActionEnd(): void &#123; this.b_isActionDead = true; &#125; protected onInit(...args: any[]): void &#123; &#125;; protected onUpdate(dt: number): void &#123; &#125; protected onDispose(): void &#123; &#125; public get isActionDead(): boolean &#123; return this.b_isActionDead; &#125; public get actionSP(): ActionSP &#123; return this.b_actionSP; &#125; public get actionOwner(): TOwner &#123; return this.b_actionOwner; &#125; public get actionCfg(): TCfg &#123; return this.b_actionCfg; &#125;&#125; Action和ActionEvent管理 同角色宝物一样，需要提供一个工厂和生命周期管理的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export enum EActionType &#123; Invalid = 0, /** 角色 **/ BattleCharacter = 1, /** 宝物 **/ BattleTreasure = 2,&#125;export enum EActionEventType &#123; Character = 1,&#125;export class ActionSP extends SceneProcessorBase &#123; private _actionList: Array&lt;BaseAction&gt;; protected override onInit(): void &#123; this._actionList = new Array&lt;BaseAction&gt;(); &#125; protected override onUpdate(dt: number): void &#123; // 更新所有Action 并移除已经死亡的Action &#125; protected override onDestroy(): void &#123; // 销毁所有Action &#125; public createAction(actionType: EActionType, actionOwner: IActionOwner, actionCfg: IActionCfg, ...args: any[]): void &#123; let action: BaseAction; switch (actionType) &#123; case EActionType.BattleCharacter: action = new CharBattleAction(this, actionOwner, actionCfg); break; case EActionType.BattleTreasure: action = new TreasureAction(this, actionOwner, actionCfg); break; // 其他类型Action &#125; if (action) &#123; action.init(args); this._actionList.push(action); &#125; &#125; /** 事件是一种一触即发的action */ public createActionEvent(actionEventType: EActionEventType, eventOwner: IActionEventOwner, eventCfg: IActionEventCfg) &#123; switch (actionEventType) &#123; case EActionEventType.Character: switch ((eventCfg as ICharActionEventCfg).EventType) &#123; case ECharActionEventType.PlayAnim: return new EventPlayAnim(this, eventOwner, eventCfg); case ECharActionEventType.PlayEffect: return new EventPlayEffect(this, eventOwner, eventCfg); // 其他角色ActionEvent &#125; break; // 其他类型ActionEvent &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十五) 宝物设计-战斗技能","slug":"放置类卡牌战斗-(十五)-宝物设计-战斗技能","date":"2022-01-10T07:32:10.000Z","updated":"2022-01-26T18:18:32.869Z","comments":true,"path":"放置类卡牌战斗-(十五)-宝物设计-战斗技能/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%94)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/","excerpt":"","text":"点我回到首页 前言 宝物的技能组件也是负责宝物的技能释放时机，具体的技能实现机制会在后面和角色技能一起阐述， 宝物的技能分为主动技能和被动技能，在释放时机的处理上需要区分开来。 技能基类 不管主动宝物还是被动宝物，技能的释放接口是一致的。 12345678export class TreasureSkillComponent extends TreasureComponent &#123; /** 技能释放目标集合 */ public skillTargetList: Array&lt;BattleCharacter&gt;; /** 释放技能 */ public castSkill(): void &#123; // 省略细节 &#125;&#125; 被动技能 目前仅根据需求实现了被动Buff技能组件，需要在角色死亡时更换技能释放目标。 12345678910111213141516171819export class TreasurePassiveBuffSkillComponent extends TreasureSkillComponent &#123; protected override onInit(): void &#123; this.skillTargetList = []; // 监听宿主列表的角色死亡事件 this.castSkill(); &#125; /** 处理角色死亡事件 */ private _onHandelCharacterChange(character: BattleCharacter): void &#123; if (character.sideType !== this.treasure.sideType) &#123; return; &#125; for (let target of this.skillTargetList) &#123; target.battleBuffComp.removeBuffByCaster(this.treasure); &#125; this.skillTargetList = []; this.castSkill(); &#125;&#125; 主动技能 主动技能需要满足条件后释放（目前只有cd，可以空放），并且在释放完以后需要重置宝物技能cd 123456789101112131415161718192021222324252627282930313233343536373839export class TreasureActiveSkillComponent extends TreasureSkillComponent &#123; /** 技能总CD时间 */ private _totalCoolDown: number = 0; /** 技能剩余CD时间 */ private _coolDown: number = 0; protected override onInit(): void &#123; this._resetCoolDown(); &#125; protected override onUpdate(dt: number): void &#123; if (this._coolDown &gt; 0) &#123; this._coolDown = this._coolDown &gt; dt ? this._coolDown - dt : 0; &#125; // 检查自动战斗 &#125; /** 重置cd */ private _resetCoolDown(): void &#123; this._totalCoolDown = this.treasure.treasureDef.CoolDown; this._coolDown = this.treasure.treasureDef.CoolDown; &#125; /** 判断宝物技能是否可以释放 */ public judgeCanTreasureCast(): boolean &#123; if (this.inCoolDown) return false; return true; &#125; /** 释放技能并重置cd */ public override castSkill(): void &#123; super.castSkill(); this._resetCoolDown(); &#125; public get inCoolDown(): boolean &#123; return this._coolDown &gt; 0; &#125; public get coolDown(): number &#123; return this._coolDown; &#125; public get coolDownPer(): number &#123; return this._totalCoolDown === 0 ? 0 : this._coolDown / this._totalCoolDown; &#125;&#125; 组件应用 在创建时候可以根据宝物类型添加不同的技能组件 123456789treasure.battleComp = treasure.addComponent(TreasureBattleCompontent, hostList);treasure.attrComp = treasure.addComponent(TreasureAttrCompontent);if (treasureDef.TreasureType === TreasureType.Active) &#123; treasure.skillComp = treasure.addComponent(TreasureActiveSkillComponent);&#125; else if (treasureDef.TreasureType === TreasureType.PassiveBuff) &#123; treasure.skillComp = treasure.addComponent(TreasurePassiveBuffSkillComponent);&#125; else &#123; // 其他类型&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十四) 宝物设计-战斗宿主","slug":"放置类卡牌战斗-(十四)-宝物设计-战斗宿主","date":"2022-01-10T07:10:58.000Z","updated":"2022-01-26T18:18:36.190Z","comments":true,"path":"放置类卡牌战斗-(十四)-宝物设计-战斗宿主/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%9B%9B)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%AE%BF%E4%B8%BB/","excerpt":"","text":"点我回到首页 前言 前文也说过宝物在战斗中需要依赖宿主，虽然大多数信息是可以直接从宿主身上获取，但是类似锁敌机制是需要有宝物独立的一套机制，例如：宝物是不会被嘲讽的，宝物也不会选取自己为目标等等。 绑定宿主 宝物的战斗组件主要实现的机制为根据给定的宿主列表寻找最前方的宿主，并提供锁敌机制。 12345678910111213141516171819202122232425262728293031export class TreasureBattleCompontent extends TreasureComponent &#123; private _hostList: Array&lt;BattleCharacter&gt;; private _host: BattleCharacter; protected override onInit(hostList: Array&lt;BattleCharacter&gt;) &#123; this._hostList = hostList; this._host = this._getFrontHost(); &#125; protected override onUpdate(dt: number): void &#123; this._host = this._getFrontHost(); &#125; public judgeCanSelectTarget(target: BattleCharacter): boolean &#123; return this.host.battleComp.judgeCanSelectTarget(target); &#125; /** 绑定最前排的宿主 */ private _getFrontHost(): BattleCharacter &#123;&#125; /** 根据条件筛选出一群单位 */ public filterTargetsByNums(toFilters: Array&lt;BattleCharacter&gt;, nums: number, battleTargetCfg: IBattleTargetCfg)&#123;&#125; /** 根据条件筛选出一个单位 */ public filterTargetByNum(toFilters: Array&lt;BattleCharacter&gt;, orderNum: number, battleTargetCfg: IBattleTargetCfg)&#123;&#125; /** 宿主 */ public get host(): BattleCharacter &#123; return this._host; &#125; /** 宿主列表 */ public get hostList(): Array&lt;BattleCharacter&gt; &#123; return this._hostList; &#125;&#125; 绑定属性 宝物的基础属性是由所有宿主的基础属性相加所得，并且需要根据角色死亡增加实时更新。 12345678910111213141516171819202122232425262728293031export class TreasureAttrCompontent extends TreasureComponent &#123; /** 总属性 */ private _attr: ssBaseAttr; protected override onInit(): void &#123; this._attr = new ssBaseAttr(); this.syncAttr(); // 监听角色死亡事件 &#125; /** 目前只有攻击，攻击为宿主的攻击总和 */ public syncAttr(): void &#123; this._attr.clear(); for (let host of this.treasure.battleComp.hostList) &#123; if (host.battleHPComp.isDying) continue; this._attr.addValue(AttrID.Attack, host.attrComp.baseAttr.attack); &#125; &#125; /** 有角色改变时需要同步属性 */ private _onHandelCharacterChange(character: BattleCharacter): void &#123; if (character.sideType !== this.treasure.sideType) &#123; return; &#125; this.syncAttr(); &#125; public get attr(): BaseAttr &#123; return this._attr; &#125; public get baseAttr(): BaseAttr &#123; return this._attr; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十三) 宝物管理","slug":"放置类卡牌战斗-(十三)-宝物管理","date":"2022-01-10T06:10:21.000Z","updated":"2022-01-26T18:18:39.026Z","comments":true,"path":"放置类卡牌战斗-(十三)-宝物管理/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%89)-%E5%AE%9D%E7%89%A9%E7%AE%A1%E7%90%86/","excerpt":"","text":"点我回到首页 前言 在介绍角色具体技能的实现机制之前，需要先介绍项目中另外一项机制——宝物，因为宝物的存在，导致技能实现机制在一定程度上需要做出调整。 机制介绍 战斗中玩家可以携带最多三种宝物，每种宝物可以释放一种技能，宝物分被动宝物和主动宝物，被动宝物自动生效，主动宝物自动战斗情况下满足条件自动释放，非自动情况下可以由玩家手动释放。 被动宝物如： 使攻击力最高的2个角色，攻击力增加x%。（有角色死亡自动更换目标） 使所有角色的攻击力增加x%。 本局对战金币额外增加x%。 主动宝物如： 使我方当前体力最低的角色恢复所有角色攻击力x%的体力。 在最近的人处释放一团火炬，并对火炬附近的敌人造成攻击力x%的持续伤害。 使最近的敌人防御降低x%。 宝物管理 从需求来看，宝物相当于一个隐藏角色跟在队伍身边，设计上也需要像角色一样对宝物进行生命周期的管理，并且也需要区分我方宝物和敌方宝物（pvp）。 1234567891011121314151617181920212223242526272829export class BattleTreasureSP extends SceneProcessorBase&lt;BattleScene&gt; &#123; public playerTreasures: Array&lt;BattleTreasure&gt; = []; public enemyTreasures: Array&lt;BattleTreasure&gt; = []; protected override onInit(): void &#123; this.playerTreasures = []; this.enemyTreasures = []; &#125; protected override onUpdate(dt: number): void &#123; for (let playerTreasure of this.playerTreasures) &#123; playerTreasure.update(dt); &#125; for (let enemyTreasure of this.enemyTreasures) &#123; enemyTreasure.update(dt); &#125; &#125; public createTreasure(sideType: BattleSideType, treasureID: number) &#123; let treasure: BattleTreasure; // 省略细节 if (treasure.isPlayerSide) &#123; this.playerTreasures.push(treasure); &#125; else &#123; this.enemyTreasures.push(treasure); &#125; return treasure; &#125;&#125; 宝物基础 和角色的设计一样，也采取组件机制。 12345678910111213141516171819202122232425export class TreasureComponent &#123; private _treasure: BattleTreasure; protected get treasure(): TTreasure &#123; return this._treasure; &#125; constructor(treasure: BattleTreasure) &#123; super(); this._treasure = treasure; &#125; public init(args?: any[]): void &#123; this.onInit.apply(this, args); &#125; public update(dt: number): void &#123; this.onUpdate(dt); &#125; public destroy(): void &#123; this.onDestroy(); &#125; protected onInit(...args: any[]): void &#123; &#125;; protected onUpdate(dt: number): void &#123; &#125;; protected onDestroy(): void &#123; &#125;;&#125; 由于宝物没有实际的载体，所以在例如最近的敌人之类的计算上，需要将宝物绑定上对应的角色列表，并在角色列表种选取最靠前的角色作为释放技能的载体，即宿主，所以宝物也有部分组件依赖于宿主。 123456/** 宝物属性 */public readonly attrComp: TreasureAttrCompontent;/** 宝物战斗 */public readonly battleComp: TreasureBattleCompontent;/** 宝物技能 */public readonly skillComp: TreasureSkillComponent;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十二) 角色设计-战斗移动","slug":"放置类卡牌战斗-(十二)-角色设计-战斗移动","date":"2022-01-10T02:18:29.000Z","updated":"2022-02-01T14:12:23.686Z","comments":true,"path":"放置类卡牌战斗-(十二)-角色设计-战斗移动/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/","excerpt":"","text":"点我回到首页 前言 角色的移动是否做成组件取决于项目本身的复杂度，如果项目本身只有一个方向的移动，或者移动比较简单，是可以不用单独做成一个组件的，这里笔者根据项目需求在迭代过程中慢慢整合到了一个单独的组件。 组件无状态 由于一般情况下战斗是左右双方交战，战斗中会存在大量判断是否朝左朝右，这里采取和前面战斗组件相同的无状态方式，在组件初始化时，将角色默认初始方向传入，将判断左右的信息由xFactor代替。 123456789101112131415161718192021222324252627282930313233343536373839404142export class CharBattleMoveComponent extends CharacterComponent &#123; private _defaultSpeedRatio: number; private _defaultDirection: Vector3; private _tempDirection: Vector3; protected override onInit(direction = Vector3.right, speedRatio: number = 1): void &#123; speedRatio || (speedRatio = 1); direction || (direction = Vector3.right); this._defaultSpeedRatio = speedRatio; this._defaultDirection = direction; this.character.setDirection(this._defaultDirection); &#125; /** 朝着目标移动一段距离 */ public moveToPos(dt: number, moveDistance: number = 0, position: Vector3): void &#123; // 角色朝着目标移动一定距离 &#125; /** 没有目标移动 */ public move(dt: number, moveDistance: number = 0) &#123; // 角色朝着既定方向移动一段距离 &#125; /** 倒退一段距离 */ public moveBack(x: number): void &#123; // 角色后退一段距离 &#125; /** 设置临时方向 */ public setTempDirection(direction: Vector3): void &#123; this._tempDirection = direction; &#125; /** 速度 */ public get speed(): number &#123; return this.character.attrComp.attr.moveSpeed; &#125; /** 加速比例 */ public get speedRatio(): number &#123; return this._defaultSpeedRatio; &#125; /** 方向 有临时方向用临时方向 */ public get direction(): Vector3 &#123; return this._tempDirection ? this._tempDirection : this._defaultDirection; &#125; /** x轴系数 */ public get xFactor(): number &#123; return this._defaultDirection.x &gt; 0 ? 1 : -1; &#125;&#125; 角色方阵需求剖析 这里由于项目有其他需求还有一些额外的内容，虽然是根据具体项目而来，但是在其中的设计花了不少心思，还是记录一下，先花一点篇幅介绍一下需求，这里需要引入一个新的概念角色方阵。 角色在行走过程中会按照如图所示的方阵行走，注意以上图中所有方块都是一个spaceX*spaceZ的方块，角色是站在方块正中间的，如下图所示： 根据所处位置，会分为前排(1,2,3)，中排(4,5,6)，后排(7,8,9)，角色按照一定的阵形位置入场，每一排最多两个角色，当每排角色为两个时，角色会站在两边，当每排角色为一个时，会站在中间，此规则战斗中有角色死亡也会实时调整。 比如上阵四个角色，前排两个，中排一个，后排一个，他们站位将会是前排站在两边位置(1,3)，中排站在中间位置(5)，后排站在中间位置(8)。如下图所示： 当在战斗中1号位角色死亡时，3号位角色会顺势调整到2号位，如下图所示： 角色会按照方阵阵形行走，当方阵中有人员掉队时，掉队的人员会按照设定好的加速倍率加速追上大部队，如下图所示： 这里有一个细节，也是坑点，由于角色行走是按一定顺序依次执行的，如1号位-&gt;3号位-&gt;5号位-&gt;8号位的顺序，所以需要在所有人行走前计算谁才是最靠前的角色（这里的最靠前指的是方阵相对位置最靠前，并不是物理位置最靠前），如下图是8号位最靠前，而不是物理位置最前面的3号位最靠前： 所以这里需要先计算出8号位是方阵相对位置最靠前的，然后以8号位为基准，其他人全部加速行走到虚线位置。（注意此时8号位玩家也是往前走的，所以其他人必须加速行走才能走到虚线位置） 痛点 可以看出，需要一个地方存储方阵的很多信息，并且存在很多定制化代码，并且当竞技场中出现敌方也有方阵时，会有很多冗余代码并且难以维护，之前的设计中会在BaseBattle中定义Static变量存储方阵信息，代码会非常丑陋。 方案 这里在重构了很多次以后，总算有了比较合适的解决方案: 核心接口 定义接口IBattleSquareMember代表方阵成员 12345678export interface IBattleSquareMember &#123; /** 成员出生位置 */ bornIndex: number; /** 成员是否有效（参与方阵计算） */ isValid: boolean; /** 以该成员为基准的方阵X轴坐标 */ frontlineX: number;&#125; 方阵 设计一个角色方阵BattleSquare用来组织角色方阵内的各种计算 12345678910111213141516171819202122232425262728293031323334353637383940/** 一个战斗方阵(只做了X轴方向的) */export class BattleSquare &#123; /** 方正朝向 */ private _xFactor: number; /** 方阵成员 */ private _squareMembers: Array&lt;IBattleSquareMember&gt;; /** 方阵前方线位置 */ private _squarelinePos: Vector3; /** 方阵x间距 */ private _squareSpaceX: number; /** 方阵z间距 */ private _squareSpaceZ: number; /** 方阵推进速度 */ private _squareSpeed: number; constructor(frontlinePos: Vector3, xFactor: number, speed: number, spaceX: number, spaceZ: number) &#123; this._squarelinePos = frontlinePos; this._xFactor = xFactor; this._squareSpeed = speed; this._squareSpaceX = spaceX; this._squareSpaceZ = spaceZ; this._squareMembers = []; &#125; public addSquareMember(squareMember: IBattleSquareMember) &#123; this._squareMembers.push(squareMember); &#125; public updateFrontline(dt: number): void &#123; // 计算当前最前方位置以及下一次可能的最前方位置 &#125; public getSquareMovePos(bornIndex: number): Vector3 &#123; // 获取方阵中角色应该在的位置 &#125; public get xFactor(): number &#123; return this._xFactor; &#125; public get squarelinePos(): Vector3 &#123; return this._squarelinePos; &#125; public get squareSpeed(): number &#123; return this._squareSpeed; &#125;&#125; 关联角色 现在需要将方阵和角色关联上，也算是整个设计的核心，抽象一层CharBattleSquareMoveComponent，并且将move和moveToPos接口覆盖实现 123456789101112131415161718192021222324252627282930313233/** 专门用于战斗中的方阵移动 */export class CharBattleSquareMoveComponent extends CharBattleMoveComponent implements IBattleSquareMember &#123; /** 方阵出生位置 */ private _bornIndex: number = 0; /** 所处战斗方阵 */ private _battleSquare: BattleSquare; protected override onInit(direction = Vector3.right, speedRatio: number = 1, battleSquare?: BattleSquare, bornIndex?: number): void &#123; super.onInit(direction, speedRatio); this._battleSquare = battleSquare; this._bornIndex = bornIndex; &#125; public override moveToPos(dt: number, moveDistance: number = 0, position: Vector3): void &#123; // 判断是否落后于应该在的位置 加速 （省略实现） &#125; public override move(dt: number, moveDistance: number = 0) &#123; // 判断是否落后于应该在的位置 加速 （省略实现） &#125; /** 方阵角色有死亡修正一下bornIndex */ private _amendBornIndex(): void &#123; this._bornIndex = this._battleSquare.getAmendBornIndex(this._bornIndex); &#125; /** 实现接口，成员出生位置 */ public get bornIndex(): number &#123; return this._bornIndex; &#125; /** 实现接口，角色存活则有效 */ public get isValid(): boolean &#123; return !this.character.battleHPComp.isDying; &#125; /** 实现接口，以该成员为基准的方阵X轴坐标 */ public get frontlineX(): number &#123; return this.character.position.x + this._battleSquare.getOffsetX(this._bornIndex); &#125;&#125; 游戏中应用 这样就可以创建一个方阵 123456789let square = new BattleSquare(bornPos, xFactor, speed, spaceX, spaceZ);let allBornPos = square.getSquareBornPos();for (let i = 0; i &lt; characterIDs.length; ++i) &#123; let character; // 省略细节 character.battleMoveComp = character.addComponent(CharBattleSquareMoveComponent, Vector3.create(xFactor, 0, 0), speedRatio, square, bornIndexs[i]); square.addSquareMember(character.getComponent(CharBattleSquareMoveComponent)); // 省略细节&#125; 这样所有的信息全部内聚在BattleSquare中，并且对于move组件来说，也无需关注使用的是CharBattleSquareMoveComponent还是CharBattleMoveComponent。调用统一的接口move和moveToPos即可。当然这里也可以把move组件包装成抽象组件baseMove，分别实现normalMove和squareMove。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十一) 角色设计-战斗血量","slug":"放置类卡牌战斗-(十一)-角色设计-战斗血量","date":"2022-01-09T17:36:43.000Z","updated":"2022-01-30T11:39:19.106Z","comments":true,"path":"放置类卡牌战斗-(十一)-角色设计-战斗血量/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%80)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E8%A1%80%E9%87%8F/","excerpt":"","text":"点我回到首页 前言 血量模块（即血条，有些游戏还会有能量条，蓝条等等），几乎是每个游戏都会有的设计了，将血量模块单独划分出来，专门处理战斗中血量的变化，并管理角色存活死亡状态，有助于代码上的解耦。 血量(护盾)管理 由于战斗中会有护盾Buff的存在，有护盾Buff时会代替血量扣除，将护盾做成属性，并且和血量一起管理，对外统一暴露changeHP接口会比较方便，并且需要注册监听属性改变消息，当最大血量或者最大护盾改变时，需要对应调整数值。 12345678910111213141516171819202122232425262728293031323334353637export class CharBattleHPComponent extends CharacterComponent &#123; /** 角色处于血量归零 播放死亡动作状态 */ private _isDying: boolean; /** 角色已经播放完死亡动作 */ private _isDead: boolean; private _maxHP: number; private _curHP: number; private _maxShiled: number; private _curShield: number; protected override onInit(): void &#123; this._isDying = false; this._isDead = false; this._maxHP = this._curHP = this.character.attrComp.attr.hp; // 血条 // 监听角色的属性改变事件 &#125; // 统一扣血接口 血量归零就死亡 public changeHP(num: number, ignoreSheild: boolean = false) &#123;&#125; // 扣护盾 private _changeHPShield(num: number) &#123;&#125; // 处理角色属性改变 private _onHandleAttrChange(): void &#123; // 处理护盾最大值改变 // 处理血量最大值改变 &#125; public get hp() &#123; return this._curHP; &#125; public get hpShield() &#123; return this._curShield; &#125; public get isDead(): boolean &#123; return this._isDead; &#125; public get isDying(): boolean &#123; return this._isDying; &#125;&#125; 定时回血（扣血） 游戏中会有一些定时回血Buff（奶妈的缓回Buff等等），定时扣血Buff（毒Buff等等），因为和血量息息相关，并且适合统一做成属性，也可以放到血量模块中 在AttrID中定义属性字段 12345678/** 每秒回血 (固定值) */public static readonly HPAddSecond: number = 31;/** 每秒回血 (百分比) 0-1 */public static readonly HPAddPerSecond: number = 131;/** 每秒掉血（固定值） */public static readonly HPReduceSecond: number = 32;/** 每秒掉血（百分比）0-1 */public static readonly HPReducePerSecond: number = 132; 并在BaseAttr中注册接口 1234public get hpAddSecond() &#123; return this.getValue(AttrID.HPAddSecond); &#125;public get hpAddPerSecond() &#123; return this.getValue(AttrID.HPAddPerSecond); &#125;public get hpReduceSecond() &#123; return this.getValue(AttrID.HPReduceSecond); &#125;public get hpReducePerSecond() &#123; return this.getValue(AttrID.HPReducePerSecond); &#125; 在血量模块的update中每秒刷新 123456789101112131415161718192021222324252627282930313233343536373839404142434445protected override onUpdate(dt: number): void &#123; this._nextRecoverTime -= dt; this._nextReduceTime -= dt; if (this._nextRecoverTime &lt; 0) &#123; this._nextRecoverTime = 1; this._checkRecover(); &#125; if (this._nextReduceTime &lt; 0) &#123; this._nextReduceTime = 1; this._checkReduce(); &#125;&#125;/** 定时回血 */private _checkRecover() &#123; let charAttr = this.character.attrComp.attr; if (charAttr.hpAddSecond &gt; 0 || charAttr.hpAddPerSecond &gt; 0) &#123; if (this.isDying) &#123; return; &#125; if (this.isMaxHP) &#123; return; &#125; // 最多回到满血 let hpAdd = Math.min(this.maxHP * charAttr.hpAddPerSecond + charAttr.hpAddSecond, this.maxHP - this._curHP); this.changeHP(hpAdd); &#125;&#125;/** 定时扣血 */private _checkReduce() &#123; let charAttr = this.character.attrComp.attr; if (charAttr.hpReduceSecond &gt; 0 || charAttr.hpReducePerSecond &gt; 0) &#123; if (this.isDying) &#123; return; &#125; // 最多扣剩余血量和剩余护盾值 let hpReduce = Math.min(this.maxHP * charAttr.hpReducePerSecond + charAttr.hpReduceSecond, this._curShield + this._curHP); // 扣血前 buff模块判断有没有免伤护盾等等 hpReduce = this.character.battleBuffComp.processBeforeBeDamage(hpReduce); if (hpReduce &gt; 0) &#123; this.changeHP(-hpReduce); &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(十) 角色设计-战斗Buff","slug":"放置类卡牌战斗-(十)-角色设计-战斗Buff","date":"2022-01-06T17:46:36.000Z","updated":"2022-02-01T14:11:52.569Z","comments":true,"path":"放置类卡牌战斗-(十)-角色设计-战斗Buff/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97Buff/","excerpt":"","text":"点我回到首页 前言 buff模块也是角色设计中必不可少的模块，游戏中角色一半以上的技能机制都需要依赖buff模块支持，一个稳定健壮的buff系统才能更好的保证游戏逻辑自洽。 Buff基础表格设计 游戏中Buff是需要策划配表做成Buff库，Buff表需要设计合理，才能方便程序和策划使用，如图所示 BuffType表示Buff种类，如 属性类: 基础属性（如：固定+10%攻击），动态属性（如：根据当前攻击50% 转化成防御） 状态类：束缚，晕眩，冰冻，嘲讽等等 位移类：被击退，被击飞，被吸附 变身类：改变普攻，改变模型 BuffClass表示Buff分类，这里用位运算处理： 1：增益Buff 2：减益Buff 4：不可驱散Buff 5：增益不可驱散Buff 6：减益不可驱散Buff OverlayType 叠加类型 1：不刷新时间（第一层3秒 加入第二层8秒） 2：刷新时间（第一层3秒 加入第二层8秒 把第一层也变成了8秒） OverlayMax 叠加层数 -1为无限层，层数溢出时默认清除最早添加的Buff Duration Buff持续时间 AttrArr Buff所添加的属性数组 对照前面属性表ID，如 102=0.2 表示一个攻击+20%的Buff （102 攻击百分比） 102=0.3|103=0.2 表示一个攻击+30%和防御+20%的buff （102 攻击百分比， 103防御百分比）通过属性字段，可以配游戏中大量的Buff，也方便Buff之间的组合，如一个狂暴Buff是同时加攻速攻击等等 Params 表示一些buff类型需要的独特字段 如 动态属性Buff约定 第一个数字 1 施法者 2 受击者 第二个数字 要使用的属性id 第三个数字 要使用的属性比例 第四个数字 增加属性id1|2|0.2|3 表示将施法者（第一个数字 1） 攻击（第二个数字 2）的20%（第三个数字 0.2）变成防御(第四个数字 3) 击退 就可以表示 击退距离或者击退速度 变身 就可以表示 变身的技能ID 模型名称等等 Effect 表示Buff持续期间加在角色身上的特效相关 Buff基类 代码层面基本就是表格的封装处理，设计一个Buff基类，让子类继承生命周期函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586export enum EBuffType &#123; BaseAttr = 1001, /** 基础属性 */ DynamicAttr = 1002, /** 动态属性 */ Dizzy = 2001, /** 晕眩 */ Silence = 2002, /** 沉默 */ Decoy = 2003, /** 嘲讽 */ PushBack = 3001, /** 击退 */ PushFly = 3002, /** 击飞 */ ChangeAttack = 4001, /** 改变普攻 */&#125;export enum EBuffClass &#123; Gain = 1, /** 增益 */ DeBuff = 2, /** 减益 */ NoClear = 4, /** 不可驱散 */&#125;export class BaseBuff &#123; protected character: BattleCharacter; protected buffDef: BuffDefine; private _leftTime: number; private _caster: IBattleActionOwner; private _attrArr: Array&lt;&#123; type: number, value: number; &#125;&gt;; private _loopEffect: string; public b_reset(character: BattleCharacter, buffDef: BuffDefine, caster: IBattleActionOwner) &#123; this.character = character; this._caster = caster; this.buffDef = buffDef; this._attrArr = []; if (buffDef.AttrArr) &#123; let vals = buffDef.AttrArr.split(&quot;|&quot;); for (let val of vals) &#123; let v = val.split(&quot;=&quot;); this._attrArr.push(&#123; type: toNumber(v[0]), value: toNumber(v[1]) &#125;); &#125; &#125; this._playKeepEffect(); this.refreshLeftTime(buffDef.Duration); this.onReset(); &#125; public b_destroy(): void &#123; this._stopKeepEffect(); this.onDestroy(); &#125; public b_update(dt: number) &#123; this._leftTime -= dt; this.onUpdate(dt); &#125; /** 刷新剩余时间 */ public refreshLeftTime(leftTime: number) &#123; this._leftTime = leftTime; &#125; private _playKeepEffect(): void &#123;&#125; private _stopKeepEffect(): void &#123;&#125; /** buff加上之前检查是否结束，比如自身免疫Debuff，则直接无视Debuff */ public checkFinishedBeforeAdd(): boolean &#123; return false; &#125; /** buff更新前检查结束 比如护盾buff次数被消耗殆尽 */ public checkFinishedBeforeUpdate(): boolean &#123; return false; &#125; /** buff更新后检查已经结束 一般非永久buff时间用完 */ public checkFinishedAfterUpdate(): boolean &#123; return (this.buffDef.Duration &gt; 0 &amp;&amp; this._leftTime &lt; 0); &#125; protected onReset(): void &#123; &#125; protected onUpdate(dt: number): void &#123; &#125; protected onDestroy(): void &#123; &#125; /** buff 剩余时间 */ public get leftTime(): number &#123; return this._leftTime; &#125; /** buff 来源 */ public get caster(): IBattleActionOwner &#123; return this._caster; &#125; /** buff 类型 */ public get buffType(): EBuffType &#123; return this.buffDef.BuffType; &#125; /** buff ID */ public get buffID(): number &#123; return this.buffDef.ID; &#125; /** buff 属性数组 */ public get attrArr(): Array&lt;&#123; type: number, value: number; &#125;&gt; &#123; return this._attrArr; &#125; /** buff 分类 */ public get buffClass(): EBuffClass &#123; return this.buffDef.BuffClass; &#125;&#125; 子类继承实现具体细节即可，如一个嘲讽Buff 12345678910/** 嘲讽 */export class DecoyBuff extends BaseBuff &#123; protected override onReset(): void &#123; this.character.battleComp.setDecoyTarget(this.caster as BattleCharacter); &#125; protected override onDestroy(): void &#123; this.character.battleComp.setDecoyTarget(null); &#125;&#125; Buff工厂 同时也需要一个Buff工厂对Buff进行回收管理，毕竟游戏中Buff对象还是比较多的，用一个Pool池管理方便Buff对象重置回收 123456789101112131415161718192021222324252627282930313233343536373839404142export class BuffFactory &#123; private static _buffDic = &#123;&#125;; public static create(character: BattleCharacter, buffDef: ssBuffDefine, caster: IBattleActionOwner): BaseBuff &#123; let buff: BaseBuff = null; let buffType: EBuffType = buffDef.BuffType; if (this._buffDic[buffType] &amp;&amp; this._buffDic[buffType].length &gt; 0) &#123; buff = this._buffDic[buffType].pop(); &#125; else &#123; switch (buffType) &#123; case EBuffType.BaseAttr: buff = new BaseAttrBuff(); break; case EBuffType.DynamicAttr: buff = new DynamicAttrBuff(); break; case EBuffType.Dizzy: buff = new DizzyBuff(); break; case EBuffType.Silence: buff = new SilenceBuff(); break; // 其他buff &#125; &#125; if (buff) &#123; buff.b_reset(character, buffDef, caster); &#125; return buff; &#125; public static garbage(buff: BaseBuff) &#123; let arr = this._buffDic[buff.buffType]; if (!arr) &#123; arr = []; this._buffDic[buff.buffType] = arr; &#125; buff.b_destroy(); arr.push(buff); &#125;&#125; 角色Buff组件角色Buff组件主要是将角色身上的Buff组织起来进行有效管理，注意Buff在战斗中是属性的一个提供者，需要在属性组件中注册，并且在添加和移除Buff时候需要调用syncAttr同步属性组件中的属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104export class CharBattleBuffComponent extends CharBattleBaseComponent &#123; private _buffList: Array&lt;BaseBuff&gt;; protected override onInit(): void &#123; this._buffList = []; this.character.attrComp.registerAttrProvider(this); &#125; protected override onDestroy(): void &#123; this._clear(); &#125; protected override onUpdate(dt: number) &#123; let index = 0; while (index &lt; this._buffList.length) &#123; let buff = this._buffList[index]; if (buff.checkFinishedBeforeUpdate()) &#123; this.removeBuff(buff); &#125; else &#123; buff.b_update(dt); if (buff.checkFinishedAfterUpdate()) &#123; this.removeBuff(buff); &#125; else &#123; ++index; &#125; &#125; &#125; &#125; private _clear() &#123; for (let buff of this._buffList) &#123; BuffFactory.garbage(buff); &#125; this._buffList = []; &#125; /** * 添加buff * @param buffID buff表id * @param caster buff释放来源，可为空 */ public addBuff(buffDef: ssBuffDefine, caster?: IBattleActionOwner) &#123; /** * 先处理同ID buff 叠加层数 * 这里注意叠加层数 是某一个ID Buff的叠加 * 有叠加上限且达到叠加上限且不是永久buff,刷新当前最早添加的buff */ /** * 再处理同ID buff 刷新时间 * 判断需要刷新同ID其他buff时间 */ /* * 有些buff例如 击退 击飞 嘲讽 等 * 不管叠加层数，该类型buff永远只能共存一个 */ this._addBuff(buffDef, caster); &#125; private _addBuff(buffDef: ssBuffDefine, caster: IBattleActionOwner) &#123; let buff = BuffFactory.create(this.character, buffDef, caster); if (buff.checkFinishedBeforeAdd()) &#123; BuffFactory.garbage(buff); &#125; else &#123; this._buffList.push(buff); this.character.attrComp.syncAttr(); &#125; &#125; public getAttr(): BaseAttr &#123; let finalAttr = new BaseAttrBaseAttr(); for (let buff of this._buffList) &#123; if (buff.attrArr) &#123; finalAttr.addAttrArray(buff.attrArr); &#125; &#125; return finalAttr; &#125; public removeBuff(buff: BaseBuff) &#123; &#125; public removeBuffByType(buffType: EBuffType) &#123; &#125; public removeBuffByCaster(buffCaster: IBattleActionOwner) &#123; &#125; public removeBuffByClass(buffClass: EBuffClass) &#123; &#125; public hasBuff(buffType: EBuffType): boolean &#123; &#125; /** 进入被击状态（晕眩冰冻等等） */ public get enterBeHit(): boolean &#123; &#125; /** 可以被移动 */ public get canBeMove(): boolean &#123; &#125; /** 可以被击飞 */ public get canBePushFly(): boolean &#123; &#125; /** 可以被击退 */ public get canBePushBack(): boolean &#123; &#125; /** 束缚击退击飞情况下不可以移动 特指自己主观想动 */ public get canMove(): boolean &#123; &#125; /** 可以被敌人选中 */ public get canSelect(): boolean &#123; &#125; /** 可以使用技能（沉默和晕眩放不出技能） */ public get canUseSkill(): boolean &#123; &#125; /** 在变身阶段 */ public get inModeChange(): boolean &#123; &#125;&#125; 其他拓展 游戏中经常有物理伤害，魔法伤害，真实伤害等等，也会对应的有免疫伤害护盾，只免疫物理伤害护盾，只免疫魔法伤害护盾等等，做这些设计的时候，例如可以在BaseBuff中加入 12/** 真正受到伤害前的处理 比如免伤护盾 减伤护盾 */public processBeforeBeDamage(damageValue: number): number &#123; return damageValue; &#125; 然后在 CharBattleBuffComponent中加入 1234567public processBeforeBeDamage(damageValue: number) &#123; if (!this._buffList) return; for (let buff of this._buffList) &#123; damageValue = buff.processBeforeBeDamage(damageValue); &#125; return damageValue;&#125; 比如免伤护盾中就可以这样实现 1234567891011121314151617181920212223/** 免伤护盾 有次数 */export class NoDamageShieldBuff extends BaseBuff &#123; /** 免疫次数 */ private _noDamageCount: number; protected override onReset(): void &#123; this._noDamageCount = RatelUtil.toNumber(this.buffDef.Params); &#125; /** 次数归零就可以清除了 */ public override checkFinishedBeforeUpdate(): boolean &#123; return this._noDamageCount &lt;= 0; &#125; /** 免伤护盾消耗一次次数将伤害归零 */ public override processBeforeBeDamage(damageValue: number) &#123; if (damageValue &lt;= 0 || this._noDamageCount &lt;= 0) &#123; return damageValue; &#125; --this._noDamageCount; return 0; &#125;&#125; 当有物理魔法伤害之分时，可以将damageValue改为一个结构，都是可以根据需求慢慢拓展的。 优化 角色的Buff模块在开发中会有各种拓展，对逻辑要求比较高，需要理清逻辑再开发，如各个buff优先级，buff间的抵消等等，在buff中会给玩家加各种状态，如被束缚不能移动，被沉默晕眩不能释放技能，在比较小型的项目Buff数量不是特别多，可以通过在bufflist中判断有无对应buff，当逻辑比较复杂以后，可以考虑用位运算，给角色加上标记信息，可以更方便管理。 123456789export enum BuffFlag &#123; None = 0, /**禁止移动 */ OccMove = 1, /**禁止放技能 */ OccCast = 2, /**禁止转向 */ OccTurn = 4,&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(九) 角色设计-战斗技能","slug":"放置类卡牌战斗-(九)-角色设计-战斗技能","date":"2022-01-06T17:36:44.000Z","updated":"2022-02-01T14:11:33.619Z","comments":true,"path":"放置类卡牌战斗-(九)-角色设计-战斗技能/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B9%9D)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/","excerpt":"","text":"点我回到首页 前言 技能模块也是角色比较核心的模块，不同游戏技能释放机制不一样，有的游戏是根据技能cd释放，有的游戏是有多个技能按照一定顺序组合依次释放，不过都大同小异，技能模块主要也是管理技能的释放，具体技能的实现机制会在后面章节中具体阐述。 项目需求 目前项目中的每个友方角色会有一个普攻和一个技能，普攻释放完就会刷新普攻cd，技能完整释放完才会刷新cd，每个怪物角色会有一个普攻和若干技能，哪个技能cd好了就释放该技能。 技能基础 普攻也是技能的一种，只是释放时机不一样，可以理解为一个特殊的技能，所以可以设计出一个共有的CharBattleSkillInfo用来管理每个技能的信息，包括技能cd，技能等级等等。 这里只是根据项目本身做了一些设计，技能组件的拓展形式有很多种，具体设计还需要结合项目实际情况分析，能够做到管理好技能的释放，使角色进入技能状态即可。 12345678910111213141516171819202122232425262728293031export class CharBattleSkillInfo &#123; /** 技能等级 */ private _skillLv: number; /** 技能表数据 */ private _skillDef: SkillDefine; /** cd */ private _coolDown: number; /** 总cd */ private _totalCoolDown: number; constructor(skillID: number, skillLv: number = 0) &#123; // 根据id读取技能配置 &#125; public update(dt: number) &#123; if (this._coolDown &gt; 0) &#123; this._coolDown = this._coolDown &gt; dt ? this._coolDown - dt : 0; &#125; &#125; public resetCoolDown(): void &#123; this._coolDown = this._skillDef.CoolDown; this._totalCoolDown = this._skillDef.CoolDown; &#125; public get coolDown(): number &#123; return this._coolDown; &#125; public get inCoolDown(): boolean &#123; return this._coolDown &gt; 0; &#125; public get coolDownPer(): number &#123; return this._totalCoolDown &gt; 0 ? this._coolDown / this._totalCoolDown : 0; &#125; public get skillDef(): SkillDefine &#123; return this._skillDef; &#125; public get skillLv(): number &#123; return this._skillLv; &#125;&#125; 基础技能组件 由于有单技能和多技能的设定，相同点是都有普攻，所以可以先设计有普攻的基础技能组件 12345678910111213141516171819202122232425262728293031323334353637383940export abstract class CharBattleSkillComponent extends CharacterComponent &#123; /** 默认普攻 */ private _defaultAttackInfo: CharBattleSkillInfo; /** 临时替换的普攻 */ private _tempAttackInfo: CharBattleSkillInfo; protected override onInit(attackID: number): void &#123; // 初始化默认普攻 this._defaultAttackInfo = new CharBattleSkillInfo(attackID); this.resetAttackInfo(); &#125; protected override onUpdate(dt: number): void &#123; // 判断自动战斗 释放技能 （省略细节） this.attackInfo.update(dt); this.onSkillUpdate(dt); &#125; public setTempAttackInfo(attackInfo: CharBattleSkillInfo): void &#123; this._tempAttackInfo = attackInfo; &#125; public resetAttackInfo(): void &#123; this.attackInfo &amp;&amp; this.attackInfo.resetCoolDown(); &#125; /** 释放技能 */ public enterSkill(): void &#123; &#125; /** 退出技能 */ public exitSkill(): void &#123; &#125; /** 判断技能能否释放 */ public judgeCanCastSkill(isAuto: boolean = false): boolean &#123; &#125; protected onSkillUpdate(dt: number) &#123; &#125;; /** 当前的技能信息 由子类实现 */ public abstract get curSkillInfo(): CharBattleSkillInfo; /** 有临时普攻用临时普攻 */ public get attackInfo(): CharBattleSkillInfo &#123; return this._tempAttackInfo ? this._tempAttackInfo : this._defaultAttackInfo; &#125;&#125; 这里由于有战斗中变身技能替换普攻，所以设置了临时普攻，读取时判断是否有临时普攻即可 组件拓展单技能组件 单技能组件直接根据传入的技能的信息初始化即可 123456789101112131415export class CharBattleSingleSkillComponent extends CharBattleSkillComponent &#123; private _curSkillInfo: CharBattleSkillInfo; protected override onInit(attackDef: SkillDefine, skillID?: number): void &#123; super.onInit(attackDef); // 初始化技能 （省略细节） &#125; protected override onSkillUpdate(dt: number): void &#123; this._curSkillInfo &amp;&amp; this._curSkillInfo.update(dt); &#125; // 返回唯一拥有的技能 public get curSkillInfo(): CharBattleSkillInfo &#123; return this._curSkillInfo; &#125;&#125; 多技能组件 多技能组件传入的是技能数组，需要实时数显寻找cd最少的作为当前技能 12345678910111213141516export class CharBattleMultiSkillComponent extends CharBattleSkillComponent &#123; private _allSkillInfos: Array&lt;CharBattleSkillInfo&gt;; private _minCDSkillInfo: CharBattleSkillInfo; protected override onInit(attackID: number, skillIDs?: Array&lt;number&gt;): void &#123; super.onInit(attackID); // 初始化所有技能（省略细节） &#125; protected override onSkillUpdate(dt: number): void &#123; // 更新所有技能cd并选出技能cd最短的技能 （省略细节） &#125; // 返回技能cd最短的技能 public get curSkillInfo(): CharBattleSkillInfo &#123; return this._minCDSkillInfo; &#125;&#125; 其他信息除此之外，还有一些其他技能相关的都可以放入技能组件中，比如技能当中一些位移信息，传送信息等等 123456789101112131415161718192021222324252627282930export type CharSkillMoveInfo = &#123; /** 速度 */ speed?: number; /** 方向 */ direction?: Vector3; /** 加速度 */ moveAcc?: number; /** 移动时间 */ moveTime?: number; /** 移向目标 */ isMoveToTarget?: boolean;&#125;;public setSkillMoveInfo(moveInfo: CharSkillMoveInfo): void &#123; moveInfo &amp;&amp; (notNull(moveInfo.speed) || (moveInfo.speed = this.character.battleMoveComp.speed)); moveInfo &amp;&amp; (notNull(moveInfo.moveAcc) || (moveInfo.moveAcc = 0)); moveInfo &amp;&amp; (notNull(moveInfo.direction) || (moveInfo.direction = this.character.battleMoveComp.direction)); moveInfo &amp;&amp; (notNull(moveInfo.moveTime) || (moveInfo.moveTime = 0)); moveInfo &amp;&amp; (notNull(moveInfo.isMoveToTarget) || (moveInfo.isMoveToTarget = false)); this._skillMoveInfo = moveInfo;&#125;export type CharSkillTeleportInfo = &#123; /** 上次传送位置 */ lastPos?: Vector3;&#125;;public setSkillTeleportInfo(teleportInfo: CharSkillTeleportInfo): void &#123; this._skillTeleportInfo = teleportInfo;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(八) 角色设计-战斗基础","slug":"放置类卡牌战斗-(八)-角色设计-战斗基础","date":"2022-01-06T17:30:30.000Z","updated":"2022-01-26T18:19:32.204Z","comments":true,"path":"放置类卡牌战斗-(八)-角色设计-战斗基础/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AB)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%9F%BA%E7%A1%80/","excerpt":"","text":"点我回到首页 前言 在以往的设计中，战斗中会有大量的判断角色所处阵营然后根据所处阵营获取是用playerlist还是enemylist，使得代码整体非常的混乱，需要一种合理的设计避免这种大量的判断。 组件无状态化 在战斗组件的设计上采取一种无状态的方式，即不管组件使用者是谁，所有逻辑都是既使用友方阵营，也适用敌方阵营。能够做到这种方式的方法即在初始化时候定义好firendList和targetList，这样通过在角色绑定组件的时候，也顺带绑定好友方和敌方列表，就可以不用再在其他地方判断角色所处阵营。 123456789101112131415161718192021222324252627282930313233343536export class CharBattleComponent extends CharacterComponent &#123; private _target: BattleCharacter; private _firendList: Array&lt;BattleCharacter&gt;; private _targetList: Array&lt;BattleCharacter&gt;; private _decoyTarget: BattleCharacter; protected override onInit(firendList: Array&lt;BattleCharacter&gt;, targetList: Array&lt;BattleCharacter&gt;) &#123; this._targetList = targetList; this._firendList = firendList; &#125; protected override onUpdate(dt: number): void &#123; this._target = this.getNearestOtherSide(); &#125; /** 判断能否选中目标 */ public judgeCanSelectTarget(target: BattleCharacter): boolean &#123;&#125; /** 受到一次攻击 */ public processBeDamage():void &#123;&#125; /** 受到一次治疗 */ public processBeHeal():void &#123;&#125; /** 设置嘲讽目标 */ public setDecoyTarget(decoyTarget: BattleCharacter) &#123;&#125; /** 根据条件筛选出一群单位 */ public filterTargetsByNums(toFilters: Array&lt;BattleCharacter&gt;, nums: number, battleTargetCfg: IBattleTargetCfg)&#123;&#125; /** 根据条件筛选出一个单位 */ public filterTargetByNum(toFilters: Array&lt;BattleCharacter&gt;, orderNum: number, battleTargetCfg: IBattleTargetCfg)&#123;&#125; /** 获得最近的敌方 */ public getNearestOtherSide(): BattleCharacter &#123;&#125;&#125; 总结 战斗基础组件中主要包含了战斗中的计算，锁敌相关，包含了所有和目标相关的信息，组件无状态化，会省去很多无用代码，也会方便拓展所有锁敌相关的设计，如嘲讽技能，魅惑技能等等。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(七) 角色设计-AI","slug":"放置类卡牌战斗-(七)-角色设计-AI","date":"2022-01-06T15:25:25.000Z","updated":"2022-01-30T12:12:13.731Z","comments":true,"path":"放置类卡牌战斗-(七)-角色设计-AI/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%83)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-AI/","excerpt":"","text":"点我回到首页 前言 AI模块也是战斗模块中的一个核心模块，是游戏中角色行为的驱动力，考虑项目中其他场景角色也有AI相关的需求，为了提高代码的复用性，需要设计一个通用的AI架构，满足各个场景角色AI的驱动。 AI配置 游戏中有各种各样的角色，每个角色会有各种各样的状态，每个角色在不同状态下做出的行为也会不一样，例如A角色IDLE状态是循环的，每次循环50ms，第0秒播放IDLE动画，第20ms播放一个特效，特效名为”XXX”，B角色IDLE状态是循环的，每次循环60ms，第0秒播放IDLE_HAPPY动画，第30ms播放一个声音，音乐名为”YYY”，这样的表现一般会需要类似如下的配置： 1234567891011121314151617181920212223242526272829303132A : &#123; &quot;AIState&quot;: &quot;Idle&quot;, &quot;IsLoop&quot;: true, &quot;TotalTime&quot;: 50, &quot;EventList&quot;: [&#123; &quot;TriggerTime&quot;: 0, &quot;EventType&quot;: &quot;PlayAnim&quot;, &quot;EventData&quot;: &#123; &quot;AnimName&quot;: &quot;IDLE&quot;, &#125;&#125;,&#123; &quot;TriggerTime&quot;: 20, &quot;EventType&quot;: &quot;PlayEffect&quot;, &quot;EventData&quot;: &#123; &quot;EffectName&quot;: &quot;XXX&quot;, &#125;&#125;] &#125;,B : &#123; &quot;AIState&quot;: &quot;Idle&quot;, &quot;IsLoop&quot;: true, &quot;TotalTime&quot;: 60, &quot;EventList&quot;: [&#123; &quot;TriggerTime&quot;: 0, &quot;EventType&quot;: &quot;PlayAnim&quot;, &quot;EventData&quot;: &#123; &quot;AnimName&quot;: &quot;IDLE_HAPPY&quot;, &#125;&#125;,&#123; &quot;TriggerTime&quot;: 30, &quot;EventType&quot;: &quot;PlaySound&quot;, &quot;EventData&quot;: &#123; &quot;SoundName&quot;: &quot;YYY&quot;, &#125;&#125;] &#125; 通过配置不同角色各种状态下所做的行为，在进入某个状态后，读取该状态下的配置信息，按时间顺序依次做出配置的行为。 角色状态基础 不同状态下，角色不仅要执行配置中所设置的行为（播放动作，播放特效，播放声音，释放技能等等），还需要执行游戏逻辑中实时需要进行的行为，如战斗中RUN状态下，需要不停向目标移动，直至目标到达攻击范围为止。这种情况下，可以用状态模式将不同状态解耦。 通过定义公共父类BaseAIState，衍生出BattleIdleState，BattleRunState，BattleAttackState等等，子类只需要复写生命周期函数即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576export class BaseAIState &#123; /** 配置的信息 */ protected aiStateConfig: CharAIStateCfg; /** 标记一个State已经执行的时间 */ protected curAIStateTime: number = 0; /** 标记当前Event的索引-&gt;跟随State的生命周期++ */ protected curEventIndex: number = 0; /** 标记一个State执行完毕，进行对应的State完结处理 */ protected curAIStateFinished: boolean = false; public init(args?: any[]): void &#123; this.onInit.apply(this, args); &#125; public reset(): void &#123; this.curAIStateTime = 0; this.curEventIndex = 0; this.curAIStateFinished = false; this.onReset(); &#125; /** 传进来的是毫秒 */ public update(dt: number): void &#123; let nextStateTime: number = 0; let delta: number = dt; if (this.curAIStateTime + dt &gt;= this.aiStateConfig.TotalTime) &#123; dt = this.aiStateConfig.TotalTime - this.curAIStateTime; nextStateTime = delta - dt; this.curAIStateFinished = true; &#125; this.curAIStateTime += dt; this.onUpdate(dt * 0.001); this._processEventList(); if (this.curAIStateFinished) &#123; this._processStateFinish(nextStateTime); &#125; &#125; public destroy(): void &#123; this.onDestroy(); &#125; /** 只有创建的时候才执行 */ protected onInit(...args: any[]) &#123; &#125; /** 每次重置都会执行 */ protected onReset() &#123; &#125; /** 更新时候执行 */ protected onUpdate(dt: number): void &#123; &#125;; /** 销毁时候执行 */ protected onDestroy() &#123; &#125; private _processEventList(): void &#123; /** 只触发一次事件 */ for (; this.curEventIndex &lt; this.aiStateConfig.EventList.length; ++this.curEventIndex) &#123; let evtCfg = this.aiStateConfig.EventList[this.curEventIndex]; if (evtCfg.TriggerTime &lt; this.curAIStateTime) &#123; // 执行事件 &#125; else &#123; break; &#125; &#125; &#125; /** State结束时执行 */ private _processStateFinish(nextStateTime: number): void &#123; // 如果当前State是loop的，就继续执行当前的State if (this.aiStateConfig.IsLoop) &#123; this.character.aiComp.setAIState(this.aiStateConfig.AIState, nextStateTime); &#125; // 如果当前State不是loop的，但是有相应的FollowState，就执行相应该FollowState else if (this.aiStateConfig.FollowState !== EAIState.Invalid) &#123; this.character.aiComp.setAIState(this.aiStateConfig.FollowState, nextStateTime); &#125; &#125;&#125; 角色AI组件 在此基础上，角色AI组件需要管理AI状态的生命周期，提供AI状态创建，AI状态切换等功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 一个AIState单元 对应idle run... */export interface CharAIStateCfg &#123; /** ID */ readonly ID: string; /** 状态 */ readonly AIState: EAIState; /** 是否循环 */ readonly IsLoop: boolean; /** 总时间(ms) */ readonly TotalTime: number; /** 非loop动作播完，必定跟随有的state */ readonly FollowState: EAIState; /** ActionEvent列表 */ readonly EventList: Array&lt;CharActionEventCfg&gt;; /** Action列表 */ readonly ActionList: Array&lt;CharActionCfg&gt;;&#125;export class CharAIComponent extends CharacterComponent &#123; /** 当前角色对应的State组 */ private _aiCfgGroup: Record&lt;string, CharAIStateCfg&gt;; /** 当前角色的AIState */ private _curAIState: BaseAIState; /** 角色上一次AIState */ private _lastAIState: BaseAIState; /** 已执行的总时间 */ private _totalTime: number = 0; protected override onUpdate(dt: number): void &#123; if (!this._curAIState) return; let t1: number = Math.floor(this._totalTime * 1000); this._totalTime += dt; let t2: number = Math.floor(this._totalTime * 1000); this._curAIState.update(t2 - t1); &#125; /** * 切换为目标State */ public setAIState(aiState: string, nextStateTime: number = 0, ...args: any[]): void &#123; let aiStateCfg: CharAIStateCfg = this._aiCfgGroup[aiState]; if (this._curAIState) &#123; this._lastAIState = this._curAIState; &#125; if (!this._lastAIState || this._lastAIState.aiStateConfig.AIState !== aiStateCfg.AIState) &#123; this._curAIState &amp;&amp; this._curAIState.destroy(); switch (aiStateCfg.AIState) &#123; case EAIState.BattleIdle: this._curAIState = new BattleIdleState(this.character, aiStateCfg); break; case EAIState.BattleRun: this._curAIState = new BattleRunState(this.character, aiStateCfg); break; case EAIState.BattleAttack: this._curAIState = new BattleAttackState(this.character, aiStateCfg); break; // 其他状态 &#125; this._curAIState &amp;&amp; this._curAIState.init(args); &#125; this._curAIState &amp;&amp; this._curAIState.reset(); if (nextStateTime &gt; 0) this._curAIState.update(nextStateTime); &#125;&#125; 状态间切换 在现有机制下，状态间切换只需要在每个子类onUpdate中，通过判断切换即可，可能会产生如下的代码 12345678910111213141516171819export class AState extends BaseAIState &#123; protected override onUpdate(dt): void &#123; /** 满足切换b状态条件 */ if (canChangeBState) &#123; this.character.aiComp.setAIState(EAIState.BState, dt); return; &#125; // 其他满足状态 /** 满足切换c状态条件 */ if (canChangeCState) &#123; this.character.aiComp.setAIState(EAIState.CState, dt); return; &#125; // 执行A状态下应该干的事 &#125;&#125; 对于战斗中这种各状态切换之间条件比较明显的，可以在项目中用统一的状态切换限制， 例如 BattleIdle - BattleRun - BattleAttack - BattleSkill - BattleFailed - BattleVictory 这一套状态间切换通用普通角色和普通副本怪，即使战斗中有Boss的需求 也可以 额外产生 例如 BossAppearance - BossIdle - BossAttack - BossSkill - BossFailed - BossVictory这样一套状态通用所有Boss，这样的成本在项目中并不算高。 引入行为树 上面的设计可以满足放置类游戏中战斗中角色AI需求，对于稍微复杂一点的角色AI需求，便很难满足了，或者说需要很多套状态来支持，有时候需要为一个角色专门定制一套状态，显然不是很合理，例如在其他场景中，有如下需求：A角色比较懒，在白天喜欢躲起来睡觉。B角色比较活泼，在人多的敌方喜欢跳舞。这种类似的SleepState， DanceState，只针对某些特定的角色生效，显然不适合在所有角色的状态判断切换时出现，这个时候我们希望能够为每个角色定制一份状态切换的配置，让角色在判断状态切换时读取这份配置进行各状态之间的切换，这样的话，我们需要修改BaseAIState，引入类似行为树的设计理念。 123456789101112131415161718192021222324252627/** 传进来的是毫秒 */public update(dt: number): void &#123; let nextStateTime: number = 0; let delta: number = dt; if (this.curAIStateTime + dt &gt;= this.aiStateConfig.TotalTime) &#123; dt = this.aiStateConfig.TotalTime - this.curAIStateTime; nextStateTime = delta - dt; this.curAIStateFinished = true; &#125; this.curAIStateTime += dt; let aiState = this.getChangeState(); if (aiState &amp;&amp; aiState !== EAIState.Invalid) &#123; this.changeAIState(aiState, delta, true, ...args); &#125; else &#123; this.onUpdate(dt * 0.001); this._processEventList(); if (this.curAIStateFinished) &#123; this._processStateFinish(nextStateTime); &#125; &#125;&#125;protected changeAIState(aiState: EAIState, nextStateTime: number = 0): void &#123; this.character.aiComp.setAIState(aiState, nextStateTime);&#125;protected getChangeState(): EAIState &#123; return EAIState.Invalid; &#125; 只需要对update加一点处理，引入getChangeState，这样一个可能的AState代码如下： 123456789101112131415161718192021export class AState extends BaseAIState &#123; protected override getChangeState(): EAIState &#123; /** 满足切换b状态条件 */ if (canChangeBState) &#123; return EAIState.BState; &#125; // 其他满足状态 /** 满足切换c状态条件 */ if (canChangeCState) &#123; return EAIState.CState; &#125; return EAIState.Invalid; &#125; protected override onUpdate(dt): void &#123; // 执行A状态下应该干的事 &#125;;&#125; 如图所示，getChangeState函数如同一颗根节点是AState的行为树，每个if条件都如同行为树上的分叉，对于没有显式的写明结果的叶子节点都用Invalid填补代表AState，这样对于复杂AI需求的时候，可以将判断条件写入配置，可能会有如下代码： 123456789101112export class AState extends BaseAIState &#123; protected override getChangeState(): EAIState &#123; /** 判断A状态下的所有配置条件是否满足 */ for (let i = 0; i &lt; StateChangeList.length; ++i) &#123; if (StateChangeList[i].Condition) &#123; return StateChangeList[i].ChangeState; &#125; &#125; return EAIState.Invalid; &#125;&#125; 这样可以分别给两个角色A状态配置如下的配置： 123456789101112131415A : &#123; &quot;AIState&quot;: &quot;AState&quot;, &quot;IsLoop&quot;: true, &quot;TotalTime&quot;: 60, &quot;StateChangeList&quot;: [ &#123; &quot;Condition&quot;: &quot;CheckBState&quot;, &quot;ChangeState&quot;: &quot;BState&quot; &#125;, &#123; &quot;Condition&quot;: &quot;CheckCState&quot;, &quot;ChangeState&quot;: &quot;CState&quot; &#125; ]&#125;, 123456789101112131415A : &#123; &quot;AIState&quot;: &quot;AState&quot;, &quot;IsLoop&quot;: true, &quot;TotalTime&quot;: 60, &quot;StateChangeList&quot;: [ &#123; &quot;Condition&quot;: &quot;CheckDState&quot;, &quot;ChangeState&quot;: &quot;DState&quot; &#125;, &#123; &quot;Condition&quot;: &quot;CheckEState&quot;, &quot;ChangeState&quot;: &quot;EState&quot; &#125; ]&#125; 这样只需要在代码中分别实现对应的Check函数，即可以达到给不同角色AState设置不同的行为树，这样之前说的A角色喜欢睡觉配置中配上CheckSleep，B角色喜欢跳舞配置中配上CheckDance即可 状态和配置关系 在目前项目中还有一个设计，比如角色1-30级用A技能，30-60级用B技能，60-90级用C技能，策划会在技能配置中配有3个技能的配置，这里的话需要明确配置和状态之间的关系，一个状态可以对应多份配置，一份配置会绑定一个状态，上述例子中，不管A，B，C哪个技能都是BattleSkillState，只需要在进入BattleSkillState时，判断角色等级去读取对应的配置即可，可能有的代码如下： 1234567891011protected override changeAIState(aiState: EAIState, nextStateTime: number = 0): void &#123; let aiStateKey: string = aiState; if (aiState === EAIState.BattleAttack) &#123; // 根据等级读取普攻配置 aiStateKey = attackDef.AICfg; &#125; else if (aiState === EAIState.BattleSkill) &#123; // 根据等级读取技能配置 aiStateKey = skillDef.AICfg; &#125; this.character.aiComp.setAIState(aiStateKey, nextStateTime);&#125; 其他 角色AI模块的很多拓展都需要根据项目实际需求出发，例如战斗中可以抽象一层BaseBattleAIState继承BaseAIState用于处理所有战斗状态中的通用逻辑，随着项目迭代，框架也会不断迭代。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(六) 角色设计-模型","slug":"放置类卡牌战斗-(六)-角色设计-模型","date":"2022-01-06T09:43:03.000Z","updated":"2022-01-26T18:19:05.962Z","comments":true,"path":"放置类卡牌战斗-(六)-角色设计-模型/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AD)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"点我回到首页 前言 角色设计中的模型模块属于表现部分，游戏中会有设置模型位置，朝向，大小，模型播放动作等需求，并且在表现上也会伴随各种位置，整体位置，受击位置，特效位置，释放技能位置，飘字位置等等，在模型组件中将这些信息统一管理使得其他模块可以直接调用。 基础模型组件 基础模型组件中管理了角色模型的各种信息，包括碰撞体(CapsuleCollider),层级(LayerMask),DOTween等都可以在这里封装接口供外部使用 12345678910111213141516171819202122232425262728293031323334353637383940414243export class CharAnimComponent extends CharacterComponent &#123; /** 设置角色的位置 */ public setPosition(pos: Vector3): void &#123; // 省略细节 &#125; /** 设置角色方向 1 */ public setDirection1(yaw: number, degree: boolean): void &#123; // 省略细节 &#125; /** 设置角色方向 2 */ public setDirection2(dir: Vector3): void &#123; // 省略细节 &#125; /** 设置角色方向 3 */ public setDirection3(qat: Quaternion): void &#123; // 省略细节 &#125; /** 播放动画 */ public playAnimation(animName: string, animSpeed: number, fadeTime: number): void &#123; // 省略细节 &#125; /** 角色的位置信息 */ public get position(): Vector3 &#123; &#125; /** 角色的朝向信息 */ public get rotation(): Vector3 &#123; &#125; /** 角色的Trans根节点信息 */ public get rootTran(): Transform &#123; &#125; /** 角色root gameobject */ public get rootGO(): GameObject &#123; &#125; /** 角色的正方向 */ public get forward(): Vector3 &#123; &#125; /** 角色的角度信息 */ public get yaw(): number &#123; &#125; /** 角色碰撞体的范围半径 */ public get radius(): number &#123; &#125; /** 角色的身高 */ public get height(): number &#123; &#125;&#125; 战斗模型组件 基础模型组件是方便其他类型角色共有，战斗中有些特殊的位置信息，还需要额外封装一层CharBattleAnimComponent，方便战斗时候使用 123456789101112131415161718192021222324252627export class CharBattleAnimComponent extends CharAnimComponent &#123; /** 受击位置 */ public get hitPosition(): Vector3 &#123; //省略细节 &#125; /** 技能释放位置 */ public get actionPosition(): Vector3 &#123; // 省略细节 &#125; /** 血条位置 */ public get hpPosition(): Vector3 &#123; // 省略细节 &#125; /** 飘字位置 */ public get numPosition(): Vector3 &#123; // 省略细节 &#125; /** 特效位置 */ public get EffectPosition(): Vector3 &#123; // 省略细节 &#125; // 其他","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(五) 角色设计-属性","slug":"放置类卡牌战斗-(五)-角色设计-属性","date":"2022-01-06T09:00:14.000Z","updated":"2022-01-26T18:18:23.535Z","comments":true,"path":"放置类卡牌战斗-(五)-角色设计-属性/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%94)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E5%B1%9E%E6%80%A7/","excerpt":"","text":"点我回到首页 前言 属性模块基本算是战斗的基础模块了，战斗中角色很多机制都依赖于属性，战斗中的属性一般分为战前属性，战斗中临时属性，有效的管理好这些属性之间的关系，在战斗中显得尤为重要。 属性类型 设计上需要先将属性编号，如： 12345678910111213141516export class AttrID &#123; /** 最大血量 */ public static readonly MaxHP: number = 1; /** 血量百分比 0-1 */ public static readonly HPPer: number = 101; /** 攻击 */ public static readonly Attack: number = 2; /** 攻击百分比 0-1 */ public static readonly AttackPer: number = 102; /** 防御 */ public static readonly Defence: number = 3; /** 防御（百分比）0-1 */ public static readonly DefencePer: number = 103; /** 暴击率（百分比）0-1 */ public static readonly CritRate: number = 4;&#125; 属性基础组织 然后需要设计一个通用的属性基类，将属性组织起来，提供各种属性接口，在拓展新属性的时候只需要加上不同的ID并且提供对应的计算接口即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105export class BaseAttr &#123; private _dict: any; constructor() &#123; this._dict = &#123;&#125;; &#125; public clone() &#123; let attr = new BaseAttr(); attr._dict = &#123;&#125;; for (let key in this._dict) &#123; attr._dict[key] = this._dict[key]; &#125; return attr; &#125; public addAttr(other: BaseAttr) &#123; if (!other) &#123; return; &#125; for (let key in other._dict) &#123; this.addValue(key, other._dict[key]); &#125; &#125; public removeAttr(other: BaseAttr) &#123; if (!other) &#123; return; &#125; for (let key in other._dict) &#123; this.removeValue(key, other._dict[key]); &#125; &#125; public addAttrArray(attrArray: Array&lt;&#123; type: number, value: number; &#125;&gt;) &#123; if (!attrArray) &#123; return; &#125; for (let attr of attrArray) &#123; this.addValue(attr.type, attr.value); &#125; &#125; public removeAttrArray(attrArray: Array&lt;&#123; type: number, value: number; &#125;&gt;) &#123; if (!attrArray) &#123; return; &#125; for (let attr of attrArray) &#123; this.removeValue(attr.type, attr.value); &#125; &#125; public addValue(attrKey: number | string, value: number) &#123; if (notNull(this._dict[attrKey])) &#123; this._dict[attrKey] += value; &#125; else &#123; this._dict[attrKey] = value; &#125; &#125; public removeValue(attrKey: number | string, value: number) &#123; if (isNull(this._dict[attrKey])) &#123; return; &#125; this._dict[attrKey] = Math.max(0, this._dict[attrKey] - value); &#125; public getValue(key: number, defaultValue: number = 0) &#123; return isNull(this._dict[key]) ? defaultValue : this._dict[key]; &#125; public getPositiveValue(key: number, defaultValue: number = 0) &#123; return Math.max(0, this.getValue(key, defaultValue)); &#125; public getRatioValue(key: number) &#123; let value = this.getValue(key); if (!value) &#123; return 1; &#125; return Math.max(0, 1 + value); &#125; public getNegativeRatioValue(key: number) &#123; let value = this.getValue(key); if (!value) &#123; return 1; &#125; return Math.max(0, 1 - value); &#125; public setValue(key: number, value: number) &#123; this._dict[key] = value; &#125; public clear() &#123; this._dict = &#123;&#125;; &#125; public get hp() &#123; return Math.round(this.getPositiveValue(AttrID.MaxHP) * this.getRatioValue(AttrID.HPPer)); &#125; public get attack() &#123; return Math.round(this.getPositiveValue(AttrID.Attack) * this.getRatioValue(AttrID.AttackPer)); &#125; public get defence() &#123; return Math.round(this.getPositiveValue(AttrID.Defence) * this.getRatioValue(AttrID.DefencePer)); &#125; public get critRate() &#123; return this.getValue(AttrID.CritRate); &#125;&#125; 角色属性组件设计 123export interface IAttrProvider &#123; getAttr(): BaseAttr;&#125; 由于战斗中会存在各种来源的属性，如buff的属性，各种战斗模式给所有角色加的全局属性等等，设计一个IAttrProvider接口用于属性组件中注册属性来源。 123456789101112131415161718192021222324252627282930313233343536export class CharAttrComponent extends CharacterComponent &#123; public static Events = &#123; /** 属性改变 */ AttrChange: &#x27;AttrChange&#x27;, &#125;; /** 角色总属性 */ private _attr: BaseAttr; /** 角色基础属性 */ private _baseAttr: BaseAttr; /** 属性提供者 */ private _attrProviders: Array&lt;IAttrProvider&gt;; protected override onInit(baseAttr: BaseAttr): void &#123; this._attrProviders = []; this._attr = new BaseAttr(); this._baseAttr = baseAttr; this.syncAttr(); &#125; public registerAttrProvider(provider: IAttrProvider) &#123; this._attrProviders.push(provider); &#125; public syncAttr(): void &#123; this._attr.clear(); this._attr.addAttr(this._baseAttr); for (let provider of this._attrProviders) &#123; this._attr.addAttr(provider.getAttr()); &#125; this.event(CharAttrComponent.Events.AttrChange); &#125; public get attr(): BaseAttr &#123; return this._attr; &#125; public get baseAttr(): BaseAttr &#123; return this._baseAttr; &#125;&#125;初始化时将角色的入场属性作为基础属性，注册其他来源属性，计算总属性的时候将所有来源属性统计好，并播报属性改变的事件。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(四) 角色设计-整体","slug":"放置类卡牌战斗-(四)-角色设计-整体","date":"2022-01-06T08:08:53.000Z","updated":"2022-01-26T18:18:26.270Z","comments":true,"path":"放置类卡牌战斗-(四)-角色设计-整体/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%9B%9B)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%95%B4%E4%BD%93/","excerpt":"","text":"点我回到首页 前言 这种放置类卡牌战斗中的角色模块，基本可以算是战斗中核心了，战斗中角色会有各种模块，包括角色模型（fbx，spine等）控制，角色属性，角色AI，角色技能，角色Buff等等，如果不进行有效管理，最后角色类会非常膨胀。 组件机制 根据项目的背景，由于角色在其他场景也有交互AI行为等等，为了达到代码的内聚和复用，采用了组件(Component)的思想对角色各个模块进行封装，后面章节中将逐个对各个模块进行详解，如下设计通用的组件基类CharacterComponent 123456789101112131415161718192021222324252627282930export class CharacterComponent&lt;TCharacter extends BaseCharacter = BaseCharacter&gt; extends EventDispatcher &#123; private _character: BaseCharacter; protected get character(): TCharacter &#123; return this._character as TCharacter; &#125; constructor(character: BaseCharacter) &#123; super(); this._character = character; &#125; public init(args?: any[]): void &#123; this.onInit.apply(this, args); &#125; public afterInit(): void &#123; this.onAfterInit.apply(this); &#125; public update(dt: number): void &#123; this.onUpdate(dt); &#125; public destroy(): void &#123; this.onDestroy(); &#125; protected onInit(...args: any[]): void &#123; &#125;; protected onAfterInit(): void &#123; &#125;; protected onUpdate(dt: number): void &#123; &#125;; protected onDestroy(): void &#123; &#125;;&#125; 角色绑定组件 在角色基类中管理所有添加的组件 123456789101112131415161718192021222324252627282930/** 所有组件 */private _components: Array&lt;CharacterComponent&gt;;/** 组件初始化参数 */private _compInitArgs: Array&lt;any&gt;;public getComponent&lt;T extends CharacterComponent&gt;(type: new (arg0: BaseCharacter) =&gt; T): T &#123; for (let comp of this._components) &#123; if (comp instanceof type) &#123; return comp; &#125; &#125;&#125;public addComponent&lt;T extends CharacterComponent&gt;(type: new (arg0: BaseCharacter) =&gt; T, ...args: any[]): T &#123; let component = new type(this); this._components.push(component); this._compInitArgs.push(args); return component;&#125;public removeComponent&lt;T extends CharacterComponent&gt;(type: new (arg0: BaseCharacter) =&gt; T): void &#123; for (let i = 0; i &lt; this._components.length; ++i) &#123; if (this._components[i] instanceof type) &#123; this._components[i].destroy(); this._components.splice(i, 1); this._compInitArgs.splice(i, 1); break; &#125; &#125;&#125; 这样在创建角色时，根据所需创建的角色类型，加入需要的组件（绝大多数组件都是必要的），即可以定制不同的角色，如一个基础角色依赖组件 123456/** 角色属性管理 */public readonly attrComp: CharAttrComponent;/** 角色模型管理 */public readonly animComp: CharAnimComponent;/** 角色AI管理 */public readonly aiComp: CharAIComponent; 如一个战斗角色继承基础角色依赖组件 123456789101112/** 战斗中角色模型管理 继承CharAnimComponent */declare public readonly animComp: CharBattleAnimComponent;/** 管理角色战斗中的一些战斗信息 主要为 战斗中计算 战斗中各种锁敌 */public readonly battleComp: CharBattleComponent;/** 管理角色战斗中移动 */public readonly battleMoveComp: CharBattleMoveComponent;/** 管理角色战斗中技能 */public readonly battleSkillComp: CharBattleSkillComponent;/** 管理角色战斗中血量 护盾 */public readonly battleHPComp: CharBattleHPComponent;/** 管理角色战斗中Buff */public readonly battleBuffComp: CharBattleBuffComponent; 角色组件的划分准则不是绝对的，应该根据项目实时调整，比如最初是没有battleMoveComp组件的，当项目不断迭代以后，角色移动相关比较复杂，就单独划分成了battleMoveComp组件，比如现在战斗锁敌是放在了battleComp，未来项目锁敌复杂以后，也会单独做成battleSearchTargetComp。 组件设计理念 下层组件是不应该调用上层组件的，上层组件可以直接调用下层组件，下层组件可以通过事件派发的方式，通过让上层组件监听事件达到调用上层组件的目的，设计的时候应该尽量将无状态（不需要依赖其他组件）组件设计成下层组件 这里笔者的设计为 第一层：attrComp animComp aiComp 第二层：battleComp 第三层：battleMoveComp battleSkillComp battleHPComp battleBuffComp","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(三) 角色管理","slug":"放置类卡牌战斗-(三)-角色管理","date":"2022-01-06T07:36:17.000Z","updated":"2022-01-26T18:19:00.718Z","comments":true,"path":"放置类卡牌战斗-(三)-角色管理/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%89)-%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86/","excerpt":"","text":"点我回到首页 前言 战斗中会有各种各样的角色，从角色站边类型上有我方单位，敌方单位，中立单位等等，从角色定位上来有玩家养成角色，普通小怪，精英怪，boss，召唤物等等，需要在战斗中对他们进行一定的区分。 角色定位设计 为了战斗中方便判断角色的定位，可以将上述两个维度合起来用位运算加以判断，如 1234567891011/** 战斗单位类型 */export enum BattleSideType &#123; /** 我方角色 */ Player = 1, /** 敌方角色 */ Enemy = 2, /** boss */ Boss = 4, /** 召唤角色 */ Summon = 8,&#125; 设计BattleCharacter 1234567891011export class BattleCharacter &#123; /** 角色类型 */ private _sideType: BattleSideType; /** 是否我方角色 */ public get isPlayerSide(): boolean &#123; return (this._sideType &amp; BattleSideType.Player) &gt; 0; &#125; /** 是否boss */ public get isBoss(): boolean &#123; return (this._sideType &amp; BattleSideType.Boss) &gt; 0; &#125; /** 是否召唤物 */ public get isSummon(): boolean &#123; return (this._sideType &amp; BattleSideType.Summon) &gt; 0; &#125; public get sideType() &#123; return this._sideType; &#125;&#125;这样通过位运算即可以达到战斗中对角色定位的判断 角色管理设计 战斗中角色的生成，更新，销毁等管理，需要有一个统一调度的敌方，将BattleCharacterSP设计成角色工厂和角色容器，提供createBattleCharacter接口给外部调用，并在内部update中对生成的角色进行管理。 BattleCharacterSP承担了角色创建工厂功能，以及内部管理角色的生成，更新，销毁，战斗中创建角色时，只需要调度接口即可。 1234567891011121314151617181920212223242526272829export class BattleCharacterSP extends SceneProcessorBase &#123; /** 我方角色列表 */ public playerSideList: Array&lt;BattleCharacter&gt; = []; /** 敌方角色列表 */ public enemySideList: Array&lt;BattleCharacter&gt; = []; protected override onInit(): void &#123; this.playerSideList = []; this.enemySideList = []; &#125; public createBattleCharacter(): BattleCharacter &#123; // 省略细节 if (character.isPlayerSide) &#123; this.playerSideList.push(character); &#125; else &#123; this.enemySideList.push(character); &#125; // 省略细节 &#125; protected override onUpdate(dt: number): void &#123; // 更新所有角色，有角色死亡移除角色 抛出事件 &#125; protected override onDestroy(): void &#123; // 销毁所有角色 &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(二) 战斗管理","slug":"放置类卡牌战斗-(二)-战斗管理","date":"2022-01-06T06:16:05.000Z","updated":"2022-01-26T18:19:29.140Z","comments":true,"path":"放置类卡牌战斗-(二)-战斗管理/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C)-%E6%88%98%E6%96%97%E7%AE%A1%E7%90%86/","excerpt":"","text":"点我回到首页 前言 卡牌类游戏中会有各种战斗模式，包括PVE模式：推进式刷怪副本，塔防类副本等等，PVP模式：5v5，15v15等等，每种战斗模式的流程不一样，战斗胜利失败条件等等都不一样，需要将这些战斗模式组织好关系。 基础战斗设计 设计BaseBattle代表所有战斗类型的基类，将所有类型战斗都需要的信息放在基类里，比如战斗加载场景资源名（pve一般跟随章节表格，pvp一般固定几张地图），战斗限制时间，战斗是否结束等等。 其他战斗类型战斗继承BaseBattle，复写BaseBattle中生命周期的函数，即可以实现不同战斗类型下战斗流程各自的管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758export abstract class BaseBattle &#123; /** 战斗是否自动 */ private _isAuto: boolean = false; /** 战斗倍速 */ private _curSpeed: number = 1; /** 准备资源 */ public prepare(): void &#123; this.onPrepare(); &#125; public start(): void &#123; this.onStart(); &#125; public update(dt: number): void &#123; if (this.battleEnd) return; this.onUpdate(dt); &#125; public destroy(): void &#123; this.onDestroy(); &#125; public handleCharacterDying(character: BattleCharacter) &#123; this.onHandleCharacterDying(character); &#125;; public handleCharacterDie(character: BattleCharacter) &#123; this.onHandleCharacterDie(character); &#125;; /** 准备资源 */ protected onPrepare(): void &#123; &#125;; /** 战斗开始 */ protected onStart(): void &#123; &#125; /** 战斗更新 */ protected onUpdate(dt: number) &#123; &#125;; /** 战斗销毁 */ protected onDestroy(): void &#123; &#125; /** 有角色血量归零播放死亡动作时候处理 */ protected onHandleCharacterDying(character: BattleCharacter) &#123; &#125; /** 有角色从战场移除以后处理 */ protected onHandleCharacterDie(character: BattleCharacter) &#123; &#125; /** 战斗场景ID */ public abstract resID: string; /** 战斗是否结束 */ public abstract battleEnd: boolean; /** 战斗类型 */ public abstract battleType: BattleType; /** 战斗限制时间 */ public abstract limitTime: number; /** 战场的位置 */ public get position(): Vector3 &#123; return Vector3.zero; &#125; /** 是否强制自动战斗 */ public get forceAuto(): boolean &#123; return false; &#125;&#125; 战斗创建设计 在BattleSP中根据服务器传来的数据判断开启不同的战斗，并在自己的生命周期中对开启的战斗进行调度即可。 12345678910111213141516171819202122232425262728293031export class BattleSP extends SceneProcessorBase &#123; private _curBattle: BaseBattle; protected override onPrepare(): void &#123; /** 后端验证后开启的战斗信息 */ let curBattleInfo; // 省略细节 if (curBattleInfo.type === BattleType.Adventure) &#123; this._curBattle = new AdventureBattle(this, curBattleInfo); &#125; else if (curBattleInfo.type === BattleType.Explore) &#123; this._curBattle = new ExploreBattle(this, curBattleInfo); &#125; else if (curBattleInfo.type === BattleType.Arena) &#123; this._curBattle = new ArenaBattle(this, curBattleInfo); &#125; this._curBattle.prepare(); &#125; protected override onLateInit(): void &#123; this._curBattle.start(); &#125; protected override onUpdate(dt: number) &#123; this._curBattle.update(dt); &#125; protected override onDestroy(): void &#123; this._curBattle.destroy(); &#125; public get curBattle(): BaseBattle &#123; return this._curBattle; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗(一) 功能分工","slug":"放置类卡牌战斗-(一)-功能分工","date":"2022-01-06T06:10:06.000Z","updated":"2022-02-01T13:29:30.345Z","comments":true,"path":"放置类卡牌战斗-(一)-功能分工/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%80)-%E5%8A%9F%E8%83%BD%E5%88%86%E5%B7%A5/","excerpt":"","text":"点我回到首页 前言 战斗中会涉及各种模块间交互配合，包括战斗流程，角色，相机，地图，飘字等等，如果这些模块全部杂糅在一起，则会使得代码非常臃肿，需要将这些模块解耦，使得关联性较强的代码内聚在一起，提升代码可读性，也方便后续相关功能拓展 场景处理基类 设计公有父类SceneProcessorBase代表所有模块的基类 123456789101112131415161718192021222324252627282930313233343536373839404142export class SceneProcessorBase &#123; public prepare(): void &#123; this.onPrepare(); &#125; public update(dt: number): void &#123; this.onUpdate(dt); &#125; public init(): Promise&lt;void&gt; &#123; this.onInit(); return new Promise&lt;void&gt;((resolve) =&gt; &#123; this.onAsyncInit(resolve); &#125;); &#125; public lateInit(): Promise&lt;void&gt; &#123; this.onLateInit(); return new Promise&lt;void&gt;((resolve) =&gt; &#123; this.onAsyncLateInit(resolve); &#125;); &#125; public destroy(): void &#123; this.onDestroy(); &#125; /** 加载场景的准备 */ protected onPrepare(): void &#123; &#125; /** 初始化 */ protected onInit(): void &#123; &#125; /** 异步初始化 */ protected onAsyncInit(onPrepared: () =&gt; void): void &#123; onPrepared(); &#125; /** 后初始化 */ protected onLateInit(): void &#123; &#125; /** 异步后初始化 */ protected onAsyncLateInit(onPrepared: () =&gt; void): void &#123; onPrepared(); &#125; /** 场景初始化后每帧调用 */ protected onUpdate(dt: number): void &#123; &#125; /** 场景销毁 */ protected onDestroy(): void &#123; &#125;&#125; 战斗中模块划分 将不同模块功能包装成对应的SP(SceneProcessor)，并在BaseScene中封装接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export abstract class BaseScene &#123; private _d_processors: Array&lt;SceneProcessorBase&gt;; /** 特效 */ public effectSP: EffectSP; /** 声音 */ public soundSP: SoundSP; /** 增加基础的sp */ protected addBaseProcessors() &#123; this.soundSP = this.addProcessor(SoundSP); this.effectSP = this.addProcessor(EffectSP); &#125; /** 添加一个sceneProcessor对象（待后续初始化） */ public addProcessor&lt;TSceneProcessor extends SceneProcessorBase&gt;(ProcessorClass: new (arg0: BaseScene): TSceneProcessor): TSceneProcessor &#123; let sceneProcessor = new ProcessorClass(this); this._d_processors.push(sceneProcessor); sceneProcessor &amp;&amp; sceneProcessor.prepare(); return sceneProcessor; &#125; /** 初始化（包含异步）sceneProcessor*/ public async initProcessors(): Promise&lt;void&gt; &#123; for (let processor of this._d_processors) &#123; await processor.init(); &#125; for (let processor of this._d_processors) &#123; await processor.lateInit(); &#125; &#125; /** 更新sceneProcessor */ public updateProcessors(): void &#123; for (let processor of this._d_processors) &#123; processor.update(Time.deltaTime); &#125; &#125; /** 删除sceneProcessor */ protected destroyProcessors() &#123; for (let i = this._d_processors.length - 1; i &gt;= 0; --i) &#123; let proc = this._d_processors[i]; proc.destroy(); &#125; this._d_processors = []; &#125;&#125; 这样战斗场景封装好战斗场景内特有的SP(SceneProcessor)，可以有如下的实现： 123456789101112131415161718192021222324252627export class BattleScene extends BaseScene &#123; /** 战斗流程 */ public battleSP: BattleSP; /** 战斗中角色 */ public battleCharacterSP: BattleCharacterSP; /** 战斗中宝物 */ public battleTreasureSP: BattleTreasureSP; /** 战斗中漂浮元素 类似飘字 气泡 血条 */ public battleFloatElementSP: BattleFloatElementSP; /** 战斗中地图 */ public battleMapSP: BattleMapSP; /** 战斗中相机 */ public battleCameraSP: BattleCameraSP; /** 战斗中释放的技能 包括子弹 */ public battleActionSP: BattleActionSP; protected override addBaseProcessors() &#123; super.addBaseProcessors(); this.battleActionSP = this.addProcessor(BattleActionSP); this.battleFloatElementSP = this.addProcessor(BattleFloatElementSP); this.battleSP = this.addProcessor(BattleSP); this.battleCharacterSP = this.addProcessor(BattleCharacterSP); this.battleTreasureSP = this.addProcessor(BattleTreasureSP); this.battleMapSP = this.addProcessor(BattleMapSP); this.battleCameraSP = this.addProcessor(BattleCameraSP); &#125;&#125; 这样就可以达到功能模块的相互隔离，不同SP(SceneProcessor)之间通过暴露的功能接口相互调用，使得模块内代码内聚。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"放置类卡牌战斗 个人总结","slug":"放置类卡牌战斗-个人总结","date":"2022-01-06T03:18:55.000Z","updated":"2022-01-26T18:18:18.542Z","comments":true,"path":"放置类卡牌战斗-个人总结/","link":"","permalink":"http://www.lidamo.cn/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言 作为游戏玩家，接触放置类卡牌也很多年了，从最早的刀塔传奇，到后来的公主连结，剑与远征，市面上很多游戏都有这种战斗类型的影子，作为游戏开发者，这两年也一直从事放置类卡牌战斗相关的开发，踩了很多坑，也收获了很多，特此记录一下。 设计思考 战斗模块一般是这种卡牌类游戏中相对来说比较核心的模块，游戏中很多玩法都会跟战斗相关，角色卡牌的收集养成也会在战斗中得到验证。对于整个战斗模块来说，早期框架的设计是比较重要的，一方面，由于战斗中各种复杂逻辑的存在，如果设计不合理，逻辑处理的非常混乱，会存在很多逻辑漏洞，一方面，由于随着版本开发，游戏中会不断加入新的战斗机制，同时也会不断的增加新的角色和新的技能机制，如果设计非常杂乱，代码没有进行有效管理，会非常影响后续各种拓展。 设计理念 框架设计中需要遵循的理念为框架本身是服务于项目的，很多设计也是需要基于游戏玩法决定，在框架设计之初，需要和游戏策划团队商量好游戏未来的大方向，以及可能会出现的一些机制，明确了项目的大方向，再着手考虑框架设计，不然就会产生很多冗余设计，也会有很多未曾想到的方面。 设计要点细分 整体战斗模块涉及的内容比较多，有些模块因为业务的需求细节部分也比较多，整理了一下大概有以下要点： （所有代码部分只列出了一部分作为参考，有需要可以根据项目内容补充） 放置类卡牌战斗(一) 功能分工 放置类卡牌战斗(二) 战斗管理 放置类卡牌战斗(三) 角色管理 放置类卡牌战斗(四) 角色设计-整体 放置类卡牌战斗(五) 角色设计-属性 放置类卡牌战斗(六) 角色设计-模型 放置类卡牌战斗(七) 角色设计-AI 放置类卡牌战斗(八) 角色设计-战斗基础 放置类卡牌战斗(九) 角色设计-战斗技能 放置类卡牌战斗(十) 角色设计-战斗Buff 放置类卡牌战斗(十一) 角色设计-战斗血量 放置类卡牌战斗(十二) 角色设计-战斗移动 放置类卡牌战斗(十三) 宝物管理 放置类卡牌战斗(十四) 宝物设计-战斗宿主 放置类卡牌战斗(十五) 宝物设计-战斗技能 放置类卡牌战斗(十六) 技能基础和管理 放置类卡牌战斗(十七) 技能设计-ActionEvent 放置类卡牌战斗(十八) 技能设计-Action整体 放置类卡牌战斗(十九) 技能设计-Action发射器 放置类卡牌战斗(二十) 技能设计-Action攻击实体 放置类卡牌战斗(二十一) 技能设计-Action受击反馈 放置类卡牌战斗(二十二) 技能设计-总结 放置类卡牌战斗(二十三) 相机管理 放置类卡牌战斗(二十四) 完结","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"战斗","slug":"技术/战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/"},{"name":"放置类卡牌战斗","slug":"技术/战斗/放置类卡牌战斗","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E6%88%98%E6%96%97/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Puerts 自动导入命名空间","slug":"Puerts-自动导入命名空间","date":"2022-01-04T14:22:42.000Z","updated":"2022-02-01T13:53:41.160Z","comments":true,"path":"Puerts-自动导入命名空间/","link":"","permalink":"http://www.lidamo.cn/Puerts-%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"","text":"前言 Puerts项目中，由于ts没有类似c#的自动导入命名空间功能，当调用带有命名空间的类时，都需要写入全称，例如定义一个Vector3，往往都需要这么写： 1let example: UnityEngine.Vector3 = UnityEngine.Vector3.zero; 这样的写法在项目中非常的不方便，并且非常繁琐，看了这个大佬的文章以后解决了这个问题，特此记录总结一下。 参考文章 创建d.ts ts中有一个d.ts的设计，类似c++的头文件，利用这个特性可以在项目根目录下创建一个d.ts文件，例如csharp.ref.d.ts, 写入如下内容： 1234567891011121314declare module &quot;csharp.System&quot; &#123; import * as csharp from &quot;csharp&quot;; export = csharp.System;&#125;declare module &quot;csharp.UnityEngine&quot; &#123; import * as csharp from &quot;csharp&quot;; export = csharp.UnityEngine;&#125;declare module &quot;csharp.UnityEngine.UI&quot; &#123; import * as csharp from &quot;csharp&quot;; export = csharp.UnityEngine.UI;&#125; 这样的话在写代码过程中由于这个文件的存在，可以直接写出如下代码，并且import部分是自动根据代码提示生成的 12import &#123; Vector3 &#125; from &#x27;csharp.UnityEngine&#x27;let example: Vector3 = Vector3.zero; 写入执行代码 由于上面的d.ts文件是我们偷换了命名空间，所以需要在项目的开始执行如下代码： 1234567891011121314import * as csharp from &#x27;csharp&#x27;;let namespaces = new Map();namespaces.set(&quot;csharp.System&quot;, csharp.System);namespaces.set(&quot;csharp.UnityEngine&quot;, csharp.UnityEngine);namespaces.set(&quot;csharp.UnityEngine.UI&quot;, csharp.UnityEngine.UI);(function () &#123; let puerts = (this ?? globalThis).puerts; namespaces.forEach((module, name) =&gt; &#123; module.default = module; puerts.registerBuildinModule(name, module); &#125;);&#125;)(); 可以创建一个新文件保存如上代码，然后再js虚拟机执行一开始执行这个文件，然后再执行项目开始文件即可，例如我项目中是这样执行的： 12JsEnv.Eval(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;ImportModule&quot;));JsEnv.Eval(string.Format(&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;, &quot;TsGame&quot;)); ImportModule为上述导入命名空间文件，TsGame为项目开始文件，这样就可以在项目中不用再写复杂的命名空间了 思考 其他命名空间都可以采用如上方法，在d.ts添加需要更换的命名空间，然后在ImportModule中注册修改的命名空间即可","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"Puerts 支持 DOTween","slug":"Puerts-支持-DOTween","date":"2022-01-04T14:10:23.000Z","updated":"2022-02-04T05:02:10.533Z","comments":true,"path":"Puerts-支持-DOTween/","link":"","permalink":"http://www.lidamo.cn/Puerts-%E6%94%AF%E6%8C%81-DOTween/","excerpt":"","text":"前言 新版的Puerts已经默认支持DOTween(笔者试了一下1.2.3版本已经可以支持DoTween了)， 老版的Puerts项目中默认没有支持DOTween，项目中需要使用DOTween时，需要一些辅助措施，参考这个大佬的文章，特此记录一下。参考文章 C#导出配置 C#对应的Puerts配置中，注册DOTween命名空间 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 第三方插件的代码绑定与导出（到ts）/// &lt;/summary&gt;[Puerts.Binding]public static IEnumerable&lt;Type&gt; ThirdPartsBindings&#123; get &#123; string[] namespaces = &#123; &quot;DG.Tweening&quot;, &#125;; return from type in getTypesByNamespaces(namespaces) select type; &#125;&#125;/// &lt;summary&gt;/// 遍历给定命名空间public的所有类型/// &lt;/summary&gt;/// &lt;param name=&quot;spaceNameList&quot;&gt;命名空间名称列表&lt;/param&gt;/// &lt;returns&gt;类型列表&lt;/returns&gt;private static IEnumerable&lt;Type&gt; getTypesByNamespaces(ICollection&lt;string&gt; spaceNameList)&#123; return from assembly in validAssemblies from type in assembly.GetTypes() where spaceNameList.Contains(type.Namespace) &amp;&amp; (type != null &amp;&amp; type.IsPublic) select type;&#125; 也可以显式注册 123456789// DOTweentypeof(DG.Tweening.Sequence),typeof(DG.Tweening.DOTween),typeof(DG.Tweening.DOTweenModuleSprite),typeof(DG.Tweening.DOTweenModuleUI),typeof(DG.Tweening.ShortcutExtensions),typeof(DG.Tweening.TweenExtensions),typeof(DG.Tweening.TweenSettingsExtensions),typeof(DG.Tweening.Ease), ts中注册拓展 12345678910111213141516171819202122232425262728private _initDoTween(): void &#123; $extension(Component, DG.Tweening.ShortcutExtensions); $extension(Transform, DG.Tweening.ShortcutExtensions); $extension(DG.Tweening.Tween, DG.Tweening.TweenExtensions); $extension(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions); $extension(UI.Image, DG.Tweening.DOTweenModuleUI); $extension(UI.Text, DG.Tweening.DOTweenModuleUI); $extension(RectTransform, DG.Tweening.DOTweenModuleUI); $extension(SpriteRenderer, DG.Tweening.DOTweenModuleSprite); let tweenerVector3 = $generic(DG.Tweening.Core.TweenerCore$3, Vector3, Vector3, DG.Tweening.Plugins.Options.VectorOptions); $extension(tweenerVector3, DG.Tweening.TweenSettingsExtensions); let tweenerVector2 = $generic(DG.Tweening.Core.TweenerCore$3, Vector2, Vector2, DG.Tweening.Plugins.Options.VectorOptions); $extension(tweenerVector2, DG.Tweening.TweenSettingsExtensions); let tweenerString = $generic(DG.Tweening.Core.TweenerCore$3, System.String, System.String, DG.Tweening.Plugins.Options.StringOptions); $extension(tweenerString, DG.Tweening.TweenSettingsExtensions); let tweenerQuaternion1 = $generic(DG.Tweening.Core.TweenerCore$3, Quaternion, Vector3, DG.Tweening.Plugins.Options.QuaternionOptions); $extension(tweenerQuaternion1, DG.Tweening.TweenSettingsExtensions); let tweenerQuaternion2 = $generic(DG.Tweening.Core.TweenerCore$3, Quaternion, Quaternion, DG.Tweening.Plugins.Options.QuaternionOptions); $extension(tweenerQuaternion2, DG.Tweening.TweenSettingsExtensions); let tweenerColor = $generic(DG.Tweening.Core.TweenerCore$3, Color, Color, DG.Tweening.Plugins.Options.ColorOptions); $extension(tweenerColor, DG.Tweening.TweenSettingsExtensions);&#125; 在项目一开始执行如上函数，即可以在项目中像C#中一样使用DOTween了如: 1this._charTrans.DOScale(Vector3.one, 5); 思考 上面只列出了一部分拓展函数，有其他需要时候，可以根据上面的拓展函数照葫芦画瓢即可。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"Puerts 双击打印日志跳转代码","slug":"Puerts-双击打印日志跳转代码","date":"2022-01-04T05:07:39.000Z","updated":"2022-02-04T04:00:45.389Z","comments":true,"path":"Puerts-双击打印日志跳转代码/","link":"","permalink":"http://www.lidamo.cn/Puerts-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/","excerpt":"","text":"前言 Unity项目中用了Puerts这种热更方式以后，Unity的console下输出的日志是不能双击跳到对应ts代码模块的，这样在开发过程中调试时候只能人工去寻找对应代码，非常的不方便以及影响开发效率，利用Unity的OnOpenAsset和正则匹配可以实现一个调试工具达到双击打印日志跳转到对应ts代码的效果，方便项目中的调试。 输出js(ts)堆栈 如图所示，Puerts输出的日志是没有js(ts)堆栈的，所以先要想办法让代码输出js(ts)堆栈信息， 这里我们找到Puerts中”\\Src\\Resources\\puerts”下的log.js文件，作者为了让console.log输出到Unity的console目录下修改了console.log函数，可以看到如下代码 1234console.log = function () &#123; if (console_org) console_org.log.apply(null, Array.prototype.slice.call(arguments)); UnityEngine_Debug.Log(toString(arguments));&#125; 这里我们参照这篇文章js获取当前代码行号将log中代码改成 12345console.log = function () &#123; let error = new Error(toString(arguments)).stack.split(&quot;Error: &quot;)[1]; if (console_org) console_org.log(error); UnityEngine_Debug.Log(error);&#125; 可以看到项目中的代码已经可以输出js堆栈信息了。 这里要注意一下，由于项目最终运行的是js代码，所以直接输出是js堆栈信息，如果需要输出ts堆栈信息，需要找一个sourcemap解析库，这个js解析库不依赖node或者浏览器，还是比较难找的。 或者区分平台在pc端用node环境方便调试，真机环境下换回v8环境(这个目前官方应该已经支持了)，由于做这个工具时候官方还未推行pc版本的node环境，暂时只输出了js堆栈 外部sourcemap支持 由于刚才说过，输出的是js堆栈，所以需要在外部做一个sourcemap支持，在项目根目录下 执行 npm install source-map-support –save 安装source-map-support插件，安装完之后新建一个js文件，我这里起名log.js，写入如下代码 1234567891011121314151617var sourceMapSupport = require(&#x27;source-map-support&#x27;)var source = process.argv[2]var line = process.argv[3]var column = process.argv[4]var p = sourceMapSupport.mapSourcePosition( &#123; source: source, line: Number(line), column: Number(column) &#125;)console.log(p.source);console.log(p.line);console.log(p.column); 这个工具函数可以根据传入的js文件名，js行数，js列数，输出对应的源ts文件名，源ts行数，源ts列数 绑定IDE 在做代码跳转之前，需要让Unity绑定对应的IDE，一般的开发IDE中，VSCode和IDEA居多，有需要也可以拓展，在Unity Editor目录下新建文件，写入如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using UnityEditor;using UnityEngine;public enum TypeScriptIDEType&#123; IDEA = 0, VSCode&#125;public class TypeScriptIDESetting : EditorWindow&#123; [MenuItem(&quot;程序工具/TypeScript/TypeScriptIDE路径配置&quot;)] public static void SetIDEPath() &#123; TypeScriptIDESetting editor = CreateInstance&lt;TypeScriptIDESetting&gt;(); editor.Show(); &#125; public string[] TypeScriptIDETypes = new string[] &#123; &quot;IDEA&quot;, &quot;VSCode&quot; &#125;; void OnGUI() &#123; int typeScriptIDETypeIndex = EditorPrefs.GetInt(&quot;TYPESCRIPT_IDE_TYPE&quot;); typeScriptIDETypeIndex = EditorGUILayout.Popup(typeScriptIDETypeIndex, TypeScriptIDETypes); EditorPrefs.SetInt(&quot;TYPESCRIPT_IDE_TYPE&quot;, typeScriptIDETypeIndex); TypeScriptIDEType typeScriptIDEType = (TypeScriptIDEType)typeScriptIDETypeIndex; if (typeScriptIDEType == TypeScriptIDEType.IDEA) &#123; GUILayout.Label(&quot;IDEA IDE路径:&quot;); string ideaPath = EditorPrefs.GetString(&quot;IDEA_IDE_Path&quot;); GUILayout.TextField(ideaPath); if (GUILayout.Button(&quot;Browse&quot;)) &#123; ideaPath = UnityEditor.EditorUtility.OpenFilePanel(&quot;选择路径&quot;, &quot;&quot;, &quot;exe&quot;); EditorPrefs.SetString(&quot;IDEA_IDE_Path&quot;, ideaPath); &#125; &#125; else if (typeScriptIDEType == TypeScriptIDEType.VSCode) &#123; GUILayout.Label(&quot;VSCode IDE路径:&quot;); string vscodePath = EditorPrefs.GetString(&quot;VSCode_IDE_Path&quot;); GUILayout.TextField(vscodePath); if (GUILayout.Button(&quot;Browse&quot;)) &#123; vscodePath = UnityEditor.EditorUtility.OpenFilePanel(&quot;选择路径&quot;, &quot;&quot;, &quot;exe&quot;); EditorPrefs.SetString(&quot;VSCode_IDE_Path&quot;, vscodePath); &#125; &#125; &#125;&#125; 在Unity标签栏寻找对应的标签，这里我放到了”程序工具/TypeScript/TypeScriptIDE路径配置”下，打开后跳出如上界面即可以绑定对应的IDE地址 双击跳转 这里利用Unity的OnOpenAssetAttribute在Editor目录下新建文件写入如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134using System.Diagnostics;using System.IO;using System.Reflection;using System.Text.RegularExpressions;using UnityEditor;public class TypeScriptLogLocation&#123; [UnityEditor.Callbacks.OnOpenAssetAttribute(0)] static bool OnOpenAsset(int instanceID, int line) &#123; string stackTrace = GetStackTrace(); // 正则匹配 MatchCollection matches = Regex.Matches(stackTrace, &quot;at(.*?.js:\\\\d+:\\\\d+)&quot;); if (matches != null &amp;&amp; matches.Count &gt;= 1) &#123; Match match = matches[0]; // puerts 需要跳转到堆栈第二条（这里需要根据项目内容具体调整） if (match.Groups[1].Value.Contains(&quot;console.log&quot;)) &#123; return (matches.Count &gt;= 2 &amp;&amp; OpenTypeScriptLocation(matches[1])); &#125; else &#123; return OpenTypeScriptLocation(matches[0]); &#125; &#125; return false; &#125; // 获取输出堆栈 static string GetStackTrace() &#123; System.Type consoleWindowType = typeof(EditorWindow).Assembly.GetType(&quot;UnityEditor.ConsoleWindow&quot;); FieldInfo ms_ConsoleWindow_fieldInfo = consoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic); EditorWindow consoleWindowInstance = ms_ConsoleWindow_fieldInfo.GetValue(null) as EditorWindow; if (null != consoleWindowInstance) &#123; if (EditorWindow.focusedWindow == consoleWindowInstance) &#123; FieldInfo m_ActiveText_fieldInfo = consoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic); return m_ActiveText_fieldInfo.GetValue(consoleWindowInstance).ToString(); &#125; &#125; return string.Empty; &#125; static bool OpenTypeScriptLocation(Match match) &#123; if (!match.Success) return false; string resPath; string resLine; string resColumn; DealMatch(match, out resPath, out resLine, out resColumn); OpenIDE(resPath, System.Convert.ToInt32(resLine), System.Convert.ToInt32(resColumn)); return true; &#125; static void DealMatch(Match match, out string resPath, out string resLine, out string resColumn) &#123; //字符串解析获取对应js文件名，行数，列数 string pathLine = match.Groups[1].Value; int colomnIndex = pathLine.LastIndexOf(&#x27;:&#x27;); int colomn = System.Convert.ToInt32(pathLine.Substring(colomnIndex + 1)); // js列数 pathLine = pathLine.Substring(0, colomnIndex); int lineIndex = pathLine.LastIndexOf(&#x27;:&#x27;); int line = System.Convert.ToInt32(pathLine.Substring(lineIndex + 1)); // js行号 int pathIndex = pathLine.LastIndexOf(&quot;(&quot;); string path = pathLine.Substring(pathIndex + 1, lineIndex - pathIndex - 1); // js文件名 Process process = new Process(); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = &quot;node&quot;; // 对应sourcemap解析工具函数（注意路径为windows下路径） startInfo.Arguments = System.Environment.CurrentDirectory.Replace(&quot;\\\\&quot;, &quot;/&quot;) + string.Format(&quot;/log.js &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, path.Replace(&quot;\\\\&quot;, &quot;/&quot;), line, colomn); startInfo.UseShellExecute = false; startInfo.CreateNoWindow = true; startInfo.RedirectStandardOutput = true; startInfo.RedirectStandardInput = true; process.StartInfo = startInfo; process.Start(); StreamReader reader = process.StandardOutput; //截取输出流 每次读取一行 resPath = reader.ReadLine(); // ts文件名 resLine = reader.ReadLine(); // ts行数 resColumn = reader.ReadLine(); // ts列数 process.WaitForExit(); // 等待程序执行完退出进程 process.Close(); // 关闭进程 reader.Close(); // 关闭流 &#125; // 打开IDE static void OpenIDE(string path, int line, int column) &#123; int typeScriptIDETypeIndex = EditorPrefs.GetInt(&quot;TYPESCRIPT_IDE_TYPE&quot;); TypeScriptIDEType typeScriptIDEType = (TypeScriptIDEType)typeScriptIDETypeIndex; string idePath = string.Empty; if (typeScriptIDEType == TypeScriptIDEType.IDEA) &#123; idePath = EditorPrefs.GetString(&quot;IDEA_IDE_Path&quot;); &#125; else if (typeScriptIDEType == TypeScriptIDEType.VSCode) &#123; idePath = EditorPrefs.GetString(&quot;VSCode_IDE_Path&quot;); &#125; if (string.IsNullOrEmpty(idePath) || !System.IO.File.Exists(idePath)) &#123; return; &#125; string args = string.Empty; if (typeScriptIDEType == TypeScriptIDEType.IDEA) &#123; args = $&quot;--line &#123;line&#125; &#123;path.Replace(&quot;\\\\&quot;, &quot;/&quot;)&#125;&quot;; &#125; else if (typeScriptIDEType == TypeScriptIDEType.VSCode) &#123; args = string.Format(&quot;-g &#123;0&#125;:&#123;1&#125;&quot;, path.Replace(&quot;\\\\&quot;, &quot;/&quot;), line); &#125; Process process = new Process(); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = idePath; startInfo.Arguments = args; startInfo.UseShellExecute = false; startInfo.CreateNoWindow = false; startInfo.RedirectStandardOutput = false; process.StartInfo = startInfo; process.Start(); return; &#125;&#125; 上面这些代码都调整好以后，双击Unity对应console下输出日志，即可在对应IDE中跳转到对应的ts代码行数 思考 由于做这个工具的时候，官方还没有支持pc版本的sourcemap支持，目前应该可以直接利用官方提供的sourcemap支持，输出ts堆栈，调试上应该更方便一点，毕竟现在这种做法unity console下输出的还是js堆栈信息 目前工具只做了windows版本,其他如mac版本可能需要在绑定和打开IDE中做出一定调整。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Puerts","slug":"技术/Puerts","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/Puerts/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://www.lidamo.cn/tags/typescript/"}]},{"title":"Unity资源管理 (四) Resources目录","slug":"Unity资源管理-(四)-Resources目录","date":"2021-05-21T07:56:24.000Z","updated":"2022-02-01T14:03:55.370Z","comments":true,"path":"Unity资源管理-(四)-Resources目录/","link":"","permalink":"http://www.lidamo.cn/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E5%9B%9B)-Resources%E7%9B%AE%E5%BD%95/","excerpt":"","text":"Resources目录 所有放在Assets/Resources目录下（可以是一个，也可以有很多个，可以在任意的子目录下面）的资源都当做Resources。无论游戏是否使用，都会被打包到最终的程序里，并能通过以下方法获得对象： 1Resources.Load(&quot;fileName&quot;); 注意：函数内的参数为相对于Resource目录下的文件路径与名称，不包含后缀。 在运行时,Assets目录下所有Resources的文件路径将被合并。 例：Assets/Resources/test.txt 与 Assets/Test/Resources/test.png在使用Resource.Load(“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt； 如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象： 1Object[] assets = Resources.LoadAll(&quot;fileName&quot;); Resources弊端 官方文档 官方的建议是不要使用它。提出此强烈建议的原因有以下： 使用Resources文件夹会使内存管理更加困难 资源文件夹使用不当会增加应用程序启动时间和构建时间，随着Resources文件夹的数量增加，在这些文件夹中管理Asset变得非常困难 Resources内的资源无法增量更新。 Resources使用场景 在项目的整个生命周期中需要的 很重要且不占用大量内存的 不怎么需要更新，或在不同平台或设备上不变化的 用于系统启动时候最小引导的。 Resource 序列化 在构建项目时，所有名为Resources的文件夹中的Asset和Object将组合到一个序列化的文件中。该文件还包含metadata和索引信息，类似于AssetBundle。 如AssetBundle文档中所述，此索引包括一个序列化的查找树，用于索引相应的File GUID和Local ID，并且它还要记录在序列化文件中的偏移量 在大多数平台上，查找数据结构是红黑树，其构建时间以O(nlog(n))的速度增长。这种增长还导致索引的加载时间随着Resources文件夹中Object数量的增加而线性增长。 在低端移动设备上初始化包含10,000个Asset的Resources系统会耗费数秒钟的时间，即使实际上很少需要将Resources文件夹中包含的大多数Object加载到应用程序的第一个场景中。 参考 https://zhuanlan.zhihu.com/p/97149491","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"资源管理","slug":"技术/资源管理","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Unity","slug":"技术/资源管理/Unity","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/Unity/"}],"tags":[]},{"title":"Unity资源管理 (三) Unity默认路径","slug":"Unity资源管理-(三)-Unity默认路径","date":"2021-05-19T06:41:44.000Z","updated":"2022-02-01T14:20:33.090Z","comments":true,"path":"Unity资源管理-(三)-Unity默认路径/","link":"","permalink":"http://www.lidamo.cn/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%B8%89)-Unity%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84/","excerpt":"","text":"前言 Unity中总共有四个数据文件路径dataPath、streamingAssetsPath、 persistentDataPath、temporaryCachePath，四个路径都是相对路径，不同平台下返回的路径不一样。 Application.dataPath 官方文档 dataPath是包含游戏数据文件夹的路径，是app程序包安装路径（安装应用时，系统自动将安装包拷贝到dataPath路径下进行安装），一般不会去手动读写这个目录。 Application.dataPath 读 写 Editor 是 是 Android 否 否 IOS 是 否 Application.persistentDataPath 官方文档 persistentDataPath是一个持久化数据存储目录。当应用程序发布到IOS和Android平台，这个路径会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，但可被用户直接删除。 Application.persistentDataPath 读 写 Editor 是 是 Android 是 是 IOS 是 是 读写方式：可以用System.IO.StreamReader和System.IO.StreamWriter，也可用System.IO.File.ReadAllText和System.IO.File.WriteAllText。写入之前，记得要先Directory.Exists(folderPath)判断路径是否存在。 Application.streamingAssetsPath 官方文档 官方文档 streamingAssetsPath返回的是流数据的缓存目录，适合用来存储一些外部数据文件用于读取，一般是存放二进制文件（比如：AssetBundle、.csv等）。StreamingAssets文件夹内的东西不会被加密，放进去什么就是什么，所以不要直接把数据文件赤裸裸地放到这个目录下。一般不会去手动将数据写入这个目录。 Application.streamingAssetsPath 读 写 Editor 是 是 Android 是 否（可通过第三方软件实现读写） IOS 是 是 StreamingAssets中资源可使用 I/O 读取，但 WebGL 和 Android 平台下该路径为 URL，不支持直接获取，因此需使用UnityWebRequest获取。若其他平台使用 UnityWebRequest 获取，则需在路径前加上**”file://“** ，如 “file://“ + Application.streamingAssetsPath + “/file.mp4” Application.temporaryCachePath temporaryCachePath返回一个临时数据缓存目录。当应用程序发布到IOS和Android平台，这个路径也会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，手机空间不足时才可能会被系统清除。 Application.temporaryCachePath 读 写 Editor 是 是 Android 是 是 IOS 是 是 路径地址 Application.dataPath 平台 地址 Editor 项目路径/Assets Windows 安装路径/ProductName_Data Mac OS /Applications/AppName.app/Contents iOS /Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data Android /data/app/package.name.apk Application.persistentDataPath 平台 地址 Editor C:/Users/username/AppData/LocalLow/CompanyName/ProductName 或 /Users/username/Library/Application Support/CompanyName/ProductName Windows C:/Users/username/AppData/LocalLow/CompanyName/ProductName Mac OS /Users/username/Library/Application Support/CompanyName/ProductName iOS /Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents Android /data/data/package.name/files Application.streamingAssetsPath 平台 地址 Editor 项目路径/Assets/StreamingAssets Windows 安装路径/ProductName_Data/StreamingAssets Mac OS /Applications/AppName.app/Contents/Resources/Data/StreamingAssets iOS /Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data/Raw Android jar:file:///data/app/package.name.apk/!/assets Application.temporaryCachePath 平台 地址 Editor C:/Users/username/AppData/Local/Temp/CompanyName/ProductName 或 /var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName Windows C:/Users/username/AppData/Local/Temp/CompanyName/ProductName Mac OS /var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName iOS /Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches Android /data/data/package.name/cache 注意事项 Android下，Application.streamingAssetsPath目录下文件被压缩到单独的.jar文件，不能直接用System.IO 读取，只能用UnityWebRequest读取 在IOS和Android下，可以使用AssetBundle.LoadFromFile来同步读取Application.streamingAssetsPath中数据 统一用UnityWebRequest读取代码可以如下：123456789 string path =#if UNITY_ANDROID &amp;&amp; !UNITY_EDITOR Application.streamingAssetsPath;#elif UNITY_IPHONE &amp;&amp; !UNITY_EDITOR &quot;file://&quot; + Application.streamingAssetsPath;#elif UNITY_STANDLONE_WIN || UNITY_EDITOR &quot;file://&quot; + Application.streamingAssetsPath;#else string.Empty; Android下，Unity以前版本直接使用Application.streamingAssetsPath是不能直接得到实际目录，需要写成 “jar:file://“ + Application.dataPath + “!/assets/“ + 资源的形式，现在已经修复，可以直接使用Application.streamingAssetsPath Android下，可以考虑把Application.streamingAssetsPath下文件拷贝至Application.persistentDataPath，这样读取的方式可以完全不受限制。可以参考https://www.bbsmax.com/A/A2dmkX1BJe/ 参考https://zhuanlan.zhihu.com/p/141641436 https://blog.csdn.net/BillCYJ/article/details/99712313","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"资源管理","slug":"技术/资源管理","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Unity","slug":"技术/资源管理/Unity","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/Unity/"}],"tags":[]},{"title":"Unity资源管理 (二) Asset","slug":"Unity资源管理-(二)-Asset","date":"2021-05-14T10:02:46.000Z","updated":"2022-02-01T13:58:34.135Z","comments":true,"path":"Unity资源管理-(二)-Asset/","link":"","permalink":"http://www.lidamo.cn/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%BA%8C)-Asset/","excerpt":"","text":"Asset 和 ObjectAsset（资源文件） 关于Asset，网上已经有很多解释了，可以去看https://zhuanlan.zhihu.com/p/96709802 简单来说，Asset是位于Assets目录下，可以在Unity的Projects窗口里看到的单个文件。这些就是平常项目中用到的资源文件，例如纹理，音效文件，预制体等等。 Object （对象） Object是指从UnityEngine.Object继承的对象，是一个可以序列化的数据，是用来描述一个特定的资源的实例。例如Mesh, Sprite, AudioClip or AnimationClip等等。 Asset和Object 刚学习时，会把Asset和Object搞混，这里可以去看这篇文章https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw? 简单来说，对于Asset，无论是纹理、音乐还是预制体，在进入Unity以后，都需要转变成Object，即纹理转变为Texture2D或Sprite，音效文件转变为AudioClip，预制体变成了GameObject等等，这个由Asset(资源文件)转变为Object(对象)，从磁盘进入内存的过程，就是实例化。 这里补充说明一下实例化，例如如下代码 12GameObject prefab = Resources.Load(&quot;prefab1&quot;, typeof(GameObject)) as GameObject;GameObject instance = Instantiate(prefab) as GameObject; 第一个GameObject prefab的Resources.Load是“解释”你要加载的东西是个GameObject并且加载到内存中。 第二个GameObject instance是对prefab进行一个深度copy克隆到场景中然后从Instantiate的返回值中持有他的引用。 通俗意义上我们理解的实例化是指Instantiate生成某个实例，而Unity层面的实例化是指Asset转化为Object，一般情况下，我们使用上会两步一起用，Unity分开做的原因是因为在实际运用中，有些Asset加载以后不需要Instantiate，分成两个API以后会有更高的自由度。 区分 File GUIDs、Local IDs和Instance IDFile GUIDs Unity通过赋予每一个Asset一个Unique ID来区分每一个Asset。这个Unique ID就是File GUID，用于标识这个Asset的位置，这个GUID是由Unity根据内部算法自动生成的，并且存放在原始文件的同目录、同名但是后缀为.meta的文件里。 例如，如果一个资源引用了另一个外部资源，比如一个Prefab引用了其他脚本、纹理或Prefab等，则一定会标明引用资源文件的File GUID。 Local IDs（FileID） File GUID表示为文件和文件之间的关系，Local ID表示为文件内部各对象之间的关系，一个对象通常是由一个或多个对象构成，每个记录在&amp;符号后面的数字都是一个Local ID，每一个Local ID也表示着它将来也会被实例化成一个对象。File GUID确保了Asset在整个Unity工程里唯一，Local ID确保Objects在Asset里唯一，这样就可以通过二者的组合去快速找到对应的引用。 Instance ID 理论上通过File GUID和Local ID就可以找到对应的引用，但是运行时性能上还有问题，即GUID对比速度慢，也就是说运行时还是需要一个表现更好的系统，所以就有了Instance ID。 Unity中使用PersistentManager，用来把File GUIDs和Local IDs转化为一个简单的、Session唯一的整数。这些整数就是Instance ID。Instance Id很简单，就是一个递增的整数，每当有新对象需要在缓存里注册的时候（即读入一个File GUID和LocalID时），就会自动将File GUID和LocalID转换成一个Instance ID，通过Instance ID去定位资源就像直接解引用一个地址，效率比通过File GUID和LocalID快很多。 PersistentManager会维护Instance ID和File GUID 、Local ID的映射关系，定位Object源数据的位置以及维护内存中（如果有的话）Object的实例。只要系统解析到一个Instance ID，就能快速找到代表这个Instance ID的已加载的对象。如果Object没有被加载的话，File GUID 和Local ID也可以快速的定位到指定的Asset资源从而即时进行资源加载。 Asset 加载和InstaniateAsset 加载和Instaniate原理 一个Prefab从AssetBundle或者Resource里Load出来 里面可能包括：Gameobject transform mesh texture material shader script和各种其他Assets Instaniate一个Prefab，是一个对Assets进行Clone(复制)+引用结合的过程，GameObject transform 是Clone是新生成的。其他mesh / texture / material / shader 等，这其中些是纯引用的关系的，包括：Texture和TerrainData，还有引用和复制同时存在的，包括：Mesh/material /PhysicMaterial。引用的Asset对象不会被复制，只是一个简单的指针指向已经Load的Asset对象 提一下的是一个特殊的东西：Script Asset，看起来很奇怪，Unity里每个Script都是一个封闭的Class定义而已, 并没有写调用代码，光Class的定义脚本是不会工作的。其实Unity引擎就是那个调用代码，Clone一个script asset等于new一个class实例，实例才会完成工作。把他挂到Unity主线程的调用链里去，Class实例里的OnUpdate OnStart等才会被执行。多个物体挂同一个脚本，其实就是在多个物体上挂了那个脚本类的多个实例而已，这样就好理解了。在new class这个过程中，数据区是复制的，代码区是共享的，算是一种特殊的复制+引用关系。 你可以再Instaniate一个同样的Prefab, 还是这套mesh/texture/material/shader等等，这时候会有新的GameObject等，但是不会创建新的引用对象比如texture. 可以参照下图理解 Asset 加载方式 通俗意义上存在三种加载方式 静态引用：建一个public的变量，在Inspector里把prefab拉上去，用的时候instantiate Resource.Load: Load以后instantiate AssetBundle.Load: Load以后instantiate 这里进行了一波测试 12345678910111213141516171819202122232425262728IEnumerator OnTestClick()&#123; Resources.UnloadUnusedAssets();//清干净以免影响测试效果 float wait = 5f;//每步都等待5s以便于分析结果 yield return new WaitForSeconds(wait); GameObject go = Resources.Load(&quot;prefab1&quot;) as GameObject;//加载Prefab yield return new WaitForSeconds(wait); GameObject obj = Instantiate(go) as GameObject;//生成实例 yield return new WaitForSeconds(wait); Destroy(obj);//销毁实例 yield return new WaitForSeconds(wait); Resources.UnloadUnusedAssets();//卸载无用资源 yield return new WaitForSeconds(wait); go = null;//将prefab引用置为空以后卸载无用资源 Resources.UnloadUnusedAssets();&#125; 放到真机环境下测试以后 可以看到Load时候引用类型的Assert（即pic1）已经被加载到内存中，Instaniate时候只是Clone和对已经加载到内存中的Assert引用 什么时候才是UnusedAssets? 从上面例子中可以看到Destory一个Prefab实例以后，这时候Prefab已经没有被实际的物体引用了，但如果这时： Resources.UnloadUnusedAssets(); 内存并没有被释放，原因：Prefab还被这个变量go所引用这时候： go = null; Resources.UnloadUnusedAssets(); 这样才能真正释放Assets对象 所以：UnusedAssets不但要没有被实际物体引用，也要没有被生命周期内的变量所引用，才可以理解为 Unused(引用计数为0) 所以：如果用个全局变量保存Load的Assets，又没有显式的设为null，那在这个变量失效前是无论如何UnloadUnusedAssets也释放不了那些Assets的 可以再写下如下代码测试 1234567891011121314151617181920212223242526272829303132333435363738IEnumerator OnTestClick()&#123; Resources.UnloadUnusedAssets();//清干净以免影响测试效果 float wait = 5f;//每步都等待5s以便于分析结果 yield return new WaitForSeconds(wait); Texture tt = Resources.Load(&quot;pic1&quot;) as Texture;//加载贴图 yield return new WaitForSeconds(wait); GameObject go = Resources.Load(&quot;prefab1&quot;) as GameObject;//加载Prefab yield return new WaitForSeconds(wait); GameObject obj = Instantiate(go) as GameObject;//生成实例 yield return new WaitForSeconds(wait); Destroy(obj);//销毁实例 yield return new WaitForSeconds(wait); Resources.UnloadUnusedAssets();//卸载无用资源 yield return new WaitForSeconds(wait); go = null;//将prefab引用置为空以后卸载无用资源 Resources.UnloadUnusedAssets(); yield return new WaitForSeconds(wait); tt = null;//将texture引用置为空以后卸载无用资源 Resources.UnloadUnusedAssets();&#125; 这里可以确认prefab中加载的Assert pic1直接加载的pic1占有的是同一块内存，并且仅当go和tt都显示的置为null以后，才可以被UnloadUnusedAssets 举个例子帮助理解 你从Resources里Load了一个prefab并克隆之：obj = Instaniate(Resources.Load(“prefab1”)); 这个prefab比如是个npc 然后你不需要他的时候你用了：Destroy(obj);你以为就释放干净了 其实这时候只是释放了Clone对象，通过Load加载的所有引用、非引用Assets对象全都静静的躺在内存里。 这种情况应该在Destroy以后再Resources.UnloadUnusedAssets()才能把Assets清除， 当然如果你是go = Resources.Load(“prefab1”), obj = Instaniate(go); 必须先go = null以后再Resources.UnloadUnusedAssets()才能把Assets清除， 当然如果这个NPC也是要频繁创建，销毁的 那就应该让那些Assets呆在内存里以加速游戏体验。 总结 Resources.Load会把需要的所有Assets加载到内存中，当Instaniate时候会Clone和对已经加载到内存中的Assert引用，这些Assets只有在没有被实际物体引用，也没有被生命周期内的变量所引用，才可以理解为Unused，才能被Resources.UnloadUnusedAssets() 同理，静态引用的时候由于始终有一个生命周期的对象引用pic1，只要中途没有把这个变量显示的置为null，pic1会自始至终躺在内存中 至于AssetBundle.Load，可以把Resources.Load看作是从一个缺省打进程序包里的AssetBundle里加载资源，AssetBundle.load也是在load时候把Perfab的全部Assets加载到内存中","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"资源管理","slug":"技术/资源管理","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Unity","slug":"技术/资源管理/Unity","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/Unity/"}],"tags":[]},{"title":"Unity资源管理 (一) 内存理解","slug":"Unity资源管理-(一)-内存理解","date":"2021-05-14T09:02:46.000Z","updated":"2022-02-01T13:53:53.703Z","comments":true,"path":"Unity资源管理-(一)-内存理解/","link":"","permalink":"http://www.lidamo.cn/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%B8%80)-%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/","excerpt":"","text":"前言 在刚学习Unity资源管理的时候，经常把GC和Resources.UnloadUnusedAssets()搞混掉，查阅了相关资料做一下记录，在学习的过程中请留意文章的时间，笔者在学习的时候查阅了很多文章，发现众说纷纭，这是因为Unity版本也在不断更新，每个版本的处理可能都不一样，尽量结合网上的资料自己做测试，才能理解的更加深刻。 Unity内存分类 Unity引擎开发的移动游戏，内存有三部分：分别是程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。 程序代码 程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。 托管堆（Managed Heap) 托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。 本机堆（Native Heap) 本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。 优化程序代码优化 这部分的优化主要就是减少打包时的引用库，使一些不需要的库剥离。具体可以看上面的链接文章。 托管堆优化 “托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。这里的垃圾回收就是我们平时所说的GC。 GC定义 GC是Mono运行时的机制，而非Unity游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。明白了这一点，也就明白了GC不是用来处理引擎的Assets（贴图，音效，模型等等）的内存释放的，因为Unity引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆。 目前绝大部分Unity游戏逻辑代码所使用的语言为C#，C#代码所占用的内存又称为Mono内存，这是因为Unity是通过Mono来跨平台解析并运行C#代码的，在Android系统上，游戏的lib目录下存在的libmono.so文件，就是Mono在Android系统上的实现。C#代码通过Mono解析执行，所需要的内存自然也是由Mono来进行分配管理。 托管堆内容 托管堆中存储的是你在代码中申请的内存，即引用类型，一般包括：自定义的类，接口，委托，数组，字符串，Object，值类型包括几种基本数据类型（如int,float,bool等），结构体，枚举，空类型。 GC触发机制 Mono内存分为两部分，已用内存（used）和堆内存（heap），已用内存指的是Mono实际需要使用的内存，堆内存指的是Mono向操作系统申请的内存，两者的差值就是Mono的空闲内存。当Mono需要分配内存时，会先查看空闲内存是否足够，如果足够的话，直接在空闲内存中分配，否则Mono会进行一次GC以释放更多的空闲内存，如果GC之后仍然没有足够的空闲内存，则Mono会向操作系统申请内存，并扩充堆内存。 GC原理 托管资源的内存管理是靠引用计数进行的，只要保证对象不再被引用，即可在GC的时候将托管资源占用的内存释放。如:将指针变量置null，则该指针之前指向的对象（如果有）​的引用计数减1；指针变量的生命周期结束（临时变量所在的大括号之外、类成员变量所在的对象被释放等）时，指针指向的对象（如果有）的引用计数减1。注意：只要指针的生命周期未结束，会一直保持对对象的引用计数，包括数组、字典等中引用的元素。 GC步骤 GC的主要作用在于从已用内存中找出那些不再需要使用的内存，并进行释放。主要步骤如下： 1.停止所有需要mono内存分配的线程。 2.遍历所有已用内存，找到那些不再需要使用的内存，并进行标记。 3.释放被标记的内存到空闲内存。 4.重新开始被停止的线程。 除了空闲内存不足时Mono会自动调用GC外，也可以在代码中调用System.GC.Collect()手动进行GC，但是，GC本身是比较耗时的操作，而且由于GC会暂停那些需要mono内存分配的线程（C#代码创建的线程和主线程），因此无论是否在主线程中调用，GC都会导致游戏一定程度的卡顿，需要谨慎处理。 GC优化 因此为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity引擎的那些资源，其实说白了GC的优化也就是代码的优化。这里网上有比较多的文章会讲很多细节代码，包括字符串处理，foreach，减少拆装箱等等。 本机堆优化 当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。 应该减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。 注意事项 需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。 因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()。 和GC区分 Resources.UnloadAsset(Object) 用于卸载对应Object（Asset）， Resources.UnloadUnusedAssets()用于卸载 所有没有被引用以及实例化的Object（Asset），这些非托管资源中的Object用GC是没办法清理的。这里了解了内存种类以后应该很好理解。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。 拓展 切换场景时，Resources.UnloadUnusedAssets()，System.GC.Collect()这两个函数都是会被自动调用的。 总结 对于非托管资源，需要调用Resources.UnloadUnusedAssets()，对于托管资源，才用​System.GC.Collect()来释放。对于资源优化应该区分清楚资源类型，了解内存的分类。最后，更深入的学习资源管理，了解更多的优化细节还需要结合实际情况具体分析。 参考 https://blog.csdn.net/HarvestHarvest/article/details/107379535 http://www.onevcat.com/2012/11/memory-in-unity3d/","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"资源管理","slug":"技术/资源管理","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Unity","slug":"技术/资源管理/Unity","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/Unity/"}],"tags":[]},{"title":"UI管理-PureMVC","slug":"UI管理-PureMVC","date":"2021-05-10T11:34:48.000Z","updated":"2022-02-03T16:05:59.850Z","comments":true,"path":"UI管理-PureMVC/","link":"","permalink":"http://www.lidamo.cn/UI%E7%AE%A1%E7%90%86-PureMVC/","excerpt":"","text":"前言 最近负责项目UI框架部分的搭建，查阅了一些资料以后，借鉴了其他项目的一些想法，在这边整理一下，项目UI部分是用Lua写的，贴的相关代码也是Lua代码，由于是边学习边写的，命名规则是按项目标准命名的（成员变量前加m等） MVC和PureMVC 目标：将数据（Model），视图组件（View）和控制逻辑（Control）进行分离。让程序便于修改，更具有扩展性，灵活性，可重用性。高内聚，低耦合，一直是追求的目标。传统经典的MVC模型虽然将数据，视图组件和控制逻辑进行了分离，但耦合性还是比较高。 PureMVC在MVC基础上做了许多的改进，通过结合多个设计模式的应用，让耦合性变得更低，也变得更加的易用，在扩展性，灵活性，重用性方面也做得更好 设计模式单例模式 （Singleton） 在PureMVC中，Model,View,Controller是三个单例模式类，三者合称为核心层，实际上是Manager管理类，分别定义了字典用于保存引用 外观模式（Facade） 在开发的过程中，需要在Contoller中，获取View以及Model的对象，修改Mode，更新View，或是在View，需要获取Model，进行一些初始化或是修改的操作，在业务逻辑很多的情况下，Model, View, Controller之间的频繁的调用就会非常多，耦合性会变高，在PureMVC中，为Model、View、Controller类提供了外观类Façade，主要负责访问和通知 Model、View 和 Controller，即管理这三者。Façade统一对外提供这3者的接口，使用过程成只需要跟Façade打交道就行 观察者模式（Observer） 为了彻底解耦，避免直接的函数调用，PureMVC使用观察者模式（又称发布/订阅模式）的形式传递消息。在PureMVC中Mediator、Proxy、Command之间的通信，以通知形式实现松散耦合。Mediator、Proxy、Command都是通知者（发布者） 可以调用sendNotification发送消息；Mediator、Command同时也是观察者（订阅者）可以接收来自其它对象的通知。 这里先不用关心Mediator、Proxy、Command是什么，需要注意的是Mediator和Command既是通知者也是观察者，Proxy只是通知者 Proxy=&gt;Model ，Mediator=&gt;View ， Command=&gt;Controller 所有的通知者（发布者）都继承自Notifier类，故拥有发布通知的功能，而Notifier是使用Façade发布通知的 由外观模式可知façade保存了View的引用，View在观察者模式中充当着管理者的角色，保存着所有消息/主题、观察者的映射。当Mediator/Command/Proxy发布通知时，façade调用View的notifyObservers()方法，遍历保存的映射关系，从而通知所有满足条件的观察者 123456function Notifier:SendNotification(notificationName, body, type) local facade = self:GetFacade() if facade ~= nil then facade:SendNotification(notificationName, body, type) endend 123function Facade:SendNotification(notificationName, body, type) self:NotifyObservers(Notification.New(notificationName, body, type))end 12345function Facade:NotifyObservers(notification) if self.mView ~= nil then self.mView:NotifyObservers(notification) endend Command 中调用 Controller的 RegisterCommand 注册通知 通过复写Command的Execute方法实现回调 123456function Controller:RegisterCommand(notificationName, commandClassRef) if(self.mCommandMap[notificationName] == nil) then self.mView:RegisterObserver(notificationName, Observer.New(self.ExecuteCommand, self)); end self.mCommandMap[notificationName] = commandClassRefend 123456789function Controller:ExecuteCommand(note) local commandClassRef = self.mCommandMap[note:GetName()] if(commandClassRef == nil) then return end local commandInstance = commandClassRef.New() commandInstance:InitializeNotifier(self.mMultitonKey) commandInstance:Execute(note)end Mediator 中调用 View 的 RegisterMediator 通过复写Mediator的ListNotificationInterests方法实现回调 123456789101112131415function View:RegisterMediator(mediator) if self.mMediatorMap[mediator:GetMediatorName()] ~= nil then return end mediator:InitializeNotifier(self.mMultitonKey) self.mMediatorMap[mediator:GetMediatorName()] = mediator local interests = mediator:ListNotificationInterests() if #interests &gt; 0 then local observer = Observer.New(mediator.handleNotification, mediator) for _, i in pairs(interests) do self:RegisterObserver(i, observer) end end mediator:OnRegister()end 中介者模式（Mediator） 在PureMVC中，Mediator帮助我们创建或重用已有UI组件，而UI不用知道PureMVC框架相关的东西，UI仅用于显示数据、接收用户输入。Mediator是UI组件与框架的中介，它负责将来自PureMVC框架的消息转接到UI，并将UI的消息转发广播到PureMVC框架。这样通过Mediator解耦了UI与PureMVC框架元素（Proxy、Mediator、Command），而不用互相引用。 一个Mediator只与一个UI绑定（1对1），Mediator构造函数参数传递与之绑定的UI。通过façade的registerMediator方法注册Mediator，以接收PureMVC框架的通知 Mediator接收PureMVC传来的Notification，调用UI函数 接收UI派发的事件，转发Notification传回PureMVC框架 例如 当点击领取邮件按钮，EmailUI发送消息给EmailMediator传给PureMVC，（中间可能涉及服务器交互），之后PureMVC，需要更新背包内容就发送消息给BagMediator，BagMediator接收事件以后更新BagUI，Bag功能和Email功能并没有影响 代理模式（Proxy） 在PureMVC中，Proxy帮助我们以更易于重用、修改对应用程序影响最小的方式暴露数据结构、接口给应用程序。Proxy可能只是简单的管理本地数据对象，以同步方式获取或修改数据；也可能是远程服务器数据，以异步方式操作数据，服务器数据返回之后以Notification方式告诉应用程序。 简单来说，Proxy对数据逻辑进行包装，只对外公布操作数据对象的API，例如EmailProxy负责接收来自服务器的邮件内容，当邮件更新时，EmailUI并不需要关心邮件数据是什么形式发来的，当EmailUI需要展示邮件内容，只需要调取EmailProxy公布的API（例如EmaliProxy.GetEmailList）即可，反之，当发送邮件时，EmailUI也不需要关注怎么发送，以什么样数据格式发给服务器，一切逻辑都由EmailProxy处理，这样极大程度实现了对一些处理逻辑的封装，降低了耦合。 命令模式（Command） 命令模式是对命令的封装，把发出命令的责任和执行命令的责任分割开，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 在PureMVC中，命令用来检索、操作Proxy，或者与Mediator通信，或者执行其它命令。 例如:EmailMediator 接收到来自UI的sendEmail的消息，EmailMediator把消息传到SendEmailCommand， SendEmailCommand持有EmailProxy的引用，调用EmailProxy的SendEmail接口发送消息 总体结构 实际应用框架入口 123456789101112131415161718192021222324local GameFacade = BaseClass(&quot;GameFade&quot;, Facade)local base = Facadelocal STARTUP = &quot;startUp&quot;GameFacade.KEY = &quot;GameFacade&quot;function GameFacade:InitializeController() base.InitializeController(self) self:RegisterCommand(STARTUP, StartUpCommand)endfunction GameFacade:StartUp() self:SendNotification(STARTUP); --PureMVC初始化完成，注销STARTUP命令 self:RemoveCommand(STARTUP);endfunction GameFacade:GetInstance() if rawget(GameFacade, &quot;Instance&quot;) == nil then rawset(GameFacade, &quot;Instance&quot;, GameFacade.New(GameFacade.KEY)) end return GameFacade.Instanceendreturn GameFacade 1234567local StartUpCommand = BaseClass(&#x27;StartUpCommand&#x27;, MacroCommand)function StartUpCommand:InitializeMacroCommand() print(&quot;start&quot;)endreturn StartUpCommand 一般是继承Facade类注册 开始事件，这里是 STARTUP， 然后继承Command 构造 StartUpCommand 这里可以参考网上一些完整样例。 1GameFacade:GetInstance():StartUp() 通过StartUp开启 单模块通信 红色为直接调用，绿色为事件通信 Proxy只发送消息不接受消息，是通过Command直接调用的，原因是设计时Proxy要负责和服务器交互，再监听其他事件过于繁琐 多模块通信 黄色线也是可能存在的事件，因为观察者模式不需要关注消息的来源，只要订阅了相关消息就可以触发 例如EmailProxy接收到服务器消息更新时也需要更新BagUI就可以发送消息给BagMediator 或者EmailUI也可以购买物品可以发送消息给 EmailMediator转发给BagCommand调用BagProxy 过于强调解耦 因为都是消息机制，整个流程很长，而且Proxy中对数据进行操作后，发送Notification时，可能需要携带修改后的数据（可能是来自服务器的数据）。这个过程不仅通过次数多，而且带反馈数据的消息增加通信负担。另一方面要调试这个过程，我们只能在编译的时候找出一步一步的通信流程，才能跟踪调试。 修改 因为游戏项目本身不需要过于解耦，UI部分不希望出现类爆炸的情况，在此基础上进行了一些修改 UI 和 Mediator 结合 Mediator和UI之间的通信有点繁琐，可以让UI持有Mediator，这样UI可以通过持有的UIMediator 与PureMVC交互，并且接收到消息时，也可以直接调用自身UI函数，不再需要Mediator持有UI调用 1234567function UIMediator:ListNotificationInterests() if(self.mViewComponent ~= nil) then local result = self.mViewComponent:ListNotificationInterests() return result end return &#123;&#125;end 12345function UIMediator:HandleNotification(notification) if(self.mViewComponent ~= nil) then return self.mViewComponent:HandleNotification(notification) endend UI直接绑定一个公用的UIMediator通过UIMeditaor发送消息和PureMVC交互 Command中介多余 数据相关部分已经被Proxy封装好，可以考虑不再需要通过Command转发，可以直接由UI（UIMediator）调用Proxy的接口以减少类的数量，Proxy之间的调用可以通过加一个全局注册事件触发 修改后 交互过程UI 通过调用自身的成员变量UIMediator发送消息 并通过在UIMediator中注册的消息响应来自来自外部的消息 UI不再经过Command调用Proxy 而是直接调用Proxy 修改总结 对于一个小功能，每个功能对应的文件应该为一个UI和一个Proxy 对于一个大功能，每个功能对应的文件应该为多个UI和一个Proxy 因为Proxy没有接收消息的接口，一般来说Proxy之间不会有互相调用的情况，但是可能会有如：背包收到服务器更新消息以后先更新背包后更新其他例如邮件等功能数据的情况，可考虑通过外部的Event添加监听 思考 解耦的同时将使项目修改的复杂程度提高，某些解耦的办法还会增加代码量、降低执行效率。PureMVC是一个强解耦的框架，其效率本身不是很高，函数调用层次较深，而有时根本不清楚消息发到了哪里 因为需要外界触发，在游戏上一般只适合用来做UI部分 参考 https://blog.csdn.net/wangjiangrong/article/details/107686954 [https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html](https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html) [https://blog.csdn.net/qq_29579137/article/details/73692842](https://blog.csdn.net/qq_29579137/article/details/73692842) 挪用了其他文章中的一些流程图","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"UI管理","slug":"技术/UI管理","permalink":"http://www.lidamo.cn/categories/%E6%8A%80%E6%9C%AF/UI%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.lidamo.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"lua","slug":"lua","permalink":"http://www.lidamo.cn/tags/lua/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.lidamo.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"hexo 指令","slug":"hexo-指令","date":"2021-05-10T11:34:48.000Z","updated":"2022-01-27T15:20:18.166Z","comments":true,"path":"hexo-指令/","link":"","permalink":"http://www.lidamo.cn/hexo-%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post(创建文章)1$ hexo new &quot;My New Post&quot; More info: Writing Run server(启动服务器)1$ hexo server More info: Server Generate static files(生成文件)1$ hexo generate More info: Generating Deploy to remote sites(传送远端)1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.lidamo.cn/categories/hexo/"}],"tags":[]}]}