<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lua和PureMVC</title>
    <url>/2021/05/10/Lua%E5%92%8CPureMVC/</url>
    <content><![CDATA[<p>参考 <a href="https://blog.csdn.net/wangjiangrong/article/details/107686954">https://blog.csdn.net/wangjiangrong/article/details/107686954</a><br>        <a href="https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html">https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html</a><br>        <a href="https://blog.csdn.net/qq_29579137/article/details/73692842">https://blog.csdn.net/qq_29579137/article/details/73692842</a></p>
<p>挪用了其他文章中的一些流程图</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近负责项目UI框架部分的搭建，查阅了一些资料以后，借鉴了其他项目的一些想法，在这边整理一下，项目UI部分是用Lua写的，贴的相关代码也是Lua代码，由于是边学习边写的，命名规则是按项目标准命名的（成员变量前加m等）</p>
<h1 id="MVC和PureMVC"><a href="#MVC和PureMVC" class="headerlink" title="MVC和PureMVC"></a>MVC和PureMVC</h1><p>目标：将数据（Model），视图组件（View）和控制逻辑（Control）进行分离。让程序便于修改，更具有扩展性，灵活性，可重用性。高内聚，低耦合，一直是追求的目标。传统经典的MVC模型虽然将数据，视图组件和控制逻辑进行了分离，但耦合性还是比较高。</p>
<p>PureMVC在MVC基础上做了许多的改进，通过结合多个设计模式的应用，让耦合性变得更低，也变得更加的易用，在扩展性，灵活性，重用性方面也做得更好</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-（Singleton）"><a href="#单例模式-（Singleton）" class="headerlink" title="单例模式 （Singleton）"></a>单例模式 （Singleton）</h2><p> 在PureMVC中，Model,View,Controller是三个单例模式类，三者合称为核心层，实际上是Manager管理类，分别定义了字典用于保存引用</p>
<h2 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h2><p>  在开发的过程中，需要在Contoller中，获取View以及Model的对象，修改Mode，更新View，或是在View，需要获取Model，进行一些初始化或是修改的操作，在业务逻辑很多的情况下，Model, View, Controller之间的频繁的调用就会非常多，耦合性会变高，在PureMVC中，为Model、View、Controller类提供了外观类Façade，主要负责访问和通知 Model、View 和 Controller，即管理这三者。Façade统一对外提供这3者的接口，使用过程成只需要跟Façade打交道就行</p>
<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>为了彻底解耦，避免直接的函数调用，PureMVC使用观察者模式（又称发布/订阅模式）的形式传递消息。在PureMVC中Mediator、Proxy、Command之间的通信，以通知形式实现松散耦合。Mediator、Proxy、Command都是通知者（发布者） 可以调用sendNotification发送消息；Mediator、Command同时也是观察者（订阅者）可以接收来自其它对象的通知。</p>
<p>这里先不用关心Mediator、Proxy、Command是什么，需要注意的是Mediator和Command既是通知者也是观察者，Proxy只是通知者<br>Proxy=&gt;Model            ，Mediator=&gt;View        ， Command=&gt;Controller</p>
<p>所有的通知者（发布者）都继承自Notifier类，故拥有发布通知的功能，而Notifier是使用Façade发布通知的<br>由外观模式可知façade保存了View的引用，View在观察者模式中充当着管理者的角色，保存着所有消息/主题、观察者的映射。当Mediator/Command/Proxy发布通知时，façade调用View的notifyObservers()方法，遍历保存的映射关系，从而通知所有满足条件的观察者</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Notifier:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="keyword">local</span> facade = <span class="built_in">self</span>:GetFacade()</span><br><span class="line">    <span class="keyword">if</span> facade ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        facade:SendNotification(notificationName, body, <span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="built_in">self</span>:NotifyObservers(Notification.New(notificationName, body, <span class="built_in">type</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:NotifyObservers</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mView ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:NotifyObservers(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Command 中调用 Controller的 RegisterCommand 注册通知<br>通过复写Command的Execute方法实现回调</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:RegisterCommand</span><span class="params">(notificationName, commandClassRef)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mCommandMap[notificationName] == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:RegisterObserver(notificationName, Observer.New(<span class="built_in">self</span>.ExecuteCommand, <span class="built_in">self</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">self</span>.mCommandMap[notificationName] = commandClassRef</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:ExecuteCommand</span><span class="params">(note)</span></span></span><br><span class="line">    <span class="keyword">local</span> commandClassRef = <span class="built_in">self</span>.mCommandMap[note:GetName()]</span><br><span class="line">    <span class="keyword">if</span>(commandClassRef == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> commandInstance = commandClassRef.New()</span><br><span class="line">    commandInstance:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    commandInstance:Execute(note)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Mediator 中调用 View 的 RegisterMediator<br>通过复写Mediator的ListNotificationInterests方法实现回调</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View:RegisterMediator</span><span class="params">(mediator)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] = mediator</span><br><span class="line">    <span class="keyword">local</span> interests = mediator:ListNotificationInterests()</span><br><span class="line">    <span class="keyword">if</span> #interests &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> observer = Observer.New(mediator.handleNotification, mediator)</span><br><span class="line">        <span class="keyword">for</span> _, i <span class="keyword">in</span> <span class="built_in">pairs</span>(interests) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">self</span>:RegisterObserver(i, observer)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:OnRegister()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img1.png" alt="在这里插入图片描述"></p>
<h2 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h2><p>在PureMVC中，Mediator帮助我们创建或重用已有UI组件，而UI不用知道PureMVC框架相关的东西，UI仅用于显示数据、接收用户输入。Mediator是UI组件与框架的中介，它负责将来自PureMVC框架的消息转接到UI，并将UI的消息转发广播到PureMVC框架。这样通过Mediator解耦了UI与PureMVC框架元素（Proxy、Mediator、Command），而不用互相引用。</p>
<p>一个Mediator只与一个UI绑定（1对1），Mediator构造函数参数传递与之绑定的UI。通过façade的registerMediator方法注册Mediator，以接收PureMVC框架的通知</p>
<p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img2.png" alt="在这里插入图片描述"></p>
<p>Mediator接收PureMVC传来的Notification，调用UI函数<br>接收UI派发的事件，转发Notification传回PureMVC框架</p>
<p>例如 当点击领取邮件按钮，EmailUI发送消息给EmailMediator传给PureMVC，（中间可能涉及服务器交互），之后PureMVC，需要更新背包内容就发送消息给BagMediator，BagMediator接收事件以后更新BagUI，Bag功能和Email功能并没有影响</p>
<h2 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h2><p>在PureMVC中，Proxy帮助我们以更易于重用、修改对应用程序影响最小的方式暴露数据结构、接口给应用程序。Proxy可能只是简单的管理本地数据对象，以同步方式获取或修改数据；也可能是远程服务器数据，以异步方式操作数据，服务器数据返回之后以Notification方式告诉应用程序。</p>
<p>简单来说，Proxy对数据逻辑进行包装，只对外公布操作数据对象的API，例如EmailProxy负责接收来自服务器的邮件内容，当邮件更新时，EmailUI并不需要关心邮件数据是什么形式发来的，当EmailUI需要展示邮件内容，只需要调取EmailProxy公布的API（例如EmaliProxy.GetEmailList）即可，反之，当发送邮件时，EmailUI也不需要关注怎么发送，以什么样数据格式发给服务器，一切逻辑都由EmailProxy处理，这样极大程度实现了对一些处理逻辑的封装，降低了耦合。</p>
<h2 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h2><p>命令模式是对命令的封装，把发出命令的责任和执行命令的责任分割开，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>
<p>在PureMVC中，命令用来检索、操作Proxy，或者与Mediator通信，或者执行其它命令。<br><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img3.png" alt="在这里插入图片描述"></p>
<p>例如:EmailMediator 接收到来自UI的sendEmail的消息，EmailMediator把消息传到SendEmailCommand， SendEmailCommand持有EmailProxy的引用，调用EmailProxy的SendEmail接口发送消息</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img4.png" alt="在这里插入图片描述"></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> GameFacade = BaseClass(<span class="string">&quot;GameFade&quot;</span>, Facade)</span><br><span class="line"><span class="keyword">local</span> base = Facade</span><br><span class="line"><span class="keyword">local</span> STARTUP = <span class="string">&quot;startUp&quot;</span></span><br><span class="line">GameFacade.KEY = <span class="string">&quot;GameFacade&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:InitializeController</span><span class="params">()</span></span></span><br><span class="line">    base.InitializeController(<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>:RegisterCommand(STARTUP, StartUpCommand)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:StartUp</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>:SendNotification(STARTUP);</span><br><span class="line">    <span class="comment">--PureMVC初始化完成，注销STARTUP命令</span></span><br><span class="line">    <span class="built_in">self</span>:RemoveCommand(STARTUP);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:GetInstance</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rawget</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rawset</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>, GameFacade.New(GameFacade.KEY))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> GameFacade.Instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GameFacade</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> StartUpCommand = BaseClass(<span class="string">&#x27;StartUpCommand&#x27;</span>, MacroCommand)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StartUpCommand:InitializeMacroCommand</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> StartUpCommand</span><br></pre></td></tr></table></figure>

<p>一般是继承Facade类注册 开始事件，这里是 STARTUP， 然后继承Command 构造 StartUpCommand<br>这里可以参考网上一些完整样例。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">GameFacade:GetInstance():StartUp()</span><br></pre></td></tr></table></figure>
<p>通过StartUp开启</p>
<h2 id="单模块通信"><a href="#单模块通信" class="headerlink" title="单模块通信"></a>单模块通信</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img5.png" alt="在这里插入图片描述"></p>
<p>红色为直接调用，绿色为事件通信</p>
<p>Proxy只发送消息不接受消息，是通过Command直接调用的，原因是设计时Proxy要负责和服务器交互，再监听其他事件过于繁琐</p>
<h2 id="多模块通信"><a href="#多模块通信" class="headerlink" title="多模块通信"></a>多模块通信</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img6.png" alt="在这里插入图片描述"></p>
<p>黄色线也是可能存在的事件，因为观察者模式不需要关注消息的来源，只要订阅了相关消息就可以触发</p>
<p>例如EmailProxy接收到服务器消息更新时也需要更新BagUI就可以发送消息给BagMediator</p>
<p>或者EmailUI也可以购买物品可以发送消息给<br>EmailMediator转发给BagCommand调用BagProxy</p>
<h2 id="过于强调解耦"><a href="#过于强调解耦" class="headerlink" title="过于强调解耦"></a>过于强调解耦</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img7.png" alt="在这里插入图片描述"></p>
<p>因为都是消息机制，整个流程很长，而且Proxy中对数据进行操作后，发送Notification时，可能需要携带修改后的数据（可能是来自服务器的数据）。这个过程不仅通过次数多，而且带反馈数据的消息增加通信负担。另一方面要调试这个过程，我们只能在编译的时候找出一步一步的通信流程，才能跟踪调试。</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>因为游戏项目本身不需要过于解耦，UI部分不希望出现类爆炸的情况，在此基础上进行了一些修改</p>
<h2 id="UI-和-Mediator-结合"><a href="#UI-和-Mediator-结合" class="headerlink" title="UI 和 Mediator 结合"></a>UI 和 Mediator 结合</h2><p>Mediator和UI之间的通信有点繁琐，可以让UI持有Mediator，这样UI可以通过持有的UIMediator 与PureMVC交互，并且接收到消息时，也可以直接调用自身UI函数，不再需要Mediator持有UI调用</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:ListNotificationInterests</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> result = <span class="built_in">self</span>.mViewComponent:ListNotificationInterests()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:HandleNotification</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>.mViewComponent:HandleNotification(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>UI直接绑定一个公用的UIMediator通过UIMeditaor发送消息和PureMVC交互</p>
<h2 id="Command中介多余"><a href="#Command中介多余" class="headerlink" title="Command中介多余"></a>Command中介多余</h2><p>数据相关部分已经被Proxy封装好，可以考虑不再需要通过Command转发，可以直接由UI（UIMediator）调用Proxy的接口以减少类的数量，Proxy之间的调用可以通过加一个全局注册事件触发</p>
<h2 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img8.png" alt="在这里插入图片描述"></p>
<p>交互过程UI 通过调用自身的成员变量UIMediator发送消息<br>并通过在UIMediator中注册的消息响应来自来自外部的消息<br>UI不再经过Command调用Proxy 而是直接调用Proxy</p>
<h2 id="修改总结"><a href="#修改总结" class="headerlink" title="修改总结"></a>修改总结</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img9.png" alt="在这里插入图片描述"></p>
<ul>
<li>对于一个小功能，每个功能对应的文件应该为一个UI和一个Proxy</li>
<li>对于一个大功能，每个功能对应的文件应该为多个UI和一个Proxy  </li>
<li>因为Proxy没有接收消息的接口，一般来说Proxy之间不会有互相调用的情况，但是可能会有如：背包收到服务器更新消息以后先更新背包后更新其他例如邮件等功能数据的情况，可考虑通过外部的Event添加监听<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1></li>
<li>解耦的同时将使项目修改的复杂程度提高，某些解耦的办法还会增加代码量、降低执行效率。PureMVC是一个强解耦的框架，其效率本身不是很高，函数调用层次较深，而有时根本不清楚消息发到了哪里</li>
<li>因为需要外界触发，在游戏上一般只适合用来做UI部分</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理（一）内存理解</title>
    <url>/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在刚学习Unity资源管理的时候，经常把GC和Resources.UnloadUnusedAssets()搞混掉，查阅了相关资料做一下记录，在学习的过程中请留意文章的时间，笔者在学习的时候查阅了很多文章，发现众说纷纭，这是因为Unity版本也在不断更新，每个版本的处理可能都不一样，尽量结合网上的资料自己做测试，才能理解的更加深刻。</p>
<h1 id="Unity内存分类"><a href="#Unity内存分类" class="headerlink" title="Unity内存分类"></a>Unity内存分类</h1><p>Unity引擎开发的移动游戏，内存有三部分：分别是程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。</p>
<h2 id="托管堆（Managed-Heap"><a href="#托管堆（Managed-Heap" class="headerlink" title="托管堆（Managed Heap)"></a>托管堆（Managed Heap)</h2><p>托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。</p>
<h2 id="本机堆（Native-Heap"><a href="#本机堆（Native-Heap" class="headerlink" title="本机堆（Native Heap)"></a>本机堆（Native Heap)</h2><p>本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。<br><img src="/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/img1.png" alt="在这里插入图片描述"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="程序代码优化"><a href="#程序代码优化" class="headerlink" title="程序代码优化"></a>程序代码优化</h2><p>这部分的优化主要就是减少打包时的引用库，使一些不需要的库剥离。具体可以看上面的链接文章。</p>
<h2 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h2><p>“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。这里的垃圾回收就是我们平时所说的GC。</p>
<h3 id="GC定义"><a href="#GC定义" class="headerlink" title="GC定义"></a>GC定义</h3><p>GC是Mono运行时的机制，而非Unity游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。明白了这一点，也就明白了GC不是用来处理引擎的Assets（贴图，音效，模型等等）的内存释放的，因为Unity引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆。<br>目前绝大部分Unity游戏逻辑代码所使用的语言为C#，C#代码所占用的内存又称为Mono内存，这是因为Unity是通过Mono来跨平台解析并运行C#代码的，在Android系统上，游戏的lib目录下存在的libmono.so文件，就是Mono在Android系统上的实现。C#代码通过Mono解析执行，所需要的内存自然也是由Mono来进行分配管理。</p>
<h3 id="托管堆内容"><a href="#托管堆内容" class="headerlink" title="托管堆内容"></a>托管堆内容</h3><p>托管堆中存储的是你在代码中申请的内存，即引用类型，一般包括：自定义的类，接口，委托，数组，字符串，Object，值类型包括几种基本数据类型（如int,float,bool等），结构体，枚举，空类型。</p>
<h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><p>Mono内存分为两部分，已用内存（used）和堆内存（heap），已用内存指的是Mono实际需要使用的内存，堆内存指的是Mono向操作系统申请的内存，两者的差值就是Mono的空闲内存。当Mono需要分配内存时，会先查看空闲内存是否足够，如果足够的话，直接在空闲内存中分配，否则Mono会进行一次GC以释放更多的空闲内存，如果GC之后仍然没有足够的空闲内存，则Mono会向操作系统申请内存，并扩充堆内存。</p>
<h3 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h3><p>托管资源的内存管理是靠引用计数进行的，只要保证对象不再被引用，即可在GC的时候将托管资源占用的内存释放。如:将指针变量置null，则该指针之前指向的对象（如果有）​的引用计数减1；指针变量的生命周期结束（临时变量所在的大括号之外、类成员变量所在的对象被释放等）时，指针指向的对象（如果有）的引用计数减1。注意：只要指针的生命周期未结束，会一直保持对对象的引用计数，包括数组、字典等中引用的元素。</p>
<h3 id="GC步骤"><a href="#GC步骤" class="headerlink" title="GC步骤"></a>GC步骤</h3><p>GC的主要作用在于从已用内存中找出那些不再需要使用的内存，并进行释放。主要步骤如下：<br>1.停止所有需要mono内存分配的线程。<br>2.遍历所有已用内存，找到那些不再需要使用的内存，并进行标记。<br>3.释放被标记的内存到空闲内存。<br>4.重新开始被停止的线程。<br>除了空闲内存不足时Mono会自动调用GC外，也可以在代码中调用System.GC.Collect()手动进行GC，但是，GC本身是比较耗时的操作，而且由于GC会暂停那些需要mono内存分配的线程（C#代码创建的线程和主线程），因此无论是否在主线程中调用，GC都会导致游戏一定程度的卡顿，需要谨慎处理。</p>
<h3 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h3><p>因此为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity引擎的那些资源，其实说白了GC的优化也就是代码的优化。这里网上有比较多的文章会讲很多细节代码，包括字符串处理，foreach，减少拆装箱等等。</p>
<h2 id="本机堆优化"><a href="#本机堆优化" class="headerlink" title="本机堆优化"></a>本机堆优化</h2><p>当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。<br>应该减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。<br>因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()。</p>
<h3 id="和GC区分"><a href="#和GC区分" class="headerlink" title="和GC区分"></a>和GC区分</h3><p>Resources.UnloadAsset(Object) 用于卸载对应Object（Asset）， Resources.UnloadUnusedAssets()用于卸载<br>所有没有被引用以及实例化的Object（Asset），这些非托管资源中的Object用GC是没办法清理的。这里了解了内存种类以后应该很好理解。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>切换场景时，Resources.UnloadUnusedAssets()，System.GC.Collect()这两个函数都是会被自动调用的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于非托管资源，需要调用Resources.UnloadUnusedAssets()，对于托管资源，才用​System.GC.Collect()来释放。对于资源优化应该区分清楚资源类型，了解内存的分类。最后，更深入的学习资源管理，了解更多的优化细节还需要结合实际情况具体分析。</p>
<p>参考 <a href="https://blog.csdn.net/HarvestHarvest/article/details/107379535">https://blog.csdn.net/HarvestHarvest/article/details/107379535</a><br><a href="http://www.onevcat.com/2012/11/memory-in-unity3d/">http://www.onevcat.com/2012/11/memory-in-unity3d/</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理（二）Asset</title>
    <url>/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89Asset/</url>
    <content><![CDATA[<h1 id="Asset-和-Object"><a href="#Asset-和-Object" class="headerlink" title="Asset 和 Object"></a>Asset 和 Object</h1><h2 id="Asset（资源文件）"><a href="#Asset（资源文件）" class="headerlink" title="Asset（资源文件）"></a>Asset（资源文件）</h2><p>关于Asset，网上已经有很多解释了，可以去看<a href="https://zhuanlan.zhihu.com/p/96709802">https://zhuanlan.zhihu.com/p/96709802</a></p>
<p>简单来说，Asset是位于Assets目录下，可以在Unity的Projects窗口里看到的单个文件。这些就是平常项目中用到的资源文件，例如纹理，音效文件，预制体等等。</p>
<h2 id="Object-（对象）"><a href="#Object-（对象）" class="headerlink" title="Object （对象）"></a>Object （对象）</h2><p>Object是指从UnityEngine.Object继承的对象，是一个可以序列化的数据，是用来描述一个特定的资源的实例。例如Mesh, Sprite, AudioClip or AnimationClip等等。</p>
<h2 id="Asset和Object"><a href="#Asset和Object" class="headerlink" title="Asset和Object"></a>Asset和Object</h2><p>刚学习时，会把Asset和Object搞混，这里可以去看这篇文章<a href="https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw">https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw?</a><br>简单来说，对于Asset，无论是纹理、音乐还是预制体，在进入Unity以后，都需要转变成Object，即纹理转变为Texture2D或Sprite，音效文件转变为AudioClip，预制体变成了GameObject等等，这个由Asset(资源文件)转变为Object(对象)，从磁盘进入内存的过程，就是实例化。<br>这里补充说明一下实例化，例如如下代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameObject prefab = Resources.Load(<span class="string">&quot;prefab1&quot;</span>, <span class="keyword">typeof</span>(GameObject)) <span class="keyword">as</span> GameObject;</span><br><span class="line">GameObject instance = Instantiate(prefab) <span class="keyword">as</span> GameObject;</span><br></pre></td></tr></table></figure>
<p>第一个GameObject prefab的Resources.Load是“解释”你要加载的东西是个GameObject并且加载到内存中。<br>第二个GameObject instance是对prefab进行一个深度copy克隆到场景中然后从Instantiate的返回值中持有他的引用。<br>通俗意义上我们理解的实例化是指Instantiate生成某个实例，而Unity层面的实例化是指Asset转化为Object，一般情况下，我们使用上会两步一起用，Unity分开做的原因是因为在实际运用中，有些Asset加载以后不需要Instantiate，分成两个API以后会有更高的自由度。</p>
<h2 id="区分-File-GUIDs、Local-IDs和Instance-ID"><a href="#区分-File-GUIDs、Local-IDs和Instance-ID" class="headerlink" title="区分 File GUIDs、Local IDs和Instance ID"></a>区分 File GUIDs、Local IDs和Instance ID</h2><h3 id="File-GUIDs"><a href="#File-GUIDs" class="headerlink" title="File GUIDs"></a>File GUIDs</h3><p>Unity通过赋予每一个Asset一个Unique ID来区分每一个Asset。这个Unique ID就是File GUID，用于标识这个Asset的位置，这个GUID是由Unity根据内部算法自动生成的，并且存放在原始文件的同目录、同名但是后缀为.meta的文件里。<br>例如，如果一个资源引用了另一个外部资源，比如一个Prefab引用了其他脚本、纹理或Prefab等，则一定会标明引用资源文件的File GUID。</p>
<h3 id="Local-IDs（FileID）"><a href="#Local-IDs（FileID）" class="headerlink" title="Local IDs（FileID）"></a>Local IDs（FileID）</h3><p>File GUID表示为文件和文件之间的关系，Local ID表示为文件内部各对象之间的关系，一个对象通常是由一个或多个对象构成，每个记录在&amp;符号后面的数字都是一个Local ID，每一个Local ID也表示着它将来也会被实例化成一个对象。File GUID确保了Asset在整个Unity工程里唯一，Local ID确保Objects在Asset里唯一，这样就可以通过二者的组合去快速找到对应的引用。</p>
<h3 id="Instance-ID"><a href="#Instance-ID" class="headerlink" title="Instance ID"></a>Instance ID</h3><p>理论上通过File GUID和Local ID就可以找到对应的引用，但是运行时性能上还有问题，即GUID对比速度慢，也就是说运行时还是需要一个表现更好的系统，所以就有了Instance ID。<br>Unity中使用PersistentManager，用来把File GUIDs和Local IDs转化为一个简单的、Session唯一的整数。这些整数就是Instance ID。Instance Id很简单，就是一个递增的整数，每当有新对象需要在缓存里注册的时候（即读入一个File GUID和LocalID时），就会自动将File GUID和LocalID转换成一个Instance ID，通过Instance ID去定位资源就像直接解引用一个地址，效率比通过File GUID和LocalID快很多。<br>PersistentManager会维护Instance ID和File GUID 、Local ID的映射关系，定位Object源数据的位置以及维护内存中（如果有的话）Object的实例。只要系统解析到一个Instance ID，就能快速找到代表这个Instance ID的已加载的对象。如果Object没有被加载的话，File GUID 和Local ID也可以快速的定位到指定的Asset资源从而即时进行资源加载。</p>
<h1 id="Asset-加载和Instaniate"><a href="#Asset-加载和Instaniate" class="headerlink" title="Asset 加载和Instaniate"></a>Asset 加载和Instaniate</h1><h2 id="Asset-加载和Instaniate原理"><a href="#Asset-加载和Instaniate原理" class="headerlink" title="Asset 加载和Instaniate原理"></a>Asset 加载和Instaniate原理</h2><p>一个Prefab从AssetBundle或者Resource里Load出来 里面可能包括：Gameobject transform mesh texture material shader script和各种其他Assets<br>Instaniate一个Prefab，是一个对Assets进行<strong>Clone(复制)+引用</strong>结合的过程，GameObject transform 是Clone是新生成的。其他mesh / texture / material / shader 等，这其中些是纯引用的关系的，包括：Texture和TerrainData，还有引用和复制同时存在的，包括：Mesh/material /PhysicMaterial。引用的Asset对象不会被复制，只是一个简单的指针指向已经Load的Asset对象<br>提一下的是一个特殊的东西：Script Asset，看起来很奇怪，Unity里每个Script都是一个封闭的Class定义而已, 并没有写调用代码，光Class的定义脚本是不会工作的。其实Unity引擎就是那个调用代码，Clone一个script asset等于new一个class实例，实例才会完成工作。把他挂到Unity主线程的调用链里去，Class实例里的OnUpdate OnStart等才会被执行。多个物体挂同一个脚本，其实就是在多个物体上挂了那个脚本类的多个实例而已，这样就好理解了。在new class这个过程中，数据区是复制的，代码区是共享的，算是一种特殊的复制+引用关系。<br>你可以再Instaniate一个同样的Prefab, 还是这套mesh/texture/material/shader等等，这时候会有新的GameObject等，但是不会创建新的引用对象比如texture.<br>可以参照下图理解<br><img src="/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89Asset/img1.png" alt="在这里插入图片描述"></p>
<h2 id="Asset-加载方式"><a href="#Asset-加载方式" class="headerlink" title="Asset 加载方式"></a>Asset 加载方式</h2><p>通俗意义上存在三种加载方式<br>静态引用：建一个public的变量，在Inspector里把prefab拉上去，用的时候instantiate<br>Resource.Load: Load以后instantiate<br>AssetBundle.Load: Load以后instantiate</p>
<p>这里进行了一波测试</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放到真机环境下测试以后<br><img src="/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89Asset/img2.png" alt="在这里插入图片描述"></p>
<p>可以看到Load时候引用类型的Assert（即pic1）已经被加载到内存中，Instaniate时候只是Clone和对已经加载到内存中的Assert引用</p>
<h2 id="什么时候才是UnusedAssets"><a href="#什么时候才是UnusedAssets" class="headerlink" title="什么时候才是UnusedAssets?"></a>什么时候才是UnusedAssets?</h2><p>从上面例子中可以看到Destory一个Prefab实例以后，这时候Prefab已经没有被实际的物体引用了，但如果这时：<br>Resources.UnloadUnusedAssets();<br>内存并没有被释放，原因：Prefab还被这个变量go所引用这时候：<br>go = null;<br>Resources.UnloadUnusedAssets();<br>这样才能真正释放Assets对象<br>所以：UnusedAssets不但要没有被实际物体引用，也要没有被<strong>生命周期内的变量</strong>所引用，才可以理解为 Unused(引用计数为0)<br>所以：如果用个全局变量保存Load的Assets，又没有显式的设为null，那在这个变量失效前是无论如何UnloadUnusedAssets也释放不了那些Assets的<br>可以再写下如下代码测试</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Texture tt = Resources.Load(<span class="string">&quot;pic1&quot;</span>) <span class="keyword">as</span> Texture;<span class="comment">//加载贴图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    tt = <span class="literal">null</span>;<span class="comment">//将texture引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/14/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89Asset/img3.png" alt="在这里插入图片描述"><br>这里可以确认prefab中加载的Assert pic1直接加载的pic1占有的是同一块内存，并且仅当go和tt都显示的置为null以后，才可以被UnloadUnusedAssets<br>举个例子帮助理解<br>你从Resources里Load了一个prefab并克隆之：obj = Instaniate(Resources.Load(“prefab1”));<br>这个prefab比如是个npc<br>然后你不需要他的时候你用了：Destroy(obj);你以为就释放干净了<br>其实这时候只是释放了Clone对象，通过Load加载的所有引用、非引用Assets对象全都静静的躺在内存里。<br>这种情况应该在Destroy以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>当然如果你是go = Resources.Load(“prefab1”), obj = Instaniate(go);<br>必须先go = null以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>当然如果这个NPC也是要频繁创建，销毁的 那就应该让那些Assets呆在内存里以加速游戏体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Resources.Load会把需要的所有Assets加载到内存中，当Instaniate时候会Clone和对已经加载到内存中的Assert引用，这些Assets只有在没有被实际物体引用，也没有被生命周期内的变量所引用，才可以理解为Unused，才能被Resources.UnloadUnusedAssets()<br>同理，静态引用的时候由于始终有一个生命周期的对象引用pic1，只要中途没有把这个变量显示的置为null，pic1会自始至终躺在内存中<br>至于AssetBundle.Load，可以把Resources.Load看作是从一个缺省打进程序包里的AssetBundle里加载资源，AssetBundle.load也是在load时候把Perfab的全部Assets加载到内存中</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理（三）Unity默认路径</title>
    <url>/2021/05/19/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89Unity%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Unity中总共有四个数据文件路径dataPath、streamingAssetsPath、 persistentDataPath、temporaryCachePath，四个路径都是相对路径，不同平台下返回的路径不一样。</p>
<h1 id="Application-dataPath"><a href="#Application-dataPath" class="headerlink" title="Application.dataPath"></a>Application.dataPath</h1><p><a href="https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Application-dataPath.html">官方文档</a></p>
<p>dataPath是包含游戏数据文件夹的路径，是app程序包安装路径（安装应用时，系统自动将安装包拷贝到dataPath路径下进行安装），一般不会去手动读写这个目录。</p>
<table>
<thead>
<tr>
<th align="left">Application.dataPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
</tbody></table>
<h1 id="Application-persistentDataPath"><a href="#Application-persistentDataPath" class="headerlink" title="Application.persistentDataPath"></a>Application.persistentDataPath</h1><p><a href="https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html">官方文档</a></p>
<p>persistentDataPath是一个持久化数据存储目录。当应用程序发布到IOS和Android平台，这个路径会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，但可被用户直接删除。</p>
<table>
<thead>
<tr>
<th align="left">Application.persistentDataPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>读写方式：可以用System.IO.StreamReader和System.IO.StreamWriter，也可用System.IO.File.ReadAllText和System.IO.File.WriteAllText。写入之前，记得要先Directory.Exists(folderPath)判断路径是否存在。</p>
<h1 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h1><p><a href="https://docs.unity3d.com/ScriptReference/Application-streamingAssetsPath.html">官方文档</a><br><a href="https://docs.unity3d.com/Manual/StreamingAssets.html">官方文档</a></p>
<p>streamingAssetsPath返回的是流数据的缓存目录，适合用来存储一些外部数据文件用于读取，一般是存放二进制文件（比如：AssetBundle、.csv等）。StreamingAssets文件夹内的东西不会被加密，放进去什么就是什么，所以不要直接把数据文件赤裸裸地放到这个目录下。一般不会去手动将数据写入这个目录。</p>
<table>
<thead>
<tr>
<th align="left">Application.streamingAssetsPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left"><strong>否（可通过第三方软件实现读写）</strong></td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>StreamingAssets中资源可使用 I/O 读取，但 <strong>WebGL 和 Android 平台下该路径为 URL，不支持直接获取，因此需使用UnityWebRequest获取</strong>。若其他平台使用 UnityWebRequest 获取，则需在路径前加上**”file://“** ，如 “file://“ + Application.streamingAssetsPath + “/file.mp4”</p>
<h1 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h1><p>temporaryCachePath返回一个临时数据缓存目录。当应用程序发布到IOS和Android平台，这个路径也会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，手机空间不足时才可能会被系统清除。</p>
<table>
<thead>
<tr>
<th align="left">Application.temporaryCachePath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h1 id="路径地址"><a href="#路径地址" class="headerlink" title="路径地址"></a>路径地址</h1><ul>
<li><strong>Application.dataPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">项目路径/Assets</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">安装路径/ProductName_Data</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Applications/AppName.app/Contents</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/app/package.name.apk</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.persistentDataPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">C:/Users/username/AppData/LocalLow/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left">或</td>
<td align="left">/Users/username/Library/Application Support/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">C:/Users/username/AppData/LocalLow/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Users/username/Library/Application Support/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/data/package.name/files</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.streamingAssetsPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">项目路径/Assets/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">安装路径/ProductName_Data/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Applications/AppName.app/Contents/Resources/Data/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data/Raw</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">jar:file:///data/app/package.name.apk/!/assets</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.temporaryCachePath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">C:/Users/username/AppData/Local/Temp/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left">或</td>
<td align="left">/var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">C:/Users/username/AppData/Local/Temp/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/data/package.name/cache</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>Android下，Application.streamingAssetsPath目录下文件被压缩到单独的.jar文件，不能直接用System.IO 读取，只能用UnityWebRequest读取</li>
<li>在IOS和Android下，可以使用AssetBundle.LoadFromFile来同步读取Application.streamingAssetsPath中数据</li>
<li>统一用UnityWebRequest读取代码可以如下：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> path =</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_ANDROID &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_IPHONE &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        <span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_STANDLONE_WIN || UNITY_EDITOR</span></span><br><span class="line">        <span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">string</span>.Empty;</span><br></pre></td></tr></table></figure></li>
<li>Android下，Unity以前版本直接使用Application.streamingAssetsPath是不能直接得到实际目录，需要写成 “jar:file://“ + Application.dataPath + “!/assets/“ + 资源的形式，现在已经修复，可以直接使用Application.streamingAssetsPath</li>
<li>Android下，可以考虑把Application.streamingAssetsPath下文件拷贝至Application.persistentDataPath，这样读取的方式可以完全不受限制。可以参考<a href="https://www.bbsmax.com/A/A2dmkX1BJe/">https://www.bbsmax.com/A/A2dmkX1BJe/</a></li>
</ul>
<p>参考<a href="https://zhuanlan.zhihu.com/p/141641436">https://zhuanlan.zhihu.com/p/141641436</a><br><a href="https://blog.csdn.net/BillCYJ/article/details/99712313">https://blog.csdn.net/BillCYJ/article/details/99712313</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理（四）Resources目录</title>
    <url>/2021/05/21/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89Resources%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Resources目录"><a href="#Resources目录" class="headerlink" title="Resources目录"></a>Resources目录</h1><p>所有放在Assets/Resources目录下（可以是一个，也可以有很多个，可以在任意的子目录下面）的资源都当做Resources。无论游戏是否使用，都会被打包到最终的程序里，并能通过以下方法获得对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Resources.Load(<span class="string">&quot;fileName&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意：函数内的参数为相对于Resource目录下的文件路径与名称，不包含后缀。<br>在运行时,Assets目录下所有Resources的文件路径将被合并。<br>例：Assets/Resources/test.txt 与 Assets/Test/Resources/test.png在使用Resource.Load(“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；<br>　　如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object[] assets = Resources.LoadAll(<span class="string">&quot;fileName&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Resources弊端"><a href="#Resources弊端" class="headerlink" title="Resources弊端"></a>Resources弊端</h1><p><a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a6">官方文档</a><br>官方的建议是不要使用它。提出此强烈建议的原因有以下：</p>
<ul>
<li>使用Resources文件夹会使内存管理更加困难</li>
<li>资源文件夹使用不当会增加应用程序启动时间和构建时间，随着Resources文件夹的数量增加，在这些文件夹中管理Asset变得非常困难</li>
<li>Resources内的资源无法增量更新。</li>
</ul>
<h1 id="Resources使用场景"><a href="#Resources使用场景" class="headerlink" title="Resources使用场景"></a>Resources使用场景</h1><ul>
<li>在项目的整个生命周期中需要的</li>
<li>很重要且不占用大量内存的</li>
<li>不怎么需要更新，或在不同平台或设备上不变化的</li>
<li>用于系统启动时候最小引导的。</li>
</ul>
<h1 id="Resource-序列化"><a href="#Resource-序列化" class="headerlink" title="Resource 序列化"></a>Resource 序列化</h1><p>在构建项目时，所有名为Resources的文件夹中的Asset和Object将组合到一个序列化的文件中。该文件还包含metadata和索引信息，类似于AssetBundle。<br>如<a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html?_ga=2.187976875.228164586.1621607206-1661509196.1616414836">AssetBundle文档</a>中所述，此索引包括一个序列化的查找树，用于索引相应的File GUID和Local ID，并且它还要记录在序列化文件中的偏移量<br>在大多数平台上，查找数据结构是红黑树，其构建时间以O(nlog(n))的速度增长。这种增长还导致索引的加载时间随着Resources文件夹中Object数量的增加而线性增长。<br>在低端移动设备上初始化包含10,000个Asset的Resources系统会耗费数秒钟的时间，即使实际上很少需要将Resources文件夹中包含的大多数Object加载到应用程序的第一个场景中。</p>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/97149491">https://zhuanlan.zhihu.com/p/97149491</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>资源管理</tag>
      </tags>
  </entry>
</search>
