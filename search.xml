<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Puerts 双击打印日志跳转代码</title>
    <url>/Puerts-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Unity项目中用了<code>Puerts</code>这种热更方式以后，Unity的console下输出的日志是不能双击跳到对应ts代码模块的，这样在开发过程中调试时候只能人工去寻找对应代码，非常的不方便以及影响开发效率，利用Unity的<code>OnOpenAsset</code>和<code>正则匹配</code>可以实现一个调试工具达到双击打印日志跳转到对应ts代码的效果，方便项目中的调试。</p>
<h1 id="输出js-ts-堆栈"><a href="#输出js-ts-堆栈" class="headerlink" title="输出js(ts)堆栈"></a>输出js(ts)堆栈</h1><p>  <img src="/Puerts-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img1.png" alt="在这里插入图片描述"><br>  如图所示，Puerts输出的日志是没有<code>js(ts)</code>堆栈的，所以先要想办法让代码输出<code>js(ts)</code>堆栈信息，<br>  这里我们找到Puerts中”\Src\Resources\puerts”下的<code>log.js</code>文件，作者为了让console.log输出到Unity的console目录下修改了console.log函数，可以看到如下代码<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (console_org) console_org.log.apply(<span class="literal">null</span>, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    UnityEngine_Debug.Log(toString(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里我们参照这篇文章<a href="https://blog.csdn.net/ycx60rzvvbj/article/details/113789431">js获取当前代码行号</a>将log中代码改成<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(toString(<span class="built_in">arguments</span>)).stack.split(<span class="string">&quot;Error: &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (console_org) console_org.log(error);</span><br><span class="line">    UnityEngine_Debug.Log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/Puerts-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img2.png" alt="在这里插入图片描述"></p>
<p>  可以看到项目中的代码已经可以输出<code>js</code>堆栈信息了。<br>  这里要注意一下，由于项目最终运行的是<code>js</code>代码，所以直接输出是<code>js</code>堆栈信息，如果需要输出<code>ts</code>堆栈信息，需要找一个<code>sourcemap</code>解析库，这个<code>js</code>解析库不依赖node或者浏览器，还是比较难找的。<br>  或者区分平台在pc端用node环境方便调试，真机环境下换回v8环境(这个目前官方应该已经支持了)，由于做这个工具时候官方还未推行pc版本的node环境，暂时只输出了<code>js</code>堆栈</p>
<h1 id="外部sourcemap支持"><a href="#外部sourcemap支持" class="headerlink" title="外部sourcemap支持"></a>外部sourcemap支持</h1><p>  由于刚才说过，输出的是<code>js</code>堆栈，所以需要在外部做一个<code>sourcemap</code>支持，在项目根目录下<br>  执行 npm install source-map-support –save 安装source-map-support插件，安装完之后新建一个<code>js</code>文件，我这里起名log.js，写入如下代码<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sourceMapSupport = <span class="built_in">require</span>(<span class="string">&#x27;source-map-support&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> line = process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> column = process.argv[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = sourceMapSupport.mapSourcePosition(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">source</span>: source,</span><br><span class="line">    <span class="attr">line</span>: <span class="built_in">Number</span>(line),</span><br><span class="line">    <span class="attr">column</span>: <span class="built_in">Number</span>(column)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.source);</span><br><span class="line"><span class="built_in">console</span>.log(p.line);</span><br><span class="line"><span class="built_in">console</span>.log(p.column);</span><br></pre></td></tr></table></figure><br>  这个工具函数可以根据传入的js文件名，js行数，js列数，输出对应的源ts文件名，源ts行数，源ts列数</p>
<h1 id="绑定IDE"><a href="#绑定IDE" class="headerlink" title="绑定IDE"></a>绑定IDE</h1><p>  在做代码跳转之前，需要让Unity绑定对应的IDE，一般的开发IDE中，VSCode和IDEA居多，有需要也可以拓展，在Unity Editor目录下新建文件，写入如下代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TypeScriptIDEType</span><br><span class="line">&#123;</span><br><span class="line">    IDEA = <span class="number">0</span>,</span><br><span class="line">    VSCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeScriptIDESetting</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;程序工具/TypeScript/TypeScriptIDE路径配置&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetIDEPath</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TypeScriptIDESetting editor = CreateInstance&lt;TypeScriptIDESetting&gt;();</span><br><span class="line">        editor.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] TypeScriptIDETypes = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;IDEA&quot;</span>, <span class="string">&quot;VSCode&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> typeScriptIDETypeIndex = EditorPrefs.GetInt(<span class="string">&quot;TYPESCRIPT_IDE_TYPE&quot;</span>);</span><br><span class="line">        typeScriptIDETypeIndex = EditorGUILayout.Popup(typeScriptIDETypeIndex, TypeScriptIDETypes);</span><br><span class="line">        EditorPrefs.SetInt(<span class="string">&quot;TYPESCRIPT_IDE_TYPE&quot;</span>, typeScriptIDETypeIndex);</span><br><span class="line"></span><br><span class="line">        TypeScriptIDEType typeScriptIDEType = (TypeScriptIDEType)typeScriptIDETypeIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            GUILayout.Label(<span class="string">&quot;IDEA IDE路径:&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> ideaPath = EditorPrefs.GetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>);</span><br><span class="line">            GUILayout.TextField(ideaPath);</span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Browse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                ideaPath = UnityEditor.EditorUtility.OpenFilePanel(<span class="string">&quot;选择路径&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;exe&quot;</span>);</span><br><span class="line">                EditorPrefs.SetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>, ideaPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;VSCode IDE路径:&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> vscodePath = EditorPrefs.GetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>);</span><br><span class="line">            GUILayout.TextField(vscodePath);</span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Browse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                vscodePath = UnityEditor.EditorUtility.OpenFilePanel(<span class="string">&quot;选择路径&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;exe&quot;</span>);</span><br><span class="line">                EditorPrefs.SetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>, vscodePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  <img src="/Puerts-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img3.png" alt="在这里插入图片描述"><br>  在Unity标签栏寻找对应的标签，这里我放到了”程序工具/TypeScript/TypeScriptIDE路径配置”下，打开后跳出如上界面即可以绑定对应的IDE地址</p>
<h1 id="双击跳转"><a href="#双击跳转" class="headerlink" title="双击跳转"></a>双击跳转</h1><p>  这里利用Unity的OnOpenAssetAttribute在Editor目录下新建文件写入如下代码<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeScriptLogLocation</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UnityEditor.Callbacks.OnOpenAssetAttribute(0)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OnOpenAsset</span>(<span class="params"><span class="built_in">int</span> instanceID, <span class="built_in">int</span> line</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> stackTrace = GetStackTrace();</span><br><span class="line">        <span class="comment">// 正则匹配</span></span><br><span class="line">        MatchCollection matches = Regex.Matches(stackTrace, <span class="string">&quot;at(.*?.js:\\d+:\\d+)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matches != <span class="literal">null</span> &amp;&amp; matches.Count &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Match match = matches[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// puerts 需要跳转到堆栈第二条（这里需要根据项目内容具体调整）</span></span><br><span class="line">            <span class="keyword">if</span> (match.Groups[<span class="number">1</span>].Value.Contains(<span class="string">&quot;console.log&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (matches.Count &gt;= <span class="number">2</span> &amp;&amp; OpenTypeScriptLocation(matches[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> OpenTypeScriptLocation(matches[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出堆栈</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetStackTrace</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Type consoleWindowType = <span class="keyword">typeof</span>(EditorWindow).Assembly.GetType(<span class="string">&quot;UnityEditor.ConsoleWindow&quot;</span>);</span><br><span class="line">        FieldInfo ms_ConsoleWindow_fieldInfo = consoleWindowType.GetField(<span class="string">&quot;ms_ConsoleWindow&quot;</span>, BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">        EditorWindow consoleWindowInstance = ms_ConsoleWindow_fieldInfo.GetValue(<span class="literal">null</span>) <span class="keyword">as</span> EditorWindow;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != consoleWindowInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (EditorWindow.focusedWindow == consoleWindowInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                FieldInfo m_ActiveText_fieldInfo = consoleWindowType.GetField(<span class="string">&quot;m_ActiveText&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">                <span class="keyword">return</span> m_ActiveText_fieldInfo.GetValue(consoleWindowInstance).ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OpenTypeScriptLocation</span>(<span class="params">Match match</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!match.Success)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> resPath;</span><br><span class="line">        <span class="built_in">string</span> resLine;</span><br><span class="line">        <span class="built_in">string</span> resColumn;</span><br><span class="line">        DealMatch(match, <span class="keyword">out</span> resPath, <span class="keyword">out</span> resLine, <span class="keyword">out</span> resColumn);</span><br><span class="line">        OpenIDE(resPath, System.Convert.ToInt32(resLine), System.Convert.ToInt32(resColumn));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DealMatch</span>(<span class="params">Match match, <span class="keyword">out</span> <span class="built_in">string</span> resPath, <span class="keyword">out</span> <span class="built_in">string</span> resLine, <span class="keyword">out</span> <span class="built_in">string</span> resColumn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//字符串解析获取对应js文件名，行数，列数</span></span><br><span class="line">        <span class="built_in">string</span> pathLine = match.Groups[<span class="number">1</span>].Value;</span><br><span class="line">        <span class="built_in">int</span> colomnIndex = pathLine.LastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="built_in">int</span> colomn = System.Convert.ToInt32(pathLine.Substring(colomnIndex + <span class="number">1</span>)); <span class="comment">// js列数</span></span><br><span class="line">        pathLine = pathLine.Substring(<span class="number">0</span>, colomnIndex);</span><br><span class="line">        <span class="built_in">int</span> lineIndex = pathLine.LastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="built_in">int</span> line = System.Convert.ToInt32(pathLine.Substring(lineIndex + <span class="number">1</span>)); <span class="comment">// js行号</span></span><br><span class="line">        <span class="built_in">int</span> pathIndex = pathLine.LastIndexOf(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> path = pathLine.Substring(pathIndex + <span class="number">1</span>, lineIndex - pathIndex - <span class="number">1</span>); <span class="comment">// js文件名</span></span><br><span class="line"></span><br><span class="line">        Process process = <span class="keyword">new</span> Process();</span><br><span class="line">        ProcessStartInfo startInfo = <span class="keyword">new</span> ProcessStartInfo();</span><br><span class="line">        startInfo.FileName = <span class="string">&quot;node&quot;</span>;</span><br><span class="line">        <span class="comment">// 对应sourcemap解析工具函数（注意路径为windows下路径）</span></span><br><span class="line">        startInfo.Arguments = System.Environment.CurrentDirectory.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="built_in">string</span>.Format(<span class="string">&quot;log.js &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;</span>, path.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>), line, colomn);</span><br><span class="line">        startInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line">        startInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line">        startInfo.RedirectStandardOutput = <span class="literal">true</span>;</span><br><span class="line">        startInfo.RedirectStandardInput = <span class="literal">true</span>;</span><br><span class="line">        process.StartInfo = startInfo;</span><br><span class="line">        process.Start();</span><br><span class="line">        StreamReader reader = process.StandardOutput; <span class="comment">//截取输出流 每次读取一行</span></span><br><span class="line">        resPath = reader.ReadLine(); <span class="comment">// ts文件名</span></span><br><span class="line">        resLine = reader.ReadLine(); <span class="comment">// ts行数</span></span><br><span class="line">        resColumn = reader.ReadLine(); <span class="comment">// ts列数</span></span><br><span class="line">        process.WaitForExit(); <span class="comment">// 等待程序执行完退出进程</span></span><br><span class="line">        process.Close(); <span class="comment">// 关闭进程</span></span><br><span class="line">        reader.Close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开IDE</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenIDE</span>(<span class="params"><span class="built_in">string</span> path, <span class="built_in">int</span> line, <span class="built_in">int</span> column</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> typeScriptIDETypeIndex = EditorPrefs.GetInt(<span class="string">&quot;TYPESCRIPT_IDE_TYPE&quot;</span>);</span><br><span class="line">        TypeScriptIDEType typeScriptIDEType = (TypeScriptIDEType)typeScriptIDETypeIndex;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> idePath = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line">            idePath = EditorPrefs.GetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            idePath = EditorPrefs.GetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(idePath) || !System.IO.File.Exists(idePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> args = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line">            args = <span class="string">$&quot;--line <span class="subst">&#123;line&#125;</span> <span class="subst">&#123;path.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typeScriptIDEType == TypeScriptIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            args = <span class="built_in">string</span>.Format(<span class="string">&quot;-g &#123;0&#125;:&#123;1&#125;&quot;</span>, path.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>), line);</span><br><span class="line">        &#125;</span><br><span class="line">        Process process = <span class="keyword">new</span> Process();</span><br><span class="line">        ProcessStartInfo startInfo = <span class="keyword">new</span> ProcessStartInfo();</span><br><span class="line">        startInfo.FileName = idePath;</span><br><span class="line">        startInfo.Arguments = args;</span><br><span class="line">        startInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line">        startInfo.CreateNoWindow = <span class="literal">false</span>;</span><br><span class="line">        startInfo.RedirectStandardOutput = <span class="literal">false</span>;</span><br><span class="line">        process.StartInfo = startInfo;</span><br><span class="line">        process.Start();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上面这些代码都调整好以后，双击Unity对应console下输出日志，即可在对应IDE中跳转到对应的ts代码行数</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li>由于做这个工具的时候，官方还没有支持pc版本的sourcemap支持，目前应该可以直接利用官方提供的sourcemap支持，输出<code>ts</code>堆栈，调试上应该更方便一点，毕竟现在这种做法unity console下输出的还是<code>js</code>堆栈信息</li>
<li>目前工具只做了windows版本,其他如mac版本可能需要在绑定和打开IDE中做出一定调整。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Puerts 支持 DOTween</title>
    <url>/Puerts-%E6%94%AF%E6%8C%81-DOTween/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  <code>Puerts</code>项目中默认没有支持<code>DOTween</code>，项目中需要使用<code>DOTween</code>时，需要一些辅助措施，参考这个大佬的文章，特此记录一下。<br><a href="https://www.jianshu.com/p/3d410c9121a1">参考文章</a></p>
<h1 id="C-导出配置"><a href="#C-导出配置" class="headerlink" title="C#导出配置"></a>C#导出配置</h1><p>  C#对应的<code>Puerts配置</code>中，注册DOTween命名空间<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 第三方插件的代码绑定与导出（到ts）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Puerts.Binding</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Type&gt; ThirdPartsBindings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] namespaces = &#123;</span><br><span class="line">                <span class="string">&quot;DG.Tweening&quot;</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">from</span> type <span class="keyword">in</span> <span class="title">getTypesByNamespaces</span>(<span class="params">namespaces</span>)</span></span><br><span class="line"><span class="function">             <span class="keyword">select</span> type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 遍历给定命名空间public的所有类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;spaceNameList&quot;&gt;</span>命名空间名称列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>类型列表<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;Type&gt; <span class="title">getTypesByNamespaces</span>(<span class="params">ICollection&lt;<span class="built_in">string</span>&gt; spaceNameList</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">from</span> assembly <span class="keyword">in</span> validAssemblies</span><br><span class="line">           <span class="keyword">from</span> type <span class="keyword">in</span> assembly.GetTypes()</span><br><span class="line">           <span class="keyword">where</span> spaceNameList.Contains(type.Namespace) &amp;&amp; (type != <span class="literal">null</span> &amp;&amp; type.IsPublic)</span><br><span class="line">           <span class="keyword">select</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  也可以显式注册<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOTween</span></span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.Sequence),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.DOTween),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.DOTweenModuleSprite),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.DOTweenModuleUI),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.ShortcutExtensions),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.TweenExtensions),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.TweenSettingsExtensions),</span><br><span class="line"><span class="keyword">typeof</span>(DG.Tweening.Ease),</span><br></pre></td></tr></table></figure></p>
<h1 id="ts中注册拓展"><a href="#ts中注册拓展" class="headerlink" title="ts中注册拓展"></a>ts中注册拓展</h1>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> _initDoTween(): <span class="built_in">void</span> &#123;</span><br><span class="line">    $extension(Component, DG.Tweening.ShortcutExtensions);</span><br><span class="line">    $extension(Transform, DG.Tweening.ShortcutExtensions);</span><br><span class="line">    $extension(DG.Tweening.Tween, DG.Tweening.TweenExtensions);</span><br><span class="line">    $extension(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line">    $extension(UI.Image, DG.Tweening.DOTweenModuleUI);</span><br><span class="line">    $extension(UI.Text, DG.Tweening.DOTweenModuleUI);</span><br><span class="line">    $extension(RectTransform, DG.Tweening.DOTweenModuleUI);</span><br><span class="line">    $extension(SpriteRenderer, DG.Tweening.DOTweenModuleSprite);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerVector3 = $generic(DG.Tweening.Core.TweenerCore$3, Vector3, Vector3, DG.Tweening.Plugins.Options.VectorOptions);</span><br><span class="line">    $extension(tweenerVector3, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerVector2 = $generic(DG.Tweening.Core.TweenerCore$3, Vector2, Vector2, DG.Tweening.Plugins.Options.VectorOptions);</span><br><span class="line">    $extension(tweenerVector2, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerString = $generic(DG.Tweening.Core.TweenerCore$3, System.String, System.String, DG.Tweening.Plugins.Options.StringOptions);</span><br><span class="line">    $extension(tweenerString, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerQuaternion1 = $generic(DG.Tweening.Core.TweenerCore$3, Quaternion, Vector3, DG.Tweening.Plugins.Options.QuaternionOptions);</span><br><span class="line">    $extension(tweenerQuaternion1, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerQuaternion2 = $generic(DG.Tweening.Core.TweenerCore$3, Quaternion, Quaternion, DG.Tweening.Plugins.Options.QuaternionOptions);</span><br><span class="line">    $extension(tweenerQuaternion2, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweenerColor = $generic(DG.Tweening.Core.TweenerCore$3, Color, Color, DG.Tweening.Plugins.Options.ColorOptions);</span><br><span class="line">    $extension(tweenerColor, DG.Tweening.TweenSettingsExtensions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在项目一开始执行如上函数，即可以在项目中像C#中一样使用DOTween了如:<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._charTrans.DOScale(Vector3.one, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>  上面只列出了一部分拓展函数，有其他需要时候，可以根据上面的拓展函数照葫芦画瓢即可。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Puerts 自动导入命名空间</title>
    <url>/Puerts-%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  <code>Puerts</code>项目中，由于<code>ts</code>没有类似<code>c#</code>的自动导入命名空间功能，当调用带有命名空间的类时，都需要写入全称，例如定义一个Vector3，往往都需要这么写：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> example: UnityEngine.Vector3 = UnityEngine.Vector3.zero;</span><br></pre></td></tr></table></figure><br>  这样的写法在项目中非常的不方便，并且非常繁琐，看了这个大佬的文章以后解决了这个问题，特此记录总结一下。<br>  <a href="https://www.jianshu.com/p/35131e580160">参考文章</a></p>
<h1 id="创建d-ts"><a href="#创建d-ts" class="headerlink" title="创建d.ts"></a>创建d.ts</h1><p>  <code>ts</code>中有一个<code>d.ts</code>的设计，类似c++的头文件，利用这个特性可以在项目根目录下创建一个<code>d.ts</code>文件，例如<code>csharp.ref.d.ts</code>, 写入如下内容：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&quot;csharp.System&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> csharp <span class="keyword">from</span> <span class="string">&quot;csharp&quot;</span>;</span><br><span class="line">    <span class="keyword">export</span> = csharp.System;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&quot;csharp.UnityEngine&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> csharp <span class="keyword">from</span> <span class="string">&quot;csharp&quot;</span>;</span><br><span class="line">    <span class="keyword">export</span> = csharp.UnityEngine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&quot;csharp.UnityEngine.UI&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> csharp <span class="keyword">from</span> <span class="string">&quot;csharp&quot;</span>;</span><br><span class="line">    <span class="keyword">export</span> = csharp.UnityEngine.UI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样的话在写代码过程中由于这个文件的存在，可以直接写出如下代码，并且import部分是自动根据代码提示生成的<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vector3 &#125; <span class="keyword">from</span> <span class="string">&#x27;csharp.UnityEngine&#x27;</span></span><br><span class="line"><span class="keyword">let</span> example: Vector3 = Vector3.zero;</span><br></pre></td></tr></table></figure></p>
<h1 id="写入执行代码"><a href="#写入执行代码" class="headerlink" title="写入执行代码"></a>写入执行代码</h1><p>  由于上面的<code>d.ts</code>文件是我们偷换了命名空间，所以需要在项目的开始执行如下代码：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> csharp <span class="keyword">from</span> <span class="string">&#x27;csharp&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namespaces = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">namespaces.set(<span class="string">&quot;csharp.System&quot;</span>, csharp.System);</span><br><span class="line">namespaces.set(<span class="string">&quot;csharp.UnityEngine&quot;</span>, csharp.UnityEngine);</span><br><span class="line">namespaces.set(<span class="string">&quot;csharp.UnityEngine.UI&quot;</span>, csharp.UnityEngine.UI);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> puerts = (<span class="built_in">this</span> ?? globalThis).puerts;</span><br><span class="line">    namespaces.forEach(<span class="function">(<span class="params"><span class="built_in">module</span>, name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">module</span>.default = <span class="built_in">module</span>;</span><br><span class="line">        puerts.registerBuildinModule(name, <span class="built_in">module</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><br>  可以创建一个新文件保存如上代码，然后再js虚拟机执行一开始执行这个文件，然后再执行项目开始文件即可，例如我项目中是这样执行的：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JsEnv.Eval(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;ImportModule&quot;</span>));</span><br><span class="line">JsEnv.Eval(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;TsGame&quot;</span>));</span><br></pre></td></tr></table></figure><br>  ImportModule为上述导入命名空间文件，TsGame为项目开始文件，这样就可以在项目中不用再写复杂的命名空间了</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>  其他命名空间都可以采用如上方法，在<code>d.ts</code>添加需要更换的命名空间，然后在<code>ImportModule</code>中注册修改的命名空间即可</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Puerts接入Unity (一) 基本接入</title>
    <url>/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h1 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h1><p>  从<a href="https://github.com/Tencent/puerts/releases">Puerts官网</a>下载对应版本的 Puerts ，并解压</p>
<ul>
<li><code>Sources_code(zip)</code>: Puerts源码<ul>
<li>将源码<code>puerts-Unity_Plugin_xxx.zip</code>解压出来的<code>unity/Assets/Puerts/</code>拷贝到<code>项目/Assets/</code>下。</li>
</ul>
</li>
<li><code>Plugins_V8_verx.tgz</code>: 编译好的V8文件<ul>
<li>将V8文件<code>Plugins_V8_verx.tgz</code>解压出来的<code>Plugins/</code>拷贝到<code>项目/Assets/</code>下。</li>
</ul>
</li>
</ul>
<p>  这样就完成对Puerts的导入。如图所示：<br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img1.png" alt="在这里插入图片描述"></p>
<h1 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h1><p>  创建一个C#脚本写下如下代码：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mJsEnv = <span class="keyword">new</span> JsEnv();        </span><br><span class="line">    mJsEnv.Eval(<span class="string">@&quot;</span></span><br><span class="line"><span class="string">        const CS = require(&#x27;csharp&#x27;);</span></span><br><span class="line"><span class="string">        console.log(&#x27;hello world&#x27;);</span></span><br><span class="line"><span class="string">        console.log(1 + 1);</span></span><br><span class="line"><span class="string">        CS.UnityEngine.Debug.Log(&#x27;Hello World&#x27;);</span></span><br><span class="line"><span class="string">    &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img2.png" alt="在这里插入图片描述"><br>  可以看到Unity的console下可以输出对应日志，代表Puerts已经成功导入项目了。</p>
<h1 id="加载独立Js文件"><a href="#加载独立Js文件" class="headerlink" title="加载独立Js文件"></a>加载独立Js文件</h1><p>  目前代码还是以字符串的形式存在C#代码之中，在实际项目中，所有的Js代码一定都是以独立文件的形式存在。<br>  考虑到放在Unity的Asset下产生无用的meta文件，我们直接将所有<code>Js</code>文件放在根目录下，在根目录下创建JavaScript文件夹，这里我们将<code>Puerts\Src\Resources\puerts</code>下puerts的js文件拷贝至JavaScript文件夹下统一管理，并创建<code>ownts</code>文件夹用于存放我们项目中自己的<code>Js</code>文件，这里我们创建一个test.js用于测试。<br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img3.png" alt="在这里插入图片描述"><br>  下面我们需要定制loader类让Puerts识别到我们自己的<code>Js</code>文件，创建一个<code>JavaScriptLoader</code>实现Puerts的<code>ILoader</code>接口<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Puerts;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JavaScriptLoader</span> : <span class="title">ILoader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> mPuertsRoot;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> mOwntsRoot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaScriptLoader</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mPuertsRoot = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        mOwntsRoot = <span class="string">&quot;ownts/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 纠正路径（Windows下路径斜杠不正确的问题）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>纠正之后的路径<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">pathUnified</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Path.Combine(args).Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 判断模块是否为 Puerts自带模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filePath&quot;&gt;</span>模块名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>true/false<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">isPuertsModule</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> filePath.StartsWith(<span class="string">&quot;puerts/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> * 接口要求实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 判断文件是否存在</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filePath&quot;&gt;</span>文件路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>true/false<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">FileExists</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> rootpath = isPuertsModule(filePath) ? mPuertsRoot : mOwntsRoot;</span><br><span class="line">        <span class="keyword">var</span> fileRealPath = pathUnified(JavaScriptPathHelper.RuntimePath, rootpath, filePath);</span><br><span class="line">        <span class="keyword">return</span> File.Exists(fileRealPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> * 接口要求实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 文件内容读取</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filePath&quot;&gt;</span>模块路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;debugPath&quot;&gt;</span>文件完整路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>文本内容<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReadFile</span>(<span class="params"><span class="built_in">string</span> filePath, <span class="keyword">out</span> <span class="built_in">string</span> debugPath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> rootpath = isPuertsModule(filePath) ? mPuertsRoot : mOwntsRoot;</span><br><span class="line">        <span class="keyword">var</span> fileRealPath = pathUnified(JavaScriptPathHelper.RuntimePath, rootpath, filePath);</span><br><span class="line">        <span class="keyword">var</span> txt = File.ReadAllText(fileRealPath);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR_WIN</span></span><br><span class="line">        debugPath = fileRealPath.Replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>        </span></span><br><span class="line">       debugPath = jsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> txt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <strong>注意</strong>这里需要判断是否为puerts自身的模块，<code>debugPath</code>windows下需要修改”/“为”\“，具体作用我们留到调试环节再阐述。<br>  新建JavaScriptPathHelper用于管理JavaScript相关的路径<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JavaScriptPathHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> RuntimePath</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.LinuxEditor</span><br><span class="line">                     || Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.OSXPlayer || Application.platform == RuntimePlatform.LinuxPlayer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> System.Environment.CurrentDirectory +  <span class="string">&quot;/JavaScript/&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Application.persistentDataPath + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  我们再调整入口文件<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JsEnv mJsEnv;</span><br><span class="line"><span class="keyword">private</span> JavaScriptLoader mJsLoader;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mJsLoader = <span class="keyword">new</span> JavaScriptLoader();</span><br><span class="line">    mJsEnv = <span class="keyword">new</span> JsEnv(mJsLoader);</span><br><span class="line">    mJsEnv.Eval(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  最后，回到游戏场景中再次运行游戏，可以看到<code>Js</code>文件被执行。</p>
<p>  参考链接:<a href="https://www.jianshu.com/p/4eb6fd5e0b4c">https://www.jianshu.com/p/4eb6fd5e0b4c</a><br>          <a href="https://www.jianshu.com/p/5537996c4c33">https://www.jianshu.com/p/5537996c4c33</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>UI管理-PureMVC</title>
    <url>/UI%E7%AE%A1%E7%90%86-PureMVC/</url>
    <content><![CDATA[<p>参考 <a href="https://blog.csdn.net/wangjiangrong/article/details/107686954">https://blog.csdn.net/wangjiangrong/article/details/107686954</a><br>        <a href="https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html">https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html</a><br>        <a href="https://blog.csdn.net/qq_29579137/article/details/73692842">https://blog.csdn.net/qq_29579137/article/details/73692842</a></p>
<p>挪用了其他文章中的一些流程图</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  最近负责项目UI框架部分的搭建，查阅了一些资料以后，借鉴了其他项目的一些想法，在这边整理一下，项目UI部分是用Lua写的，贴的相关代码也是Lua代码，由于是边学习边写的，命名规则是按项目标准命名的（成员变量前加m等）</p>
<h1 id="MVC和PureMVC"><a href="#MVC和PureMVC" class="headerlink" title="MVC和PureMVC"></a>MVC和PureMVC</h1><p>  目标：将数据（Model），视图组件（View）和控制逻辑（Control）进行分离。让程序便于修改，更具有扩展性，灵活性，可重用性。高内聚，低耦合，一直是追求的目标。传统经典的MVC模型虽然将数据，视图组件和控制逻辑进行了分离，但耦合性还是比较高。</p>
<p>  PureMVC在MVC基础上做了许多的改进，通过结合多个设计模式的应用，让耦合性变得更低，也变得更加的易用，在扩展性，灵活性，重用性方面也做得更好</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-（Singleton）"><a href="#单例模式-（Singleton）" class="headerlink" title="单例模式 （Singleton）"></a>单例模式 （Singleton）</h2><p>  在PureMVC中，Model,View,Controller是三个单例模式类，三者合称为核心层，实际上是Manager管理类，分别定义了字典用于保存引用</p>
<h2 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h2><p>  在开发的过程中，需要在Contoller中，获取View以及Model的对象，修改Mode，更新View，或是在View，需要获取Model，进行一些初始化或是修改的操作，在业务逻辑很多的情况下，Model, View, Controller之间的频繁的调用就会非常多，耦合性会变高，在PureMVC中，为Model、View、Controller类提供了外观类Façade，主要负责访问和通知 Model、View 和 Controller，即管理这三者。Façade统一对外提供这3者的接口，使用过程成只需要跟Façade打交道就行</p>
<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>  为了彻底解耦，避免直接的函数调用，PureMVC使用观察者模式（又称发布/订阅模式）的形式传递消息。在PureMVC中Mediator、Proxy、Command之间的通信，以通知形式实现松散耦合。Mediator、Proxy、Command都是通知者（发布者） 可以调用sendNotification发送消息；Mediator、Command同时也是观察者（订阅者）可以接收来自其它对象的通知。</p>
<p>  这里先不用关心Mediator、Proxy、Command是什么，需要注意的是Mediator和Command既是通知者也是观察者，Proxy只是通知者<br>  Proxy=&gt;Model            ，Mediator=&gt;View        ， Command=&gt;Controller</p>
<p>  所有的通知者（发布者）都继承自Notifier类，故拥有发布通知的功能，而Notifier是使用Façade发布通知的<br>  由外观模式可知façade保存了View的引用，View在观察者模式中充当着管理者的角色，保存着所有消息/主题、观察者的映射。当Mediator/Command/Proxy发布通知时，façade调用View的notifyObservers()方法，遍历保存的映射关系，从而通知所有满足条件的观察者</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Notifier:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="keyword">local</span> facade = <span class="built_in">self</span>:GetFacade()</span><br><span class="line">    <span class="keyword">if</span> facade ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        facade:SendNotification(notificationName, body, <span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="built_in">self</span>:NotifyObservers(Notification.New(notificationName, body, <span class="built_in">type</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:NotifyObservers</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mView ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:NotifyObservers(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  Command 中调用 Controller的 RegisterCommand 注册通知<br>  通过复写Command的Execute方法实现回调<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:RegisterCommand</span><span class="params">(notificationName, commandClassRef)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mCommandMap[notificationName] == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:RegisterObserver(notificationName, Observer.New(<span class="built_in">self</span>.ExecuteCommand, <span class="built_in">self</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">self</span>.mCommandMap[notificationName] = commandClassRef</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:ExecuteCommand</span><span class="params">(note)</span></span></span><br><span class="line">    <span class="keyword">local</span> commandClassRef = <span class="built_in">self</span>.mCommandMap[note:GetName()]</span><br><span class="line">    <span class="keyword">if</span>(commandClassRef == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> commandInstance = commandClassRef.New()</span><br><span class="line">    commandInstance:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    commandInstance:Execute(note)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>  Mediator 中调用 View 的 RegisterMediator<br>  通过复写Mediator的ListNotificationInterests方法实现回调<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View:RegisterMediator</span><span class="params">(mediator)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] = mediator</span><br><span class="line">    <span class="keyword">local</span> interests = mediator:ListNotificationInterests()</span><br><span class="line">    <span class="keyword">if</span> #interests &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> observer = Observer.New(mediator.handleNotification, mediator)</span><br><span class="line">        <span class="keyword">for</span> _, i <span class="keyword">in</span> <span class="built_in">pairs</span>(interests) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">self</span>:RegisterObserver(i, observer)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:OnRegister()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img1.png" alt="在这里插入图片描述"></p>
<h2 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h2><p>  在PureMVC中，Mediator帮助我们创建或重用已有UI组件，而UI不用知道PureMVC框架相关的东西，UI仅用于显示数据、接收用户输入。Mediator是UI组件与框架的中介，它负责将来自PureMVC框架的消息转接到UI，并将UI的消息转发广播到PureMVC框架。这样通过Mediator解耦了UI与PureMVC框架元素（Proxy、Mediator、Command），而不用互相引用。</p>
<p>  一个Mediator只与一个UI绑定（1对1），Mediator构造函数参数传递与之绑定的UI。通过façade的registerMediator方法注册Mediator，以接收PureMVC框架的通知</p>
<p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img2.png" alt="在这里插入图片描述"></p>
<p>  Mediator接收PureMVC传来的Notification，调用UI函数<br>  接收UI派发的事件，转发Notification传回PureMVC框架</p>
<p>  例如 当点击领取邮件按钮，EmailUI发送消息给EmailMediator传给PureMVC，（中间可能涉及服务器交互），之后PureMVC，需要更新背包内容就发送消息给BagMediator，BagMediator接收事件以后更新BagUI，Bag功能和Email功能并没有影响</p>
<h2 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h2><p>  在PureMVC中，Proxy帮助我们以更易于重用、修改对应用程序影响最小的方式暴露数据结构、接口给应用程序。Proxy可能只是简单的管理本地数据对象，以同步方式获取或修改数据；也可能是远程服务器数据，以异步方式操作数据，服务器数据返回之后以Notification方式告诉应用程序。</p>
<p>  简单来说，Proxy对数据逻辑进行包装，只对外公布操作数据对象的API，例如EmailProxy负责接收来自服务器的邮件内容，当邮件更新时，EmailUI并不需要关心邮件数据是什么形式发来的，当EmailUI需要展示邮件内容，只需要调取EmailProxy公布的API（例如EmaliProxy.GetEmailList）即可，反之，当发送邮件时，EmailUI也不需要关注怎么发送，以什么样数据格式发给服务器，一切逻辑都由EmailProxy处理，这样极大程度实现了对一些处理逻辑的封装，降低了耦合。</p>
<h2 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h2><p>  命令模式是对命令的封装，把发出命令的责任和执行命令的责任分割开，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>
<p>  在PureMVC中，命令用来检索、操作Proxy，或者与Mediator通信，或者执行其它命令。<br>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img3.png" alt="在这里插入图片描述"></p>
<p>  例如:EmailMediator 接收到来自UI的sendEmail的消息，EmailMediator把消息传到SendEmailCommand， SendEmailCommand持有EmailProxy的引用，调用EmailProxy的SendEmail接口发送消息</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img4.png" alt="在这里插入图片描述"></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h2>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> GameFacade = BaseClass(<span class="string">&quot;GameFade&quot;</span>, Facade)</span><br><span class="line"><span class="keyword">local</span> base = Facade</span><br><span class="line"><span class="keyword">local</span> STARTUP = <span class="string">&quot;startUp&quot;</span></span><br><span class="line">GameFacade.KEY = <span class="string">&quot;GameFacade&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:InitializeController</span><span class="params">()</span></span></span><br><span class="line">    base.InitializeController(<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>:RegisterCommand(STARTUP, StartUpCommand)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:StartUp</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>:SendNotification(STARTUP);</span><br><span class="line">    <span class="comment">--PureMVC初始化完成，注销STARTUP命令</span></span><br><span class="line">    <span class="built_in">self</span>:RemoveCommand(STARTUP);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:GetInstance</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rawget</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rawset</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>, GameFacade.New(GameFacade.KEY))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> GameFacade.Instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GameFacade</span><br></pre></td></tr></table></figure>

  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> StartUpCommand = BaseClass(<span class="string">&#x27;StartUpCommand&#x27;</span>, MacroCommand)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StartUpCommand:InitializeMacroCommand</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> StartUpCommand</span><br></pre></td></tr></table></figure>

<p>  一般是继承Facade类注册 开始事件，这里是 STARTUP， 然后继承Command 构造 StartUpCommand<br>  这里可以参考网上一些完整样例。<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">GameFacade:GetInstance():StartUp()</span><br></pre></td></tr></table></figure><br>  通过StartUp开启</p>
<h2 id="单模块通信"><a href="#单模块通信" class="headerlink" title="单模块通信"></a>单模块通信</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img5.png" alt="在这里插入图片描述"></p>
<p>  红色为直接调用，绿色为事件通信</p>
<p>  Proxy只发送消息不接受消息，是通过Command直接调用的，原因是设计时Proxy要负责和服务器交互，再监听其他事件过于繁琐</p>
<h2 id="多模块通信"><a href="#多模块通信" class="headerlink" title="多模块通信"></a>多模块通信</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img6.png" alt="在这里插入图片描述"></p>
<p>  黄色线也是可能存在的事件，因为观察者模式不需要关注消息的来源，只要订阅了相关消息就可以触发</p>
<p>  例如EmailProxy接收到服务器消息更新时也需要更新BagUI就可以发送消息给BagMediator</p>
<p>  或者EmailUI也可以购买物品可以发送消息给<br>  EmailMediator转发给BagCommand调用BagProxy</p>
<h2 id="过于强调解耦"><a href="#过于强调解耦" class="headerlink" title="过于强调解耦"></a>过于强调解耦</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img7.png" alt="在这里插入图片描述"></p>
<p>  因为都是消息机制，整个流程很长，而且Proxy中对数据进行操作后，发送Notification时，可能需要携带修改后的数据（可能是来自服务器的数据）。这个过程不仅通过次数多，而且带反馈数据的消息增加通信负担。另一方面要调试这个过程，我们只能在编译的时候找出一步一步的通信流程，才能跟踪调试。</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>  因为游戏项目本身不需要过于解耦，UI部分不希望出现类爆炸的情况，在此基础上进行了一些修改</p>
<h2 id="UI-和-Mediator-结合"><a href="#UI-和-Mediator-结合" class="headerlink" title="UI 和 Mediator 结合"></a>UI 和 Mediator 结合</h2><p>  Mediator和UI之间的通信有点繁琐，可以让UI持有Mediator，这样UI可以通过持有的UIMediator 与PureMVC交互，并且接收到消息时，也可以直接调用自身UI函数，不再需要Mediator持有UI调用</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:ListNotificationInterests</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> result = <span class="built_in">self</span>.mViewComponent:ListNotificationInterests()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:HandleNotification</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>.mViewComponent:HandleNotification(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  UI直接绑定一个公用的UIMediator通过UIMeditaor发送消息和PureMVC交互</p>
<h2 id="Command中介多余"><a href="#Command中介多余" class="headerlink" title="Command中介多余"></a>Command中介多余</h2><p>  数据相关部分已经被Proxy封装好，可以考虑不再需要通过Command转发，可以直接由UI（UIMediator）调用Proxy的接口以减少类的数量，Proxy之间的调用可以通过加一个全局注册事件触发</p>
<h2 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img8.png" alt="在这里插入图片描述"></p>
<p>  交互过程UI 通过调用自身的成员变量UIMediator发送消息<br>  并通过在UIMediator中注册的消息响应来自来自外部的消息<br>  UI不再经过Command调用Proxy 而是直接调用Proxy</p>
<h2 id="修改总结"><a href="#修改总结" class="headerlink" title="修改总结"></a>修改总结</h2><p>  <img src="/UI%E7%AE%A1%E7%90%86-PureMVC/img9.png" alt="在这里插入图片描述"></p>
<ul>
<li>对于一个小功能，每个功能对应的文件应该为一个UI和一个Proxy</li>
<li>对于一个大功能，每个功能对应的文件应该为多个UI和一个Proxy  </li>
<li>因为Proxy没有接收消息的接口，一般来说Proxy之间不会有互相调用的情况，但是可能会有如：背包收到服务器更新消息以后先更新背包后更新其他例如邮件等功能数据的情况，可考虑通过外部的Event添加监听</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li>解耦的同时将使项目修改的复杂程度提高，某些解耦的办法还会增加代码量、降低执行效率。PureMVC是一个强解耦的框架，其效率本身不是很高，函数调用层次较深，而有时根本不清楚消息发到了哪里</li>
<li>因为需要外界触发，在游戏上一般只适合用来做UI部分</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>UI管理</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>lua</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Puerts接入Unity (二) 搭建Ts环境</title>
    <url>/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-%E6%90%AD%E5%BB%BATs%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在前面章节中，脚本文件内容都是<code>Js</code>，实际项目开发过程中，我们是编写<code>Ts</code>的，但是<code>Ts</code>是不能直接运行的，在V8中的运行形式还是<code>Js</code>，所以，我们需要搭建<code>Ts</code>到<code>Js</code>的编译环境。<code>Ts</code>到<code>Js</code>的编译器有很多，本文主要介绍<code>tsc</code>编译。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>安装<a href="https://code.visualstudio.com/">VSCode</a>(对TypeScript有很好的支持)</li>
<li>安装<a href="https://nodejs.org/zh-cn/">Node.js</a>(编译环境)</li>
<li>安装npm, npm为Node.js自带的包管理工具，上面安装Node时就已经安装上了</li>
<li>安装TypeScript到系统环境(在 <code>项目根目录</code>)下打开控制台(下同)<ul>
<li> 输入 <code>npm install typescript -g</code> 安装</li>
</ul>
</li>
<li>项目目录下创建下列文件<ul>
<li><code>TypeScript</code>空文件夹，用于存放项目中的所有<code>Ts</code>文件</li>
<li><code>package.json</code>文件，用于保存项目中要用到的模块依赖、构建命令<ul>
<li>终端输入<code>npm init</code>，一直回车直到结束</li>
</ul>
</li>
<li><code>tsconfig.json</code>文件，用于配置项目中<code>Ts</code>的配置项，<ul>
<li>一开始可以是{}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  全部准备完以后，项目的整体情况如图所示:<br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-%E6%90%AD%E5%BB%BATs%E7%8E%AF%E5%A2%83/img1.png" alt="在这里插入图片描述"></p>
<h1 id="修改package-json"><a href="#修改package-json" class="headerlink" title="修改package.json"></a>修改package.json</h1><p>  可以将以下内容，复制到初始化好的<code>package.json</code>中。<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;puerts&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;tsc -b tsconfig.json -w&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node ./Build.js clear &amp;&amp; tsc -b tsconfig.json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fs-extra&quot;</span>: <span class="string">&quot;^9.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;uglify-js&quot;</span>: <span class="string">&quot;^3.13.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里我们需要关注几个内容：</p>
<ul>
<li><code>scripts</code>: 定义的构建脚本，可以定义任意工作流，通过<code>npm run 任务名</code>来执行某个任务<ul>
<li>如<code>npm run watch</code>代表执行 <code>tsc -b tsconfig.json -w</code></li>
</ul>
</li>
<li><code>dependencies</code>: 定义了项目中要用到的依赖。如目前有的依赖<ul>
<li>fs-extra，一个 node 文件操作模块增强版本</li>
<li>uglify-js，一个 Js 代码压缩模块</li>
</ul>
</li>
</ul>
<p>  在项目目录下运行<code>npm install</code>来拉取依赖到本地，拉取到的所有的依赖都将保存在<code>项目/node_modules</code>目录中。<br>  此外可以通过<code>npm install 依赖名 --save</code>安装依赖，并将依赖注册到<code>dependencies</code>中<br>  如<code>npm install source-map-support -- save</code>代表安装<code>source-map-support</code>依赖，并会在<code>dependencies</code>中注册<code>source-map-support</code>的版本，方便项目中其他人直接安装</p>
<h1 id="修改tsconfig-json"><a href="#修改tsconfig-json" class="headerlink" title="修改tsconfig.json"></a>修改tsconfig.json</h1><p>  <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">tsconfig参考配置</a><br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ESNext&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react-jsx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;ESNext&quot;</span> ,<span class="string">&quot;DOM&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./TypeScript/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;typeRoots&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;./Assets/Puerts/Typing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;./Assets/Gen/Typing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;./node_modules/@types&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./JavaScript/ownts/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里我们需要关注几个内容：</p>
<ul>
<li><code>baseUrl</code>: 基本目录即放置ts代码的目录</li>
<li><code>typeRoots</code>: 指定哪些文件默认需要引入<ul>
<li><code>./Assets/Puerts/Typing</code>: Puerts自带的文件</li>
<li><code>./Assets/Gen/Typing</code>: csharp导出的文件</li>
<li><code>./node_modules/@types</code>: 安装的依赖带有的文件</li>
</ul>
</li>
<li><code>outDir</code>: 编译输出目录即编译生成的js代码目录</li>
</ul>
<h1 id="创建Puerts配置文件"><a href="#创建Puerts配置文件" class="headerlink" title="创建Puerts配置文件"></a>创建Puerts配置文件</h1><p>  <a href="https://github.com/Tencent/puerts/blob/master/doc/unity/manual.md">官方文档</a><br>  需要根据官网要求加上一定的标签，并且放在Unity的Editor目录下<br>  这里我们在Editor下创建MyPuertsCfg统一管理，这里贴出一部分代码供参考<br>  完整代码可以下载<a href="MyPuertsCfg.zip">MyPuertsCfg</a><br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> puerts工具配置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Puerts.Configure</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPuertsCfg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 部分C# System接口绑定与导出（到ts）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Puerts.Binding</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Type&gt; CsharpBindings</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Array),</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Object),</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Type),</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Delegate),</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Collections.Generic.ICollection&lt;UnityEngine.Object&gt;),</span><br><span class="line">                    <span class="keyword">typeof</span>(System.Collections.Generic.IList&lt;UnityEngine.Object&gt;),</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 部分Unity Engine接口绑定与导出（到ts）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Puerts.Binding</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Type&gt; UnityBindings</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Color),</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Debug),</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Time),</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Rect),</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Vector2),</span><br><span class="line">                    <span class="keyword">typeof</span>(UnityEngine.Vector3),</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Puerts.Filter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">FilterMethods</span>(<span class="params">System.Reflection.MemberInfo mb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mb.DeclaringType == <span class="keyword">typeof</span>(UnityEngine.MonoBehaviour) &amp;&amp; mb.Name == <span class="string">&quot;runInEditMode&quot;</span>)</span><br><span class="line">        &#123;<span class="comment">// 排除 MonoBehaviour.runInEditMode, 在 Editor 环境下可用发布后不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mb.DeclaringType == <span class="keyword">typeof</span>(UnityEngine.UI.Text) &amp;&amp; mb.Name == <span class="string">&quot;OnRebuildRequested&quot;</span>)</span><br><span class="line">        &#123;<span class="comment">// 排除 Text.OnRebuildRequested, 在 Editor 环境下可用发布后不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mb.DeclaringType == <span class="keyword">typeof</span>(UnityEngine.UI.Graphic) &amp;&amp; mb.Name == <span class="string">&quot;OnRebuildRequested&quot;</span>)</span><br><span class="line">        &#123;<span class="comment">// 排除 Graphic.OnRebuildRequested, 在 Editor 环境下可用发布后不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认不过滤</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-%E6%90%AD%E5%BB%BATs%E7%8E%AF%E5%A2%83/img2.png" alt="在这里插入图片描述"><br>  创建完成以后可以点击Generate Code就可以看到<code>Assets/Gen</code>目录下生成的Puerts导出文件</p>
<h1 id="创建辅助脚本Build-js"><a href="#创建辅助脚本Build-js" class="headerlink" title="创建辅助脚本Build.js"></a>创建辅助脚本Build.js</h1><p>  可以看到我们的<code>package.json</code>中的<code>&quot;build&quot;: &quot;node ./Build.js clear &amp;&amp; tsc -b tsconfig.json&quot;</code>，我们可以用node做出脚本辅助我们项目中一些文件处理，这里我做了一个清理脚本Build.js有需要可以根据项目拓展<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>),</span><br><span class="line">    fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取传入的参数模式</span></span><br><span class="line">    mode = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> argv = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>).argv;</span><br><span class="line">        <span class="keyword">return</span> argv[argv.length - <span class="number">1</span>];</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">mode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> configPath = path.join(__dirname, <span class="string">&#x27;tsconfig.json&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(configPath)</span><br><span class="line">        <span class="keyword">if</span> (fs.existsSync(configPath)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.config = <span class="built_in">require</span>(configPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;tsconfig.json 配置文件不存在&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">this</span>.srcDir = path.join(__dirname, <span class="built_in">this</span>.config.compilerOptions.baseUrl);</span><br><span class="line">        <span class="built_in">this</span>.outDir = path.join(__dirname, <span class="built_in">this</span>.config.compilerOptions.outDir);</span><br><span class="line">        <span class="built_in">this</span>.timer = &#123;&#125;;      <span class="comment">// 文件监听计时器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;clear&#x27;</span>:</span><br><span class="line">                <span class="built_in">this</span>.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除目录 Js</span></span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        fs.emptyDirSync(<span class="built_in">this</span>.outDir);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`目录清除成功：<span class="subst">$&#123;<span class="built_in">this</span>.outDir&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Build(mode);</span><br></pre></td></tr></table></figure></p>
<h1 id="创建Ts代码测试"><a href="#创建Ts代码测试" class="headerlink" title="创建Ts代码测试"></a>创建Ts代码测试</h1><p>  完成了上面所有操作以后，我们就可以编写<code>Ts</code>代码了，如图我们可以创建test.ts，然后运行<code>npm run build</code>(删除原有<code>Js</code>代码重新编译)，或者<code>npm run watch</code>(实时监听编译，TypeScript目录下所有的 ts 文件有任何改动，都会实时编译)，就可以看到编译生成的<code>Js</code>代码了，运行Unity就可以成功读取生成的<code>Js</code>代码了<br>  <img src="/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-%E6%90%AD%E5%BB%BATs%E7%8E%AF%E5%A2%83/img3.png" alt="在这里插入图片描述"></p>
<p>  参考链接：<a href="https://www.jianshu.com/p/007be135eb92">https://www.jianshu.com/p/007be135eb92</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理 (一) 内存理解</title>
    <url>/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%B8%80)-%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在刚学习Unity资源管理的时候，经常把GC和Resources.UnloadUnusedAssets()搞混掉，查阅了相关资料做一下记录，在学习的过程中请留意文章的时间，笔者在学习的时候查阅了很多文章，发现众说纷纭，这是因为Unity版本也在不断更新，每个版本的处理可能都不一样，尽量结合网上的资料自己做测试，才能理解的更加深刻。</p>
<h1 id="Unity内存分类"><a href="#Unity内存分类" class="headerlink" title="Unity内存分类"></a>Unity内存分类</h1><p>  Unity引擎开发的移动游戏，内存有三部分：分别是程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>  程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。</p>
<h2 id="托管堆（Managed-Heap"><a href="#托管堆（Managed-Heap" class="headerlink" title="托管堆（Managed Heap)"></a>托管堆（Managed Heap)</h2><p>  托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。</p>
<h2 id="本机堆（Native-Heap"><a href="#本机堆（Native-Heap" class="headerlink" title="本机堆（Native Heap)"></a>本机堆（Native Heap)</h2><p>  本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。<br>  <img src="/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%B8%80)-%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/img1.png" alt="在这里插入图片描述"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="程序代码优化"><a href="#程序代码优化" class="headerlink" title="程序代码优化"></a>程序代码优化</h2><p>  这部分的优化主要就是减少打包时的引用库，使一些不需要的库剥离。具体可以看上面的链接文章。</p>
<h2 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h2><p>  “托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。这里的垃圾回收就是我们平时所说的GC。</p>
<h3 id="GC定义"><a href="#GC定义" class="headerlink" title="GC定义"></a>GC定义</h3><p>  GC是Mono运行时的机制，而非Unity游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。明白了这一点，也就明白了GC不是用来处理引擎的Assets（贴图，音效，模型等等）的内存释放的，因为Unity引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆。<br>  目前绝大部分Unity游戏逻辑代码所使用的语言为C#，C#代码所占用的内存又称为Mono内存，这是因为Unity是通过Mono来跨平台解析并运行C#代码的，在Android系统上，游戏的lib目录下存在的libmono.so文件，就是Mono在Android系统上的实现。C#代码通过Mono解析执行，所需要的内存自然也是由Mono来进行分配管理。</p>
<h3 id="托管堆内容"><a href="#托管堆内容" class="headerlink" title="托管堆内容"></a>托管堆内容</h3><p>  托管堆中存储的是你在代码中申请的内存，即引用类型，一般包括：自定义的类，接口，委托，数组，字符串，Object，值类型包括几种基本数据类型（如int,float,bool等），结构体，枚举，空类型。</p>
<h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><p>  Mono内存分为两部分，已用内存（used）和堆内存（heap），已用内存指的是Mono实际需要使用的内存，堆内存指的是Mono向操作系统申请的内存，两者的差值就是Mono的空闲内存。当Mono需要分配内存时，会先查看空闲内存是否足够，如果足够的话，直接在空闲内存中分配，否则Mono会进行一次GC以释放更多的空闲内存，如果GC之后仍然没有足够的空闲内存，则Mono会向操作系统申请内存，并扩充堆内存。</p>
<h3 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h3><p>  托管资源的内存管理是靠引用计数进行的，只要保证对象不再被引用，即可在GC的时候将托管资源占用的内存释放。如:将指针变量置null，则该指针之前指向的对象（如果有）​的引用计数减1；指针变量的生命周期结束（临时变量所在的大括号之外、类成员变量所在的对象被释放等）时，指针指向的对象（如果有）的引用计数减1。注意：只要指针的生命周期未结束，会一直保持对对象的引用计数，包括数组、字典等中引用的元素。</p>
<h3 id="GC步骤"><a href="#GC步骤" class="headerlink" title="GC步骤"></a>GC步骤</h3><p>  GC的主要作用在于从已用内存中找出那些不再需要使用的内存，并进行释放。主要步骤如下：<br>  1.停止所有需要mono内存分配的线程。<br>  2.遍历所有已用内存，找到那些不再需要使用的内存，并进行标记。<br>  3.释放被标记的内存到空闲内存。<br>  4.重新开始被停止的线程。<br>  除了空闲内存不足时Mono会自动调用GC外，也可以在代码中调用System.GC.Collect()手动进行GC，但是，GC本身是比较耗时的操作，而且由于GC会暂停那些需要mono内存分配的线程（C#代码创建的线程和主线程），因此无论是否在主线程中调用，GC都会导致游戏一定程度的卡顿，需要谨慎处理。</p>
<h3 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h3><p>  因此为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity引擎的那些资源，其实说白了GC的优化也就是代码的优化。这里网上有比较多的文章会讲很多细节代码，包括字符串处理，foreach，减少拆装箱等等。</p>
<h2 id="本机堆优化"><a href="#本机堆优化" class="headerlink" title="本机堆优化"></a>本机堆优化</h2><p>  当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。<br>  应该减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>  需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。<br>  因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()。</p>
<h3 id="和GC区分"><a href="#和GC区分" class="headerlink" title="和GC区分"></a>和GC区分</h3><p>  Resources.UnloadAsset(Object) 用于卸载对应Object（Asset）， Resources.UnloadUnusedAssets()用于卸载<br>  所有没有被引用以及实例化的Object（Asset），这些非托管资源中的Object用GC是没办法清理的。这里了解了内存种类以后应该很好理解。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>  切换场景时，Resources.UnloadUnusedAssets()，System.GC.Collect()这两个函数都是会被自动调用的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  对于非托管资源，需要调用Resources.UnloadUnusedAssets()，对于托管资源，才用​System.GC.Collect()来释放。对于资源优化应该区分清楚资源类型，了解内存的分类。最后，更深入的学习资源管理，了解更多的优化细节还需要结合实际情况具体分析。</p>
<p>  参考 <a href="https://blog.csdn.net/HarvestHarvest/article/details/107379535">https://blog.csdn.net/HarvestHarvest/article/details/107379535</a><br>  <a href="http://www.onevcat.com/2012/11/memory-in-unity3d/">http://www.onevcat.com/2012/11/memory-in-unity3d/</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>资源管理</category>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity资源管理 (三) Unity默认路径</title>
    <url>/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%B8%89)-Unity%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Unity中总共有四个数据文件路径dataPath、streamingAssetsPath、 persistentDataPath、temporaryCachePath，四个路径都是相对路径，不同平台下返回的路径不一样。</p>
<h1 id="Application-dataPath"><a href="#Application-dataPath" class="headerlink" title="Application.dataPath"></a>Application.dataPath</h1><p>  <a href="https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Application-dataPath.html">官方文档</a></p>
<p>  dataPath是包含游戏数据文件夹的路径，是app程序包安装路径（安装应用时，系统自动将安装包拷贝到dataPath路径下进行安装），一般不会去手动读写这个目录。</p>
<table>
<thead>
<tr>
<th align="left">Application.dataPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
</tbody></table>
<h1 id="Application-persistentDataPath"><a href="#Application-persistentDataPath" class="headerlink" title="Application.persistentDataPath"></a>Application.persistentDataPath</h1><p>  <a href="https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html">官方文档</a></p>
<p>  persistentDataPath是一个持久化数据存储目录。当应用程序发布到IOS和Android平台，这个路径会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，但可被用户直接删除。</p>
<table>
<thead>
<tr>
<th align="left">Application.persistentDataPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>  读写方式：可以用System.IO.StreamReader和System.IO.StreamWriter，也可用System.IO.File.ReadAllText和System.IO.File.WriteAllText。写入之前，记得要先Directory.Exists(folderPath)判断路径是否存在。</p>
<h1 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h1><p>  <a href="https://docs.unity3d.com/ScriptReference/Application-streamingAssetsPath.html">官方文档</a><br>  <a href="https://docs.unity3d.com/Manual/StreamingAssets.html">官方文档</a></p>
<p>  streamingAssetsPath返回的是流数据的缓存目录，适合用来存储一些外部数据文件用于读取，一般是存放二进制文件（比如：AssetBundle、.csv等）。StreamingAssets文件夹内的东西不会被加密，放进去什么就是什么，所以不要直接把数据文件赤裸裸地放到这个目录下。一般不会去手动将数据写入这个目录。</p>
<table>
<thead>
<tr>
<th align="left">Application.streamingAssetsPath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left"><strong>否（可通过第三方软件实现读写）</strong></td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>  StreamingAssets中资源可使用 I/O 读取，但 <strong>WebGL 和 Android 平台下该路径为 URL，不支持直接获取，因此需使用UnityWebRequest获取</strong>。若其他平台使用 UnityWebRequest 获取，则需在路径前加上**”file://“** ，如 “file://“ + Application.streamingAssetsPath + “/file.mp4”</p>
<h1 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h1><p>  temporaryCachePath返回一个临时数据缓存目录。当应用程序发布到IOS和Android平台，这个路径也会指向一个公共的路径。应用更新、覆盖安装时，这里的数据都不会被清除，手机空间不足时才可能会被系统清除。</p>
<table>
<thead>
<tr>
<th align="left">Application.temporaryCachePath</th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Editor</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Android</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">IOS</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h1 id="路径地址"><a href="#路径地址" class="headerlink" title="路径地址"></a>路径地址</h1><ul>
<li><strong>Application.dataPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">项目路径/Assets</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">安装路径/ProductName_Data</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Applications/AppName.app/Contents</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/app/package.name.apk</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.persistentDataPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">C:/Users/username/AppData/LocalLow/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left">或</td>
<td align="left">/Users/username/Library/Application Support/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">C:/Users/username/AppData/LocalLow/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Users/username/Library/Application Support/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/data/package.name/files</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.streamingAssetsPath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">项目路径/Assets/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">安装路径/ProductName_Data/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/Applications/AppName.app/Contents/Resources/Data/StreamingAssets</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/AppName.app/Data/Raw</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">jar:file:///data/app/package.name.apk/!/assets</td>
</tr>
</tbody></table>
</li>
<li><strong>Application.temporaryCachePath</strong><table>
<thead>
<tr>
<th align="left">平台</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Editor</strong></td>
<td align="left">C:/Users/username/AppData/Local/Temp/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left">或</td>
<td align="left">/var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Windows</strong></td>
<td align="left">C:/Users/username/AppData/Local/Temp/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>Mac OS</strong></td>
<td align="left">/var/folders/xx/xxxxxxxxxxxxxx/X/CompanyName/ProductName</td>
</tr>
<tr>
<td align="left"><strong>iOS</strong></td>
<td align="left">/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td>
</tr>
<tr>
<td align="left"><strong>Android</strong></td>
<td align="left">/data/data/package.name/cache</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>Android下，Application.streamingAssetsPath目录下文件被压缩到单独的.jar文件，不能直接用System.IO 读取，只能用UnityWebRequest读取</li>
<li>在IOS和Android下，可以使用AssetBundle.LoadFromFile来同步读取Application.streamingAssetsPath中数据</li>
<li>统一用UnityWebRequest读取代码可以如下：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> path =</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_ANDROID &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_IPHONE &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        <span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_STANDLONE_WIN || UNITY_EDITOR</span></span><br><span class="line">        <span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">string</span>.Empty;</span><br></pre></td></tr></table></figure></li>
<li>Android下，Unity以前版本直接使用Application.streamingAssetsPath是不能直接得到实际目录，需要写成 “jar:file://“ + Application.dataPath + “!/assets/“ + 资源的形式，现在已经修复，可以直接使用Application.streamingAssetsPath</li>
<li>Android下，可以考虑把Application.streamingAssetsPath下文件拷贝至Application.persistentDataPath，这样读取的方式可以完全不受限制。可以参考<a href="https://www.bbsmax.com/A/A2dmkX1BJe/">https://www.bbsmax.com/A/A2dmkX1BJe/</a></li>
</ul>
<p>  参考<a href="https://zhuanlan.zhihu.com/p/141641436">https://zhuanlan.zhihu.com/p/141641436</a><br>  <a href="https://blog.csdn.net/BillCYJ/article/details/99712313">https://blog.csdn.net/BillCYJ/article/details/99712313</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>资源管理</category>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity资源管理 (二) Asset</title>
    <url>/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%BA%8C)-Asset/</url>
    <content><![CDATA[<h1 id="Asset-和-Object"><a href="#Asset-和-Object" class="headerlink" title="Asset 和 Object"></a>Asset 和 Object</h1><h2 id="Asset（资源文件）"><a href="#Asset（资源文件）" class="headerlink" title="Asset（资源文件）"></a>Asset（资源文件）</h2><p>  关于Asset，网上已经有很多解释了，可以去看<a href="https://zhuanlan.zhihu.com/p/96709802">https://zhuanlan.zhihu.com/p/96709802</a></p>
<p>  简单来说，Asset是位于Assets目录下，可以在Unity的Projects窗口里看到的单个文件。这些就是平常项目中用到的资源文件，例如纹理，音效文件，预制体等等。</p>
<h2 id="Object-（对象）"><a href="#Object-（对象）" class="headerlink" title="Object （对象）"></a>Object （对象）</h2><p>  Object是指从UnityEngine.Object继承的对象，是一个可以序列化的数据，是用来描述一个特定的资源的实例。例如Mesh, Sprite, AudioClip or AnimationClip等等。</p>
<h2 id="Asset和Object"><a href="#Asset和Object" class="headerlink" title="Asset和Object"></a>Asset和Object</h2><p>  刚学习时，会把Asset和Object搞混，这里可以去看这篇文章<a href="https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw">https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw?</a><br>  简单来说，对于Asset，无论是纹理、音乐还是预制体，在进入Unity以后，都需要转变成Object，即纹理转变为Texture2D或Sprite，音效文件转变为AudioClip，预制体变成了GameObject等等，这个由Asset(资源文件)转变为Object(对象)，从磁盘进入内存的过程，就是实例化。<br>  这里补充说明一下实例化，例如如下代码<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameObject prefab = Resources.Load(<span class="string">&quot;prefab1&quot;</span>, <span class="keyword">typeof</span>(GameObject)) <span class="keyword">as</span> GameObject;</span><br><span class="line">GameObject instance = Instantiate(prefab) <span class="keyword">as</span> GameObject;</span><br></pre></td></tr></table></figure><br>  第一个GameObject prefab的Resources.Load是“解释”你要加载的东西是个GameObject并且加载到内存中。<br>  第二个GameObject instance是对prefab进行一个深度copy克隆到场景中然后从Instantiate的返回值中持有他的引用。<br>  通俗意义上我们理解的实例化是指Instantiate生成某个实例，而Unity层面的实例化是指Asset转化为Object，一般情况下，我们使用上会两步一起用，Unity分开做的原因是因为在实际运用中，有些Asset加载以后不需要Instantiate，分成两个API以后会有更高的自由度。</p>
<h2 id="区分-File-GUIDs、Local-IDs和Instance-ID"><a href="#区分-File-GUIDs、Local-IDs和Instance-ID" class="headerlink" title="区分 File GUIDs、Local IDs和Instance ID"></a>区分 File GUIDs、Local IDs和Instance ID</h2><h3 id="File-GUIDs"><a href="#File-GUIDs" class="headerlink" title="File GUIDs"></a>File GUIDs</h3><p>  Unity通过赋予每一个Asset一个Unique ID来区分每一个Asset。这个Unique ID就是File GUID，用于标识这个Asset的位置，这个GUID是由Unity根据内部算法自动生成的，并且存放在原始文件的同目录、同名但是后缀为.meta的文件里。<br>  例如，如果一个资源引用了另一个外部资源，比如一个Prefab引用了其他脚本、纹理或Prefab等，则一定会标明引用资源文件的File GUID。</p>
<h3 id="Local-IDs（FileID）"><a href="#Local-IDs（FileID）" class="headerlink" title="Local IDs（FileID）"></a>Local IDs（FileID）</h3><p>  File GUID表示为文件和文件之间的关系，Local ID表示为文件内部各对象之间的关系，一个对象通常是由一个或多个对象构成，每个记录在&amp;符号后面的数字都是一个Local ID，每一个Local ID也表示着它将来也会被实例化成一个对象。File GUID确保了Asset在整个Unity工程里唯一，Local ID确保Objects在Asset里唯一，这样就可以通过二者的组合去快速找到对应的引用。</p>
<h3 id="Instance-ID"><a href="#Instance-ID" class="headerlink" title="Instance ID"></a>Instance ID</h3><p>  理论上通过File GUID和Local ID就可以找到对应的引用，但是运行时性能上还有问题，即GUID对比速度慢，也就是说运行时还是需要一个表现更好的系统，所以就有了Instance ID。<br>  Unity中使用PersistentManager，用来把File GUIDs和Local IDs转化为一个简单的、Session唯一的整数。这些整数就是Instance ID。Instance Id很简单，就是一个递增的整数，每当有新对象需要在缓存里注册的时候（即读入一个File GUID和LocalID时），就会自动将File GUID和LocalID转换成一个Instance ID，通过Instance ID去定位资源就像直接解引用一个地址，效率比通过File GUID和LocalID快很多。<br>  PersistentManager会维护Instance ID和File GUID 、Local ID的映射关系，定位Object源数据的位置以及维护内存中（如果有的话）Object的实例。只要系统解析到一个Instance ID，就能快速找到代表这个Instance ID的已加载的对象。如果Object没有被加载的话，File GUID 和Local ID也可以快速的定位到指定的Asset资源从而即时进行资源加载。</p>
<h1 id="Asset-加载和Instaniate"><a href="#Asset-加载和Instaniate" class="headerlink" title="Asset 加载和Instaniate"></a>Asset 加载和Instaniate</h1><h2 id="Asset-加载和Instaniate原理"><a href="#Asset-加载和Instaniate原理" class="headerlink" title="Asset 加载和Instaniate原理"></a>Asset 加载和Instaniate原理</h2><p>  一个Prefab从AssetBundle或者Resource里Load出来 里面可能包括：Gameobject transform mesh texture material shader script和各种其他Assets<br>  Instaniate一个Prefab，是一个对Assets进行<strong>Clone(复制)+引用</strong>结合的过程，GameObject transform 是Clone是新生成的。其他mesh / texture / material / shader 等，这其中些是纯引用的关系的，包括：Texture和TerrainData，还有引用和复制同时存在的，包括：Mesh/material /PhysicMaterial。引用的Asset对象不会被复制，只是一个简单的指针指向已经Load的Asset对象<br>  提一下的是一个特殊的东西：Script Asset，看起来很奇怪，Unity里每个Script都是一个封闭的Class定义而已, 并没有写调用代码，光Class的定义脚本是不会工作的。其实Unity引擎就是那个调用代码，Clone一个script asset等于new一个class实例，实例才会完成工作。把他挂到Unity主线程的调用链里去，Class实例里的OnUpdate OnStart等才会被执行。多个物体挂同一个脚本，其实就是在多个物体上挂了那个脚本类的多个实例而已，这样就好理解了。在new class这个过程中，数据区是复制的，代码区是共享的，算是一种特殊的复制+引用关系。<br>  你可以再Instaniate一个同样的Prefab, 还是这套mesh/texture/material/shader等等，这时候会有新的GameObject等，但是不会创建新的引用对象比如texture.<br>  可以参照下图理解<br>  <img src="/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%BA%8C)-Asset/img1.png" alt="在这里插入图片描述"></p>
<h2 id="Asset-加载方式"><a href="#Asset-加载方式" class="headerlink" title="Asset 加载方式"></a>Asset 加载方式</h2><p>  通俗意义上存在三种加载方式<br>  静态引用：建一个public的变量，在Inspector里把prefab拉上去，用的时候instantiate<br>  Resource.Load: Load以后instantiate<br>  AssetBundle.Load: Load以后instantiate</p>
<p>  这里进行了一波测试<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  放到真机环境下测试以后<br>  <img src="/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%BA%8C)-Asset/img2.png" alt="在这里插入图片描述"></p>
<p>  可以看到Load时候引用类型的Assert（即pic1）已经被加载到内存中，Instaniate时候只是Clone和对已经加载到内存中的Assert引用</p>
<h2 id="什么时候才是UnusedAssets"><a href="#什么时候才是UnusedAssets" class="headerlink" title="什么时候才是UnusedAssets?"></a>什么时候才是UnusedAssets?</h2><p>  从上面例子中可以看到Destory一个Prefab实例以后，这时候Prefab已经没有被实际的物体引用了，但如果这时：<br>  Resources.UnloadUnusedAssets();<br>  内存并没有被释放，原因：Prefab还被这个变量go所引用这时候：<br>  go = null;<br>  Resources.UnloadUnusedAssets();<br>  这样才能真正释放Assets对象<br>  所以：UnusedAssets不但要没有被实际物体引用，也要没有被<strong>生命周期内的变量</strong>所引用，才可以理解为 Unused(引用计数为0)<br>  所以：如果用个全局变量保存Load的Assets，又没有显式的设为null，那在这个变量失效前是无论如何UnloadUnusedAssets也释放不了那些Assets的<br>  可以再写下如下代码测试<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Texture tt = Resources.Load(<span class="string">&quot;pic1&quot;</span>) <span class="keyword">as</span> Texture;<span class="comment">//加载贴图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    tt = <span class="literal">null</span>;<span class="comment">//将texture引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E4%BA%8C)-Asset/img3.png" alt="在这里插入图片描述"><br>  这里可以确认prefab中加载的Assert pic1直接加载的pic1占有的是同一块内存，并且仅当go和tt都显示的置为null以后，才可以被UnloadUnusedAssets<br>  举个例子帮助理解<br>  你从Resources里Load了一个prefab并克隆之：obj = Instaniate(Resources.Load(“prefab1”));<br>  这个prefab比如是个npc<br>  然后你不需要他的时候你用了：Destroy(obj);你以为就释放干净了<br>  其实这时候只是释放了Clone对象，通过Load加载的所有引用、非引用Assets对象全都静静的躺在内存里。<br>  这种情况应该在Destroy以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>  当然如果你是go = Resources.Load(“prefab1”), obj = Instaniate(go);<br>  必须先go = null以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>  当然如果这个NPC也是要频繁创建，销毁的 那就应该让那些Assets呆在内存里以加速游戏体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  Resources.Load会把需要的所有Assets加载到内存中，当Instaniate时候会Clone和对已经加载到内存中的Assert引用，这些Assets只有在没有被实际物体引用，也没有被生命周期内的变量所引用，才可以理解为Unused，才能被Resources.UnloadUnusedAssets()<br>  同理，静态引用的时候由于始终有一个生命周期的对象引用pic1，只要中途没有把这个变量显示的置为null，pic1会自始至终躺在内存中<br>  至于AssetBundle.Load，可以把Resources.Load看作是从一个缺省打进程序包里的AssetBundle里加载资源，AssetBundle.load也是在load时候把Perfab的全部Assets加载到内存中</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>资源管理</category>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity资源管理 (四) Resources目录</title>
    <url>/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-(%E5%9B%9B)-Resources%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Resources目录"><a href="#Resources目录" class="headerlink" title="Resources目录"></a>Resources目录</h1><p>  所有放在Assets/Resources目录下（可以是一个，也可以有很多个，可以在任意的子目录下面）的资源都当做Resources。无论游戏是否使用，都会被打包到最终的程序里，并能通过以下方法获得对象：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Resources.Load(<span class="string">&quot;fileName&quot;</span>);</span><br></pre></td></tr></table></figure><br>  注意：函数内的参数为相对于Resource目录下的文件路径与名称，不包含后缀。<br>  在运行时,Assets目录下所有Resources的文件路径将被合并。<br>  例：Assets/Resources/test.txt 与 Assets/Test/Resources/test.png在使用Resource.Load(“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；<br>  如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object[] assets = Resources.LoadAll(<span class="string">&quot;fileName&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="Resources弊端"><a href="#Resources弊端" class="headerlink" title="Resources弊端"></a>Resources弊端</h1><p>  <a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a6">官方文档</a><br>  官方的建议是不要使用它。提出此强烈建议的原因有以下：</p>
<ul>
<li>使用Resources文件夹会使内存管理更加困难</li>
<li>资源文件夹使用不当会增加应用程序启动时间和构建时间，随着Resources文件夹的数量增加，在这些文件夹中管理Asset变得非常困难</li>
<li>Resources内的资源无法增量更新。</li>
</ul>
<h1 id="Resources使用场景"><a href="#Resources使用场景" class="headerlink" title="Resources使用场景"></a>Resources使用场景</h1><ul>
<li>在项目的整个生命周期中需要的</li>
<li>很重要且不占用大量内存的</li>
<li>不怎么需要更新，或在不同平台或设备上不变化的</li>
<li>用于系统启动时候最小引导的。</li>
</ul>
<h1 id="Resource-序列化"><a href="#Resource-序列化" class="headerlink" title="Resource 序列化"></a>Resource 序列化</h1><p>  在构建项目时，所有名为Resources的文件夹中的Asset和Object将组合到一个序列化的文件中。该文件还包含metadata和索引信息，类似于AssetBundle。<br>  如<a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html?_ga=2.187976875.228164586.1621607206-1661509196.1616414836">AssetBundle文档</a>中所述，此索引包括一个序列化的查找树，用于索引相应的File GUID和Local ID，并且它还要记录在序列化文件中的偏移量<br>  在大多数平台上，查找数据结构是红黑树，其构建时间以O(nlog(n))的速度增长。这种增长还导致索引的加载时间随着Resources文件夹中Object数量的增加而线性增长。<br>  在低端移动设备上初始化包含10,000个Asset的Resources系统会耗费数秒钟的时间，即使实际上很少需要将Resources文件夹中包含的大多数Object加载到应用程序的第一个场景中。</p>
<p>  参考 <a href="https://zhuanlan.zhihu.com/p/97149491">https://zhuanlan.zhihu.com/p/97149491</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>资源管理</category>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>XLua 双击打印日志跳转代码</title>
    <url>/XLua-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Unity项目中用了<code>XLua</code>这种热更方式以后，Unity的console下输出的日志是不能双击跳到对应lua代码模块的，这样在开发过程中调试时候只能人工去寻找对应代码，非常的不方便以及影响开发效率，利用Unity的<code>OnOpenAsset</code>和<code>正则匹配</code>可以实现一个调试工具达到双击打印日志跳转到对应lua代码的效果，方便项目中的调试。</p>
<h1 id="输出lua堆栈"><a href="#输出lua堆栈" class="headerlink" title="输出lua堆栈"></a>输出lua堆栈</h1><p>  <img src="/XLua-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img1.png" alt="在这里插入图片描述"><br>  如图所示，lua输出的日志是没有<code>lua</code>堆栈的，所以先要想办法让代码输出<code>lua</code>堆栈信息，这里我们可以<br>  封装一个Debug.lua文件<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> csDebug = CS.UnityEngine.Debug</span><br><span class="line"><span class="keyword">local</span> LogPreFix = <span class="string">&quot;LUA: &quot;</span></span><br><span class="line"></span><br><span class="line">Debug = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Debug.Log</span><span class="params">(msg)</span></span></span><br><span class="line">    csDebug.Log(Debug.FormatTraceback(msg))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Debug.LogWarning</span><span class="params">(msg)</span></span></span><br><span class="line">    csDebug.LogWarning(Debug.FormatTraceback(msg))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Debug.LogError</span><span class="params">(msg)</span></span></span><br><span class="line">    csDebug.LogError(Debug.FormatTraceback(msg))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 显示第三层堆栈的信息，过滤掉前面两层</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Debug.FormatTraceback</span><span class="params">(msg)</span></span></span><br><span class="line">    <span class="keyword">return</span> LogPreFix .. <span class="built_in">debug</span>.<span class="built_in">traceback</span>(msg, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><br>  <img src="/XLua-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img2.png" alt="在这里插入图片描述"></p>
<p>  可以看到项目中的代码已经可以输出<code>lua</code>堆栈信息了。</p>
<h1 id="绑定IDE"><a href="#绑定IDE" class="headerlink" title="绑定IDE"></a>绑定IDE</h1><p>  在做代码跳转之前，需要让Unity绑定对应的IDE，一般的开发IDE中，VSCode和IDEA居多，有需要也可以拓展，在Unity Editor目录下新建文件，写入如下代码<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">using</span> UnityEditor;</span><br><span class="line">  <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> LuaIDEType</span><br><span class="line">&#123;</span><br><span class="line">    IDEA = <span class="number">0</span>,</span><br><span class="line">    VSCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaIDESetting</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;程序工具/Lua/LuaIDE路径配置&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetIdeaIDEPath</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LuaIDESetting editor = CreateInstance&lt;LuaIDESetting&gt;();</span><br><span class="line">        editor.Show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] luaIDETypes = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;IDEA&quot;</span>, <span class="string">&quot;VSCode&quot;</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> luaIDETypeIndex = EditorPrefs.GetInt(<span class="string">&quot;LUA_IDE_TYPE&quot;</span>);</span><br><span class="line">        luaIDETypeIndex = EditorGUILayout.Popup(luaIDETypeIndex, luaIDETypes);</span><br><span class="line">        EditorPrefs.SetInt(<span class="string">&quot;LUA_IDE_TYPE&quot;</span>, luaIDETypeIndex);</span><br><span class="line">        LuaIDEType luaIDEType = (LuaIDEType)luaIDETypeIndex;</span><br><span class="line">        <span class="keyword">if</span> (luaIDEType == LuaIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;IDEA IDE路径:&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> ideaPath = EditorPrefs.GetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>);</span><br><span class="line">            GUILayout.TextField(ideaPath);</span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Browse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                ideaPath = UnityEditor.EditorUtility.OpenFilePanel(<span class="string">&quot;选择路径&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;exe&quot;</span>);</span><br><span class="line">                EditorPrefs.SetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>, ideaPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (luaIDEType == LuaIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;VSCode IDE路径:&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> vscodePath = EditorPrefs.GetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>);</span><br><span class="line">            GUILayout.TextField(vscodePath);</span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Browse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                vscodePath = UnityEditor.EditorUtility.OpenFilePanel(<span class="string">&quot;选择路径&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;exe&quot;</span>);</span><br><span class="line">                EditorPrefs.SetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>, vscodePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/XLua-%E5%8F%8C%E5%87%BB%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/img3.png" alt="在这里插入图片描述"><br>在Unity标签栏寻找对应的标签，这里我放到了”程序工具/Lua/LuaIDE路径配置”下，打开后跳出如上界面即可以绑定对应的IDE地址</p>
<h1 id="双击跳转"><a href="#双击跳转" class="headerlink" title="双击跳转"></a>双击跳转</h1><p>这里利用Unity的OnOpenAssetAttribute在Editor目录下新建文件写入如下代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaLogLocation</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UnityEditor.Callbacks.OnOpenAssetAttribute(1)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OnOpenAsset</span>(<span class="params"><span class="built_in">int</span> instanceID, <span class="built_in">int</span> line</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> stackTrace = GetStackTrace();</span><br><span class="line">        <span class="comment">// 这里正则解析</span></span><br><span class="line">        Match match = Regex.Match(stackTrace, <span class="string">&quot;stack traceback:\n.*:\\d+:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OpenLuaLocation(match);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出堆栈</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetStackTrace</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Type consoleWindowType = <span class="keyword">typeof</span>(EditorWindow).Assembly.GetType(<span class="string">&quot;UnityEditor.ConsoleWindow&quot;</span>);</span><br><span class="line">        FieldInfo ms_ConsoleWindow_fieldInfo = consoleWindowType.GetField(<span class="string">&quot;ms_ConsoleWindow&quot;</span>, BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">        EditorWindow consoleWindowInstance = ms_ConsoleWindow_fieldInfo.GetValue(<span class="literal">null</span>) <span class="keyword">as</span> EditorWindow;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != consoleWindowInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (EditorWindow.focusedWindow == consoleWindowInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                FieldInfo m_ActiveText_fieldInfo = consoleWindowType.GetField(<span class="string">&quot;m_ActiveText&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">                <span class="keyword">return</span> m_ActiveText_fieldInfo.GetValue(consoleWindowInstance).ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开IDE</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OpenLuaLocation</span>(<span class="params">Match match</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> luaIDETypeIndex = EditorPrefs.GetInt(<span class="string">&quot;LUA_IDE_TYPE&quot;</span>);</span><br><span class="line">        LuaIDEType luaIDEType = (LuaIDEType)luaIDETypeIndex;</span><br><span class="line">        <span class="built_in">string</span> idePath = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (luaIDEType == LuaIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line">            idePath = EditorPrefs.GetString(<span class="string">&quot;IDEA_IDE_Path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (luaIDEType == LuaIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            idePath = EditorPrefs.GetString(<span class="string">&quot;VSCode_IDE_Path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(idePath) || !System.IO.File.Exists(idePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里处理正则匹配后的结构，需要根据项目实际情况具体分析</span></span><br><span class="line">        <span class="built_in">string</span> pathLine = match.Groups[<span class="number">0</span>].Value;</span><br><span class="line">        pathLine = pathLine.Substring(pathLine.IndexOf(<span class="string">&quot;\t&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        pathLine = pathLine.Substring(<span class="number">0</span>, pathLine.Length - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> spliteIndex = pathLine.LastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="built_in">string</span> filePath = pathLine.Substring(<span class="number">0</span>, spliteIndex);</span><br><span class="line">        <span class="built_in">int</span> line = System.Convert.ToInt32(pathLine.Substring(spliteIndex + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里需要根据项目中lua文件的位置以及补充后缀等</span></span><br><span class="line">        <span class="built_in">string</span> luaCodePath = Path.Combine(LuaManager.LUA_FILE_PATH, filePath + LuaManager.LUA_FILE_EXTENSION);</span><br><span class="line">        filePath = System.Environment.CurrentDirectory + <span class="string">&quot;/&quot;</span> + luaCodePath;</span><br><span class="line">        <span class="built_in">string</span> args = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (luaIDEType == LuaIDEType.IDEA)</span><br><span class="line">        &#123;</span><br><span class="line">            args = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span>, filePath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>), line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (luaIDEType == LuaIDEType.VSCode)</span><br><span class="line">        &#123;</span><br><span class="line">            args = <span class="built_in">string</span>.Format(<span class="string">&quot;-g &#123;0&#125;:&#123;1&#125;&quot;</span>, filePath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>), line);</span><br><span class="line">        &#125;</span><br><span class="line">        Process process = <span class="keyword">new</span> Process();</span><br><span class="line">        ProcessStartInfo startInfo = <span class="keyword">new</span> ProcessStartInfo();</span><br><span class="line">        startInfo.FileName = idePath;</span><br><span class="line">        startInfo.Arguments = args;</span><br><span class="line">        startInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line">        startInfo.CreateNoWindow = <span class="literal">false</span>;</span><br><span class="line">        startInfo.RedirectStandardOutput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        process.StartInfo = startInfo;</span><br><span class="line">        process.Start();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些代码都调整好以后，双击Unity对应console下输出日志，即可在对应IDE中跳转到对应的lua代码行数<br>注意中间解析字符串的过程以及获取目录的过程，需要自己根据项目目录调整一下，注意使用绝对路径，windows下注意文件目录左右斜杠的问题</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li>目前工具只做了windows版本，其他如mac版本可能需要在绑定和打开IDE中做出一定调整。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>XLua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>XLua接入Unity (一) 基本接入</title>
    <url>/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h1 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h1><p>  从<a href="https://github.com/Tencent/xLua">XLua官网</a>下载XLua项目，将<code>Assets/Plugins/</code>和<code>Assets/XLua/</code>拷贝到<code>项目/Assets/</code>下，这样就完成对XLua的导入。如图所示：<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img1.png" alt="在这里插入图片描述"></p>
<h1 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h1><p>  创建一个C#脚本写下如下代码：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mLuaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">    mLuaEnv.DoString(<span class="string">&quot;print(&#x27;hello world&#x27;)&quot;</span>);</span><br><span class="line">    mLuaEnv.DoString(<span class="string">&quot;print(1 + 1)&quot;</span>);</span><br><span class="line">    mLuaEnv.DoString(<span class="string">&quot;CS.UnityEngine.Debug.Log(&#x27;hello world&#x27;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img2.png" alt="在这里插入图片描述"><br>  可以看到Unity的console下可以输出对应日志，代表XLua已经成功导入项目了。</p>
<h1 id="加载独立Lua文件"><a href="#加载独立Lua文件" class="headerlink" title="加载独立Lua文件"></a>加载独立Lua文件</h1><p>  目前代码还是以字符串的形式存在C#代码之中，在实际项目中，所有的Lua代码一定都是以独立文件的形式存在。<br>  考虑到放在Unity的Asset下产生无用的meta文件，我们直接将所有<code>Lua</code>文件放在根目录下，在根目录下创建Lua文件夹，并新建test.lua文件，如图所示：<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img3.png" alt="在这里插入图片描述"><br>  下面我们需要定制loader函数让XLua识别到我们自己的<code>Lua</code>文件，<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mLuaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">  mLuaEnv.AddLoader(handleLoad);</span><br><span class="line">  mLuaEnv.DoString(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;Lua.test&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">byte</span>[] <span class="title">handleLoad</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    filePath = filePath.Replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="built_in">string</span> newPath = LuaPathHelper.RuntimePath + filePath + <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(File.Exists(newPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> File.ReadAllBytes(newPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <strong>注意</strong>这里handleLoad中需要加上<code>File.Exists</code>判断，不然require非自己编写的lua文件会报错。<br>  新建LuaPathHelper用于管理Lua相关的路径<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaPathHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> RuntimePath</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.LinuxEditor</span><br><span class="line">                     || Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.OSXPlayer || Application.platform == RuntimePlatform.LinuxPlayer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Path.Combine(Application.dataPath, <span class="string">&quot;../&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Application.persistentDataPath + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%85%A5/img4.png" alt="在这里插入图片描述"><br>  可以看到XLua成功识别到了我们在Lua文件夹下的test.lua文件</p>
<h1 id="配置GenConfig"><a href="#配置GenConfig" class="headerlink" title="配置GenConfig"></a>配置GenConfig</h1><p>  在Lua中使用C#的方法，和在C#中使用Lua的方法都需要对相应方法打上<code>[LuaCallCSharp]</code>和<code>[CSharpCallLua]</code>标签，为了统一管理，可以将他们放到一个C#文件中<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置的详细介绍请看Doc下《XLua的配置.doc》</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GenConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//lua中要使用到C#库的配置，比如C#标准库，或者Unity API，第三方库等。</span></span><br><span class="line">    [<span class="meta">LuaCallCSharp</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Type</span>&gt; LuaCallCSharp</span> = <span class="keyword">new</span> List&lt;Type&gt;() &#123;</span><br><span class="line">                <span class="keyword">typeof</span>(System.Object),</span><br><span class="line">                <span class="keyword">typeof</span>(UnityEngine.Object),</span><br><span class="line">                <span class="keyword">typeof</span>(Vector2),</span><br><span class="line">                <span class="keyword">typeof</span>(Vector3),</span><br><span class="line">                <span class="keyword">typeof</span>(Vector4),</span><br><span class="line">                <span class="keyword">typeof</span>(Quaternion)</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C#静态调用Lua的配置（包括事件的原型），仅可以配delegate，interface</span></span><br><span class="line">    [<span class="meta">CSharpCallLua</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Type</span>&gt; CSharpCallLua</span> = <span class="keyword">new</span> List&lt;Type&gt;() &#123;</span><br><span class="line">                <span class="keyword">typeof</span>(Action),</span><br><span class="line">                <span class="keyword">typeof</span>(Action&lt;<span class="built_in">bool</span>&gt;),</span><br><span class="line">                <span class="keyword">typeof</span>(Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt;),</span><br><span class="line">                <span class="keyword">typeof</span>(Action&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//黑名单</span></span><br><span class="line">    [<span class="meta">BlackList</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">List</span>&lt;<span class="title">string</span>&gt;&gt; BlackList</span> = <span class="keyword">new</span> List&lt;List&lt;<span class="built_in">string</span>&gt;&gt;()  &#123;</span><br><span class="line">                <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123;<span class="string">&quot;System.Xml.XmlNodeList&quot;</span>, <span class="string">&quot;ItemOf&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123;<span class="string">&quot;UnityEngine.WWW&quot;</span>, <span class="string">&quot;movie&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过调用Unity标签栏下的Generate Code 和 Clear Generate Code即可以生成对应的Wrap文件，Wrap文件的原理和作用可以参考这篇文章<a href="https://www.cnblogs.com/blueberryzzz/p/9672342.html">Wrap文件原理和作用</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>XLua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>XLua接入Unity (三) 搭建调试环境(VSCode)</title>
    <url>/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Lua调试需要借助EmmyLua，EmmyLua调试可以直接attach到unity进程进行调试（官方不太建议），安装JDK后并设置JAVA_HOME环境变量即可，也可以使用tcp连接进行远程调试，下面介绍如何使用tcp连接调试。</p>
<h1 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h1><p>  在VSCode中创建或添加新的调试配置，选择EmmyLua new Debug<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/img1.png" alt="在这里插入图片描述"><br>  会产生如下的配置（也可以直接粘贴进launch.json中）<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;emmylua_new&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;EmmyLua IDEConnectDebugger&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">9978</span>,</span><br><span class="line">            <span class="attr">&quot;ext&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;.lua&quot;</span>,</span><br><span class="line">                <span class="string">&quot;.lua.txt&quot;</span>,</span><br><span class="line">                <span class="string">&quot;.lua.bytes&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;ideConnectDebugger&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里我们需要关注两个变量</p>
<ul>
<li>port ：调试端口号（这个端口号需要跟emmyluaService中端口号不一样）</li>
<li>ideConnectDebugger： 是否由ide连接Debugger(即Unity)<ul>
<li>true 需要先启动Unity后启动IDE调试</li>
<li>false 需要先启动IDE调试后启动Unity</li>
</ul>
</li>
</ul>
<h1 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h1><p>  在lua代码最开始初，我们在VSCode中ctrl + shift + p 输入EmmyLua选择Insert Emmy Debugger Code<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/img2.png" alt="在这里插入图片描述"><br>  可以生成如下的代码：<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">cpath</span> = <span class="built_in">package</span>.<span class="built_in">cpath</span> .. <span class="string">&quot;;c:/Users/用户名/.vscode/extensions/tangzx.emmylua-0.3.49/debugger/emmy/windows/x86/?.dll&quot;</span></span><br><span class="line"><span class="keyword">local</span> dbg = <span class="built_in">require</span>(<span class="string">&quot;emmy_core&quot;</span>)</span><br><span class="line">dbg.tcpListen(<span class="string">&quot;localhost&quot;</span>, <span class="number">9978</span>)</span><br></pre></td></tr></table></figure><br>  默认是ideConnectDebugger：true形式的，我们将端口号修改为和launch.json中端口号一致即可以启动项目开始调试了</p>
<h1 id="项目封装"><a href="#项目封装" class="headerlink" title="项目封装"></a>项目封装</h1><p>  我们可以将上面的过程封装一下，将上面dll路径中的<code>emmy_core.dll</code>提取出来放入项目的<code>Lua\EmmyLua下</code>然后生成一个新文件<code>EmmyLuaDebuger.lua</code>写入如下代码：<br>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StartEmmyLuaDebuger</span><span class="params">(isUnityConnectIDE)</span></span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">cpath</span> = <span class="built_in">package</span>.<span class="built_in">cpath</span> .. <span class="string">&quot;;Lua/EmmyLua/?.dll&quot;</span></span><br><span class="line">    CS.UnityEngine.Debug.Log(<span class="built_in">package</span>.<span class="built_in">cpath</span>)</span><br><span class="line">    <span class="keyword">local</span> dbg = <span class="built_in">require</span>(<span class="string">&#x27;emmy_core&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> isUnityConnectIDE <span class="keyword">then</span></span><br><span class="line">        dbg.tcpConnect(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9977</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dbg.tcpListen(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9978</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/img3.png" alt="在这里插入图片描述"><br>  在项目挂载的脚本上增加LuaDebugEnabled和LuaDebugUnityConnectIDE两个参数，并在项目运行所有lua代码前执行上面的Lua代码：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> LuaDebugEnabled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> LuaDebugUnityConnectIDE = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mLuaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">        mLuaEnv.AddLoader(handleLoad);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="keyword">if</span> (LuaDebugEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            mLuaEnv.DoString(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;Lua.EmmyLua.EmmyLuaDebuger&quot;</span>));</span><br><span class="line">            <span class="keyword">var</span> startDebugerFunc = mLuaEnv.Global.Get&lt;LuaFunction&gt;(<span class="string">&quot;StartEmmyLuaDebuger&quot;</span>);</span><br><span class="line">            startDebugerFunc.Call(LuaDebugUnityConnectIDE);</span><br><span class="line">            startDebugerFunc.Dispose();</span><br><span class="line">            startDebugerFunc = <span class="literal">null</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        mLuaEnv.DoString(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;Lua.Main&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/img4.png" alt="在这里插入图片描述"><br>  这样便可以在项目中通过Unity界面灵活使用，方便项目开发过程中使用</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>XLua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 指令</title>
    <url>/hexo-%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-创建文章"><a href="#Create-a-new-post-创建文章" class="headerlink" title="Create a new post(创建文章)"></a>Create a new post(创建文章)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server-启动服务器"><a href="#Run-server-启动服务器" class="headerlink" title="Run server(启动服务器)"></a>Run server(启动服务器)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files-生成文件"><a href="#Generate-static-files-生成文件" class="headerlink" title="Generate static files(生成文件)"></a>Generate static files(生成文件)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites-传送远端"><a href="#Deploy-to-remote-sites-传送远端" class="headerlink" title="Deploy to remote sites(传送远端)"></a>Deploy to remote sites(传送远端)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>XLua接入Unity (二) EmmyLua接入(VSCode)</title>
    <url>/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>安装<a href="https://code.visualstudio.com/">VSCode</a></li>
<li>vscode插件栏安装<code>lua</code>插件<br>安装完成以后，便可以打开项目中的Lua文件夹进行Lua代码编写了</li>
</ul>
<h1 id="Lua代码引用关联"><a href="#Lua代码引用关联" class="headerlink" title="Lua代码引用关联"></a>Lua代码引用关联</h1><p>  正常情况下，Lua这种弱类型代码是没办法像强类型代码查看代码引用关系的，需要借助<code>emmylua</code>来帮助建议lua代码之间的引用关联。在vscode插件商店中找到<code>EmmyLua</code>插件，安装好即可以使用了<br>  参考<a href="https://emmylua.github.io/zh_CN/index.html">EmmyLua官方文档</a><br>  如图在设置中设置好显示引用计数，即可以在代码中显示代码引用计数<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img1.png" alt="在这里插入图片描述"></p>
<h1 id="Lua显示UnityAPI提示"><a href="#Lua显示UnityAPI提示" class="headerlink" title="Lua显示UnityAPI提示"></a>Lua显示UnityAPI提示</h1><p>  安装<code>Emmylua-unity</code>插件，这款插件在应用商店中找不到，可以点击链接下载<a href="emmylua-unity-1.0.4.vsix">EmmyLua-Unity</a><br>  在EmmyLua官网找到<a href="https://github.com/EmmyLua/EmmyLua-Unity/blob/master/Unity/Assets/Editor/EmmyLuaService.cs">EmmyLuaService</a>文件放到项目Editor目录下<br>  修改EmmyLuaService中的端口号<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img2.png" alt="在这里插入图片描述"><br>  以及VSCode中的端口号<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img3.png" alt="在这里插入图片描述"><br>  在Unity标签栏中找到EmmyLuaService开启(注意每次改完端口号，都需要重新disable，enable一下)<br>  在VSCode<strong>工作区</strong>中右键点击<strong>pull unity api</strong><br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img4.png" alt="在这里插入图片描述"><br>  即可以看到导入的emmyLualib<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img5.png" alt="在这里插入图片描述"><br>  编写代码时即可以看到UnityAPI的提示<br>  <img src="/XLua%E6%8E%A5%E5%85%A5Unity-(%E4%BA%8C)-EmmyLua%E6%8E%A5%E5%85%A5(VSCode)/img6.png" alt="在这里插入图片描述">  </p>
]]></content>
      <categories>
        <category>技术</category>
        <category>XLua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(一) 功能分工</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%80)-%E5%8A%9F%E8%83%BD%E5%88%86%E5%B7%A5/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  战斗中会涉及各种模块间交互配合，包括战斗流程，角色，相机，地图，飘字等等，如果这些模块全部杂糅在一起，则会使得代码非常臃肿，需要将这些模块解耦，使得关联性较强的代码内聚在一起，提升代码可读性，也方便后续相关功能拓展</p>
<h1 id="场景处理基类"><a href="#场景处理基类" class="headerlink" title="场景处理基类"></a>场景处理基类</h1><p>  设计公有父类<code>SceneProcessorBase</code>代表所有模块的基类<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SceneProcessorBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> prepare(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onPrepare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> init(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.onInit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.onAsyncInit(resolve);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> lateInit(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.onLateInit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.onAsyncLateInit(resolve);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 加载场景的准备 */</span></span><br><span class="line">    <span class="keyword">protected</span> onPrepare(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 初始化 */</span></span><br><span class="line">    <span class="keyword">protected</span> onInit(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 异步初始化 */</span></span><br><span class="line">    <span class="keyword">protected</span> onAsyncInit(onPrepared: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123; onPrepared(); &#125;</span><br><span class="line">    <span class="comment">/** 后初始化 */</span></span><br><span class="line">    <span class="keyword">protected</span> onLateInit(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 异步后初始化 */</span></span><br><span class="line">    <span class="keyword">protected</span> onAsyncLateInit(onPrepared: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123; onPrepared(); &#125;</span><br><span class="line">    <span class="comment">/** 场景初始化后每帧调用 */</span></span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 场景销毁 */</span></span><br><span class="line">    <span class="keyword">protected</span> onDestroy(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="战斗中模块划分"><a href="#战斗中模块划分" class="headerlink" title="战斗中模块划分"></a>战斗中模块划分</h1><p>  将不同模块功能包装成对应的<code>SP(SceneProcessor)</code>，并在BaseScene中封装接口<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseScene</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _d_processors: <span class="built_in">Array</span>&lt;SceneProcessorBase&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 特效 */</span></span><br><span class="line">    <span class="keyword">public</span> effectSP: EffectSP;</span><br><span class="line">    <span class="comment">/** 声音 */</span></span><br><span class="line">    <span class="keyword">public</span> soundSP: SoundSP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 增加基础的sp */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">addBaseProcessors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.soundSP = <span class="built_in">this</span>.addProcessor(SoundSP);</span><br><span class="line">        <span class="built_in">this</span>.effectSP = <span class="built_in">this</span>.addProcessor(EffectSP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加一个sceneProcessor对象（待后续初始化） */</span></span><br><span class="line">    <span class="keyword">public</span> addProcessor&lt;TSceneProcessor <span class="keyword">extends</span> SceneProcessorBase&gt;(ProcessorClass: <span class="keyword">new</span> (arg0: BaseScene): TSceneProcessor): TSceneProcessor &#123;</span><br><span class="line">        <span class="keyword">let</span> sceneProcessor = <span class="keyword">new</span> ProcessorClass(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>._d_processors.push(sceneProcessor);</span><br><span class="line">        sceneProcessor &amp;&amp; sceneProcessor.prepare();</span><br><span class="line">        <span class="keyword">return</span> sceneProcessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化（包含异步）sceneProcessor*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> initProcessors(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> processor <span class="keyword">of</span> <span class="built_in">this</span>._d_processors) &#123;</span><br><span class="line">            <span class="keyword">await</span> processor.init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> processor <span class="keyword">of</span> <span class="built_in">this</span>._d_processors) &#123;</span><br><span class="line">            <span class="keyword">await</span> processor.lateInit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 更新sceneProcessor */</span></span><br><span class="line">    <span class="keyword">public</span> updateProcessors(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> processor <span class="keyword">of</span> <span class="built_in">this</span>._d_processors) &#123;</span><br><span class="line">            processor.update(Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 删除sceneProcessor */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">destroyProcessors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>._d_processors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">let</span> proc = <span class="built_in">this</span>._d_processors[i];</span><br><span class="line">            proc.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._d_processors = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样战斗场景封装好战斗场景内特有的<code>SP(SceneProcessor)</code>，可以有如下的实现：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleScene</span> <span class="keyword">extends</span> <span class="title">BaseScene</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 战斗流程 */</span></span><br><span class="line">    <span class="keyword">public</span> battleSP: BattleSP;</span><br><span class="line">    <span class="comment">/** 战斗中角色 */</span></span><br><span class="line">    <span class="keyword">public</span> battleCharacterSP: BattleCharacterSP;</span><br><span class="line">    <span class="comment">/** 战斗中宝物 */</span></span><br><span class="line">    <span class="keyword">public</span> battleTreasureSP: BattleTreasureSP;</span><br><span class="line">    <span class="comment">/** 战斗中漂浮元素 类似飘字 气泡 血条 */</span></span><br><span class="line">    <span class="keyword">public</span> battleFloatElementSP: BattleFloatElementSP;</span><br><span class="line">    <span class="comment">/** 战斗中地图 */</span></span><br><span class="line">    <span class="keyword">public</span> battleMapSP: BattleMapSP;</span><br><span class="line">    <span class="comment">/** 战斗中相机 */</span></span><br><span class="line">    <span class="keyword">public</span> battleCameraSP: BattleCameraSP;</span><br><span class="line">    <span class="comment">/** 战斗中释放的技能 包括子弹 */</span></span><br><span class="line">    <span class="keyword">public</span> battleActionSP: BattleActionSP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">addBaseProcessors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addBaseProcessors();</span><br><span class="line">        <span class="built_in">this</span>.battleActionSP = <span class="built_in">this</span>.addProcessor(BattleActionSP);</span><br><span class="line">        <span class="built_in">this</span>.battleFloatElementSP = <span class="built_in">this</span>.addProcessor(BattleFloatElementSP);</span><br><span class="line">        <span class="built_in">this</span>.battleSP = <span class="built_in">this</span>.addProcessor(BattleSP);</span><br><span class="line">        <span class="built_in">this</span>.battleCharacterSP = <span class="built_in">this</span>.addProcessor(BattleCharacterSP);</span><br><span class="line">        <span class="built_in">this</span>.battleTreasureSP = <span class="built_in">this</span>.addProcessor(BattleTreasureSP);</span><br><span class="line">        <span class="built_in">this</span>.battleMapSP = <span class="built_in">this</span>.addProcessor(BattleMapSP);</span><br><span class="line">        <span class="built_in">this</span>.battleCameraSP = <span class="built_in">this</span>.addProcessor(BattleCameraSP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样就可以达到功能模块的相互隔离，不同<code>SP(SceneProcessor)</code>之间通过暴露的功能接口相互调用，使得模块内代码内聚。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(七) 角色设计-AI</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%83)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-AI/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  AI模块也是战斗模块中的一个核心模块，是游戏中角色行为的驱动力，考虑项目中其他场景角色也有AI相关的需求，为了提高代码的复用性，需要设计一个通用的AI架构，满足各个场景角色AI的驱动。</p>
<h1 id="AI配置"><a href="#AI配置" class="headerlink" title="AI配置"></a>AI配置</h1><p>  游戏中有各种各样的角色，每个角色会有各种各样的状态，每个角色在不同状态下做出的行为也会不一样，例如A角色<code>IDLE</code>状态是循环的，每次循环50ms，第0秒播放<code>IDLE</code>动画，第20ms播放一个特效，特效名为”XXX”，B角色<code>IDLE</code>状态是循环的，每次循环60ms，第0秒播放<code>IDLE_HAPPY</code>动画，第30ms播放一个声音，音乐名为”YYY”，这样的表现一般会需要类似如下的配置：<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">A : &#123;</span><br><span class="line">	<span class="attr">&quot;AIState&quot;</span>: <span class="string">&quot;Idle&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;IsLoop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">&quot;TotalTime&quot;</span>: <span class="number">50</span>,</span><br><span class="line">	<span class="attr">&quot;EventList&quot;</span>: [&#123;</span><br><span class="line">			<span class="attr">&quot;TriggerTime&quot;</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">&quot;EventType&quot;</span>: <span class="string">&quot;PlayAnim&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;EventData&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;AnimName&quot;</span>: <span class="string">&quot;IDLE&quot;</span>,</span><br><span class="line">			&#125;&#125;,&#123;</span><br><span class="line">			<span class="attr">&quot;TriggerTime&quot;</span>: <span class="number">20</span>,</span><br><span class="line">			<span class="attr">&quot;EventType&quot;</span>: <span class="string">&quot;PlayEffect&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;EventData&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;EffectName&quot;</span>: <span class="string">&quot;XXX&quot;</span>,</span><br><span class="line">			&#125;&#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">B : &#123;</span><br><span class="line">	<span class="attr">&quot;AIState&quot;</span>: <span class="string">&quot;Idle&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;IsLoop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">&quot;TotalTime&quot;</span>: <span class="number">60</span>,</span><br><span class="line">	<span class="attr">&quot;EventList&quot;</span>: [&#123;</span><br><span class="line">			<span class="attr">&quot;TriggerTime&quot;</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">&quot;EventType&quot;</span>: <span class="string">&quot;PlayAnim&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;EventData&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;AnimName&quot;</span>: <span class="string">&quot;IDLE_HAPPY&quot;</span>,</span><br><span class="line">			&#125;&#125;,&#123;</span><br><span class="line">			<span class="attr">&quot;TriggerTime&quot;</span>: <span class="number">30</span>,</span><br><span class="line">			<span class="attr">&quot;EventType&quot;</span>: <span class="string">&quot;PlaySound&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;EventData&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;SoundName&quot;</span>: <span class="string">&quot;YYY&quot;</span>,</span><br><span class="line">			&#125;&#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>  通过配置不同角色各种状态下所做的行为，在进入某个状态后，读取该状态下的配置信息，按时间顺序依次做出配置的行为。</p>
<h1 id="角色状态基础"><a href="#角色状态基础" class="headerlink" title="角色状态基础"></a>角色状态基础</h1><p>  不同状态下，角色不仅要执行配置中所设置的行为（播放动作，播放特效，播放声音，释放技能等等），还需要执行游戏逻辑中实时需要进行的行为，如战斗中<code>RUN</code>状态下，需要不停向目标移动，直至目标到达攻击范围为止。这种情况下，可以用<code>状态模式</code>将不同状态解耦。<br>  通过定义公共父类<code>BaseAIState</code>，衍生出<code>BattleIdleState</code>，<code>BattleRunState</code>，<code>BattleAttackState</code>等等，子类只需要复写生命周期函数即可。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAIState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 配置的信息 */</span></span><br><span class="line">    <span class="keyword">protected</span> aiStateConfig: CharAIStateCfg;</span><br><span class="line">    <span class="comment">/** 标记一个State已经执行的时间 */</span></span><br><span class="line">    <span class="keyword">protected</span> curAIStateTime: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 标记当前Event的索引-&gt;跟随State的生命周期++ */</span></span><br><span class="line">    <span class="keyword">protected</span> curEventIndex: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 标记一个State执行完毕，进行对应的State完结处理 */</span></span><br><span class="line">    <span class="keyword">protected</span> curAIStateFinished: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> init(args?: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onInit.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> reset(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curAIStateTime = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.curEventIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.curAIStateFinished = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.onReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 传进来的是毫秒 */</span></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> nextStateTime: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> delta: <span class="built_in">number</span> = dt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.curAIStateTime + dt &gt;= <span class="built_in">this</span>.aiStateConfig.TotalTime) &#123;</span><br><span class="line">            dt = <span class="built_in">this</span>.aiStateConfig.TotalTime - <span class="built_in">this</span>.curAIStateTime;</span><br><span class="line">            nextStateTime = delta - dt;</span><br><span class="line">            <span class="built_in">this</span>.curAIStateFinished = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.curAIStateTime += dt;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt * <span class="number">0.001</span>);</span><br><span class="line">        <span class="built_in">this</span>._processEventList();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.curAIStateFinished) &#123;</span><br><span class="line">            <span class="built_in">this</span>._processStateFinish(nextStateTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 只有创建的时候才执行 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onInit</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 每次重置都会执行 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onReset</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 更新时候执行 */</span></span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">    <span class="comment">/** 销毁时候执行 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processEventList(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">/** 只触发一次事件 */</span></span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">this</span>.curEventIndex &lt; <span class="built_in">this</span>.aiStateConfig.EventList.length; ++<span class="built_in">this</span>.curEventIndex) &#123;</span><br><span class="line">            <span class="keyword">let</span> evtCfg = <span class="built_in">this</span>.aiStateConfig.EventList[<span class="built_in">this</span>.curEventIndex];</span><br><span class="line">            <span class="keyword">if</span> (evtCfg.TriggerTime &lt; <span class="built_in">this</span>.curAIStateTime) &#123;</span><br><span class="line">                <span class="comment">// 执行事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** State结束时执行 */</span></span><br><span class="line">    <span class="keyword">private</span> _processStateFinish(nextStateTime: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前State是loop的，就继续执行当前的State</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.aiStateConfig.IsLoop) &#123;</span><br><span class="line">            <span class="built_in">this</span>.character.aiComp.setAIState(<span class="built_in">this</span>.aiStateConfig.AIState, nextStateTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前State不是loop的，但是有相应的FollowState，就执行相应该FollowState</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.aiStateConfig.FollowState !== EAIState.Invalid) &#123;</span><br><span class="line">            <span class="built_in">this</span>.character.aiComp.setAIState(<span class="built_in">this</span>.aiStateConfig.FollowState, nextStateTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="角色AI组件"><a href="#角色AI组件" class="headerlink" title="角色AI组件"></a>角色AI组件</h1><p>  在此基础上，角色AI组件需要管理AI状态的生命周期，提供AI状态创建，AI状态切换等功能<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个AIState单元 对应idle run... */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CharAIStateCfg &#123;</span><br><span class="line">    <span class="comment">/** ID */</span></span><br><span class="line">    <span class="keyword">readonly</span> ID: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">/** 状态 */</span></span><br><span class="line">    <span class="keyword">readonly</span> AIState: EAIState;</span><br><span class="line">    <span class="comment">/** 是否循环 */</span></span><br><span class="line">    <span class="keyword">readonly</span> IsLoop: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 总时间(ms) */</span></span><br><span class="line">    <span class="keyword">readonly</span> TotalTime: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 非loop动作播完，必定跟随有的state */</span></span><br><span class="line">    <span class="keyword">readonly</span> FollowState: EAIState;</span><br><span class="line">    <span class="comment">/** ActionEvent列表 */</span></span><br><span class="line">    <span class="keyword">readonly</span> EventList: <span class="built_in">Array</span>&lt;CharActionEventCfg&gt;;</span><br><span class="line">    <span class="comment">/** Action列表 */</span></span><br><span class="line">    <span class="keyword">readonly</span> ActionList: <span class="built_in">Array</span>&lt;CharActionCfg&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharAIComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 当前角色对应的State组 */</span></span><br><span class="line">  <span class="keyword">private</span> _aiCfgGroup: Record&lt;<span class="built_in">string</span>, CharAIStateCfg&gt;;</span><br><span class="line">  <span class="comment">/** 当前角色的AIState */</span></span><br><span class="line">  <span class="keyword">private</span> _curAIState: BaseAIState;</span><br><span class="line">  <span class="comment">/** 角色上一次AIState */</span></span><br><span class="line">  <span class="keyword">private</span> _lastAIState: BaseAIState;</span><br><span class="line">  <span class="comment">/** 已执行的总时间 */</span></span><br><span class="line">  <span class="keyword">private</span> _totalTime: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>._curAIState) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> t1: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>._totalTime * <span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">this</span>._totalTime += dt;</span><br><span class="line">      <span class="keyword">let</span> t2: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>._totalTime * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>._curAIState.update(t2 - t1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 切换为目标State</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> setAIState(aiState: <span class="built_in">string</span>, <span class="attr">nextStateTime</span>: <span class="built_in">number</span> = <span class="number">0</span>, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> aiStateCfg: CharAIStateCfg = <span class="built_in">this</span>._aiCfgGroup[aiState];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>._curAIState) &#123;</span><br><span class="line">          <span class="built_in">this</span>._lastAIState = <span class="built_in">this</span>._curAIState;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>._lastAIState || <span class="built_in">this</span>._lastAIState.aiStateConfig.AIState !== aiStateCfg.AIState) &#123;</span><br><span class="line">          <span class="built_in">this</span>._curAIState &amp;&amp; <span class="built_in">this</span>._curAIState.destroy();</span><br><span class="line">          <span class="keyword">switch</span> (aiStateCfg.AIState) &#123;</span><br><span class="line">              <span class="keyword">case</span> EAIState.BattleIdle:</span><br><span class="line">                  <span class="built_in">this</span>._curAIState = <span class="keyword">new</span> BattleIdleState(<span class="built_in">this</span>.character, aiStateCfg);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> EAIState.BattleRun:</span><br><span class="line">                  <span class="built_in">this</span>._curAIState = <span class="keyword">new</span> BattleRunState(<span class="built_in">this</span>.character, aiStateCfg);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> EAIState.BattleAttack:</span><br><span class="line">                  <span class="built_in">this</span>._curAIState = <span class="keyword">new</span> BattleAttackState(<span class="built_in">this</span>.character, aiStateCfg);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">// 其他状态</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">this</span>._curAIState &amp;&amp; <span class="built_in">this</span>._curAIState.init(args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>._curAIState &amp;&amp; <span class="built_in">this</span>._curAIState.reset();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextStateTime &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">this</span>._curAIState.update(nextStateTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="状态间切换"><a href="#状态间切换" class="headerlink" title="状态间切换"></a>状态间切换</h1><p>  在现有机制下，状态间切换只需要在每个子类onUpdate中，通过判断切换即可，可能会产生如下的代码<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AState</span> <span class="keyword">extends</span> <span class="title">BaseAIState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">/** 满足切换b状态条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (canChangeBState) &#123;</span><br><span class="line">            <span class="built_in">this</span>.character.aiComp.setAIState(EAIState.BState, dt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他满足状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 满足切换c状态条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (canChangeCState) &#123;</span><br><span class="line">            <span class="built_in">this</span>.character.aiComp.setAIState(EAIState.CState, dt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行A状态下应该干的事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  对于战斗中这种各状态切换之间条件比较明显的，可以在项目中用统一的状态切换限制，<br>  例如 BattleIdle - BattleRun - BattleAttack - BattleSkill - BattleFailed - BattleVictory<br>  这一套状态间切换通用普通角色和普通副本怪，即使战斗中有Boss的需求 也可以 额外产生<br>  例如 BossAppearance - BossIdle - BossAttack - BossSkill - BossFailed - BossVictory这样一套状态通用所有Boss，这样的成本在项目中并不算高。</p>
<h1 id="引入行为树"><a href="#引入行为树" class="headerlink" title="引入行为树"></a>引入行为树</h1><p>  上面的设计可以满足放置类游戏中战斗中角色AI需求，对于稍微复杂一点的角色AI需求，便很难满足了，或者说需要很多套状态来支持，有时候需要为一个角色专门定制一套状态，显然不是很合理，例如在其他场景中，有如下需求：A角色比较懒，在白天喜欢躲起来睡觉。B角色比较活泼，在人多的敌方喜欢跳舞。这种类似的SleepState， DanceState，只针对某些特定的角色生效，显然不适合在所有角色的状态判断切换时出现，这个时候我们希望能够为每个角色定制一份状态切换的配置，让角色在判断状态切换时读取这份配置进行各状态之间的切换，这样的话，我们需要修改BaseAIState，引入类似行为树的设计理念。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 传进来的是毫秒 */</span></span><br><span class="line"><span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nextStateTime: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> delta: <span class="built_in">number</span> = dt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.curAIStateTime + dt &gt;= <span class="built_in">this</span>.aiStateConfig.TotalTime) &#123;</span><br><span class="line">        dt = <span class="built_in">this</span>.aiStateConfig.TotalTime - <span class="built_in">this</span>.curAIStateTime;</span><br><span class="line">        nextStateTime = delta - dt;</span><br><span class="line">        <span class="built_in">this</span>.curAIStateFinished = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.curAIStateTime += dt;</span><br><span class="line">    <span class="keyword">let</span> aiState = <span class="built_in">this</span>.getChangeState();</span><br><span class="line">    <span class="keyword">if</span> (aiState &amp;&amp; aiState !== EAIState.Invalid) &#123;</span><br><span class="line">        <span class="built_in">this</span>.changeAIState(aiState, delta, <span class="literal">true</span>, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt * <span class="number">0.001</span>);</span><br><span class="line">        <span class="built_in">this</span>._processEventList();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.curAIStateFinished) &#123;</span><br><span class="line">            <span class="built_in">this</span>._processStateFinish(nextStateTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> changeAIState(aiState: EAIState, <span class="attr">nextStateTime</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.character.aiComp.setAIState(aiState, nextStateTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> getChangeState(): EAIState &#123; <span class="keyword">return</span> EAIState.Invalid; &#125;</span><br></pre></td></tr></table></figure><br>  只需要对update加一点处理，引入getChangeState，这样一个可能的AState代码如下：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AState</span> <span class="keyword">extends</span> <span class="title">BaseAIState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override getChangeState(): EAIState &#123;</span><br><span class="line">        <span class="comment">/** 满足切换b状态条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (canChangeBState) &#123;</span><br><span class="line">            <span class="keyword">return</span> EAIState.BState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他满足状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 满足切换c状态条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (canChangeCState) &#123;</span><br><span class="line">            <span class="keyword">return</span> EAIState.CState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EAIState.Invalid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 执行A状态下应该干的事</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%83)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-AI/img1.png" alt="在这里插入图片描述"><br>  如图所示，getChangeState函数如同一颗根节点是AState的<code>行为树</code>，每个<code>if条件</code>都如同行为树上的分叉，对于没有显式的写明结果的叶子节点都用Invalid填补代表AState，这样对于复杂AI需求的时候，可以将判断条件写入配置，可能会有如下代码：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AState</span> <span class="keyword">extends</span> <span class="title">BaseAIState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override getChangeState(): EAIState &#123;</span><br><span class="line">        <span class="comment">/** 判断A状态下的所有配置条件是否满足 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; StateChangeList.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StateChangeList[i].Condition) &#123;</span><br><span class="line">                <span class="keyword">return</span> StateChangeList[i].ChangeState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EAIState.Invalid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样可以分别给两个角色A状态配置如下的配置：<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">A : &#123;</span><br><span class="line">    <span class="attr">&quot;AIState&quot;</span>: <span class="string">&quot;AState&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;IsLoop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;TotalTime&quot;</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">&quot;StateChangeList&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: <span class="string">&quot;CheckBState&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ChangeState&quot;</span>: <span class="string">&quot;BState&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: <span class="string">&quot;CheckCState&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ChangeState&quot;</span>: <span class="string">&quot;CState&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">A : &#123;</span><br><span class="line">    <span class="attr">&quot;AIState&quot;</span>: <span class="string">&quot;AState&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;IsLoop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;TotalTime&quot;</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">&quot;StateChangeList&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: <span class="string">&quot;CheckDState&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ChangeState&quot;</span>: <span class="string">&quot;DState&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: <span class="string">&quot;CheckEState&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ChangeState&quot;</span>: <span class="string">&quot;EState&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样只需要在代码中分别实现对应的Check函数，即可以达到给不同角色AState设置不同的行为树，这样之前说的A角色喜欢睡觉配置中配上CheckSleep，B角色喜欢跳舞配置中配上CheckDance即可</p>
<h1 id="状态和配置关系"><a href="#状态和配置关系" class="headerlink" title="状态和配置关系"></a>状态和配置关系</h1><p>  在目前项目中还有一个设计，比如角色1-30级用A技能，30-60级用B技能，60-90级用C技能，策划会在技能配置中配有3个技能的配置，这里的话需要明确配置和状态之间的关系，一个状态可以对应多份配置，一份配置会绑定一个状态，上述例子中，不管A，B，C哪个技能都是BattleSkillState，只需要在进入BattleSkillState时，判断角色等级去读取对应的配置即可，可能有的代码如下：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> override changeAIState(aiState: EAIState, <span class="attr">nextStateTime</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> aiStateKey: <span class="built_in">string</span> = aiState;</span><br><span class="line">	<span class="keyword">if</span> (aiState === EAIState.BattleAttack) &#123;</span><br><span class="line">		<span class="comment">// 根据等级读取普攻配置</span></span><br><span class="line">		aiStateKey = attackDef.AICfg;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (aiState === EAIState.BattleSkill) &#123;</span><br><span class="line">		<span class="comment">// 根据等级读取技能配置</span></span><br><span class="line">		aiStateKey = skillDef.AICfg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.character.aiComp.setAIState(aiStateKey, nextStateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>  角色AI模块的很多拓展都需要根据项目实际需求出发，例如战斗中可以抽象一层<code>BaseBattleAIState</code>继承<code>BaseAIState</code>用于处理所有战斗状态中的通用逻辑，随着项目迭代，框架也会不断迭代。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(三) 角色管理</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%89)-%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  战斗中会有各种各样的角色，从角色站边类型上有我方单位，敌方单位，中立单位等等，从角色定位上来有玩家养成角色，普通小怪，精英怪，boss，召唤物等等，需要在战斗中对他们进行一定的区分。</p>
<h1 id="角色定位设计"><a href="#角色定位设计" class="headerlink" title="角色定位设计"></a>角色定位设计</h1><p>  为了战斗中方便判断角色的定位，可以将上述两个维度合起来用位运算加以判断，如<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 战斗单位类型 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> BattleSideType &#123;</span><br><span class="line">  <span class="comment">/** 我方角色 */</span></span><br><span class="line">  Player = <span class="number">1</span>,</span><br><span class="line">  <span class="comment">/** 敌方角色 */</span></span><br><span class="line">  Enemy = <span class="number">2</span>,</span><br><span class="line">  <span class="comment">/** boss */</span></span><br><span class="line">  Boss = <span class="number">4</span>,</span><br><span class="line">  <span class="comment">/** 召唤角色 */</span></span><br><span class="line">  Summon = <span class="number">8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  设计BattleCharacter<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCharacter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 角色类型 */</span></span><br><span class="line">  <span class="keyword">private</span> _sideType: BattleSideType;</span><br><span class="line">  <span class="comment">/** 是否我方角色 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isPlayerSide</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> (<span class="built_in">this</span>._sideType &amp; BattleSideType.Player) &gt; <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="comment">/** 是否boss */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isBoss</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> (<span class="built_in">this</span>._sideType &amp; BattleSideType.Boss) &gt; <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="comment">/** 是否召唤物 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isSummon</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> (<span class="built_in">this</span>._sideType &amp; BattleSideType.Summon) &gt; <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">sideType</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>._sideType; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样通过位运算即可以达到战斗中对角色定位的判断</p>
<h1 id="角色管理设计"><a href="#角色管理设计" class="headerlink" title="角色管理设计"></a>角色管理设计</h1><p>  战斗中角色的生成，更新，销毁等管理，需要有一个统一调度的敌方，将BattleCharacterSP设计成角色工厂和角色容器，提供createBattleCharacter接口给外部调用，并在内部update中对生成的角色进行管理。<br>  BattleCharacterSP承担了角色创建工厂功能，以及内部管理角色的生成，更新，销毁，战斗中创建角色时，只需要调度接口即可。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCharacterSP</span> <span class="keyword">extends</span> <span class="title">SceneProcessorBase</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 我方角色列表 */</span></span><br><span class="line">    <span class="keyword">public</span> playerSideList: <span class="built_in">Array</span>&lt;BattleCharacter&gt; = [];</span><br><span class="line">    <span class="comment">/** 敌方角色列表 */</span></span><br><span class="line">    <span class="keyword">public</span> enemySideList: <span class="built_in">Array</span>&lt;BattleCharacter&gt; = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.playerSideList = [];</span><br><span class="line">        <span class="built_in">this</span>.enemySideList = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> createBattleCharacter(): BattleCharacter &#123;</span><br><span class="line">        <span class="comment">// 省略细节</span></span><br><span class="line">        <span class="keyword">if</span> (character.isPlayerSide) &#123;</span><br><span class="line">            <span class="built_in">this</span>.playerSideList.push(character);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.enemySideList.push(character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 更新所有角色，有角色死亡移除角色 抛出事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁所有角色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(九) 角色设计-战斗技能</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B9%9D)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  技能模块也是角色比较核心的模块，不同游戏技能释放机制不一样，有的游戏是根据技能cd释放，有的游戏是有多个技能按照一定顺序组合依次释放，不过都大同小异，技能模块主要也是管理技能的释放，具体技能的实现机制会在后面章节中具体阐述。</p>
<h1 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h1><p>  目前项目中的每个友方角色会有一个普攻和一个技能，普攻释放完就会刷新普攻cd，技能完整释放完才会刷新cd，每个怪物角色会有一个普攻和若干技能，哪个技能cd好了就释放该技能。</p>
<h1 id="技能基础"><a href="#技能基础" class="headerlink" title="技能基础"></a>技能基础</h1><p>  普攻也是技能的一种，只是释放时机不一样，可以理解为一个特殊的技能，所以可以设计出一个共有的CharBattleSkillInfo用来管理每个技能的信息，包括技能cd，技能等级等等。<br>  这里只是根据项目本身做了一些设计，技能组件的拓展形式有很多种，具体设计还需要结合项目实际情况分析，能够做到管理好技能的释放，使角色进入技能状态即可。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleSkillInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 技能等级 */</span></span><br><span class="line">    <span class="keyword">private</span> _skillLv: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 技能表数据 */</span></span><br><span class="line">    <span class="keyword">private</span> _skillDef: SkillDefine;</span><br><span class="line">    <span class="comment">/** cd */</span></span><br><span class="line">    <span class="keyword">private</span> _coolDown: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 总cd */</span></span><br><span class="line">    <span class="keyword">private</span> _totalCoolDown: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">skillID: <span class="built_in">number</span>, skillLv: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据id读取技能配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">update</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._coolDown &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._coolDown = <span class="built_in">this</span>._coolDown &gt; dt ? <span class="built_in">this</span>._coolDown - dt : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> resetCoolDown(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._coolDown = <span class="built_in">this</span>._skillDef.CoolDown;</span><br><span class="line">        <span class="built_in">this</span>._totalCoolDown = <span class="built_in">this</span>._skillDef.CoolDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">coolDown</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._coolDown; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">inCoolDown</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._coolDown &gt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">coolDownPer</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._totalCoolDown &gt; <span class="number">0</span> ? <span class="built_in">this</span>._coolDown / <span class="built_in">this</span>._totalCoolDown : <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">skillDef</span>(): <span class="title">SkillDefine</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._skillDef; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">skillLv</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._skillLv; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="基础技能组件"><a href="#基础技能组件" class="headerlink" title="基础技能组件"></a>基础技能组件</h1><p>  由于有单技能和多技能的设定，相同点是都有普攻，所以可以先设计有普攻的基础技能组件<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleSkillComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 默认普攻 */</span></span><br><span class="line">    <span class="keyword">private</span> _defaultAttackInfo: CharBattleSkillInfo;</span><br><span class="line">    <span class="comment">/** 临时替换的普攻 */</span></span><br><span class="line">    <span class="keyword">private</span> _tempAttackInfo: CharBattleSkillInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(attackID: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化默认普攻</span></span><br><span class="line">        <span class="built_in">this</span>._defaultAttackInfo = <span class="keyword">new</span> CharBattleSkillInfo(attackID);</span><br><span class="line">        <span class="built_in">this</span>.resetAttackInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 判断自动战斗 释放技能 （省略细节）</span></span><br><span class="line">        <span class="built_in">this</span>.attackInfo.update(dt);</span><br><span class="line">        <span class="built_in">this</span>.onSkillUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> setTempAttackInfo(attackInfo: CharBattleSkillInfo): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._tempAttackInfo = attackInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> resetAttackInfo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attackInfo &amp;&amp; <span class="built_in">this</span>.attackInfo.resetCoolDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 释放技能 */</span></span><br><span class="line">    <span class="keyword">public</span> enterSkill(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 退出技能 */</span></span><br><span class="line">    <span class="keyword">public</span> exitSkill(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 判断技能能否释放 */</span></span><br><span class="line">    <span class="keyword">public</span> judgeCanCastSkill(isAuto: <span class="built_in">boolean</span> = <span class="literal">false</span>): <span class="built_in">boolean</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onSkillUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前的技能信息 由子类实现 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">get</span> <span class="title">curSkillInfo</span>(): <span class="title">CharBattleSkillInfo</span>;</span><br><span class="line">    /** 有临时普攻用临时普攻 */</span><br><span class="line">    <span class="title">public</span> <span class="title">get</span> <span class="title">attackInfo</span>(): <span class="title">CharBattleSkillInfo</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._tempAttackInfo ? <span class="built_in">this</span>._tempAttackInfo : <span class="built_in">this</span>._defaultAttackInfo; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里由于有战斗中变身技能替换普攻，所以设置了临时普攻，读取时判断是否有临时普攻即可</p>
<h1 id="组件拓展"><a href="#组件拓展" class="headerlink" title="组件拓展"></a>组件拓展</h1><h2 id="单技能组件"><a href="#单技能组件" class="headerlink" title="单技能组件"></a>单技能组件</h2><p>  单技能组件直接根据传入的技能的信息初始化即可<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleSingleSkillComponent</span> <span class="keyword">extends</span> <span class="title">CharBattleSkillComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _curSkillInfo: CharBattleSkillInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(attackDef: SkillDefine, skillID?: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onInit(attackDef);</span><br><span class="line">        <span class="comment">// 初始化技能 （省略细节）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onSkillUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._curSkillInfo &amp;&amp; <span class="built_in">this</span>._curSkillInfo.update(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回唯一拥有的技能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">curSkillInfo</span>(): <span class="title">CharBattleSkillInfo</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._curSkillInfo; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多技能组件"><a href="#多技能组件" class="headerlink" title="多技能组件"></a>多技能组件</h2><p>  多技能组件传入的是技能数组，需要实时数显寻找cd最少的作为当前技能<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleMultiSkillComponent</span> <span class="keyword">extends</span> <span class="title">CharBattleSkillComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _allSkillInfos: <span class="built_in">Array</span>&lt;CharBattleSkillInfo&gt;;</span><br><span class="line">    <span class="keyword">private</span> _minCDSkillInfo: CharBattleSkillInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(attackID: <span class="built_in">number</span>, skillIDs?: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onInit(attackID);</span><br><span class="line">        <span class="comment">// 初始化所有技能（省略细节）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onSkillUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 更新所有技能cd并选出技能cd最短的技能 （省略细节）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回技能cd最短的技能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">curSkillInfo</span>(): <span class="title">CharBattleSkillInfo</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._minCDSkillInfo; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h1><p>除此之外，还有一些其他技能相关的都可以放入技能组件中，比如技能当中一些位移信息，传送信息等等<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CharSkillMoveInfo = &#123;</span><br><span class="line">  <span class="comment">/** 速度 */</span></span><br><span class="line">  speed?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 方向 */</span></span><br><span class="line">  direction?: Vector3;</span><br><span class="line">  <span class="comment">/** 加速度 */</span></span><br><span class="line">  moveAcc?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 移动时间 */</span></span><br><span class="line">  moveTime?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 移向目标 */</span></span><br><span class="line">  isMoveToTarget?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> setSkillMoveInfo(moveInfo: CharSkillMoveInfo): <span class="built_in">void</span> &#123;</span><br><span class="line">    moveInfo &amp;&amp; (notNull(moveInfo.speed) || (moveInfo.speed = <span class="built_in">this</span>.character.battleMoveComp.speed));</span><br><span class="line">    moveInfo &amp;&amp; (notNull(moveInfo.moveAcc) || (moveInfo.moveAcc = <span class="number">0</span>));</span><br><span class="line">    moveInfo &amp;&amp; (notNull(moveInfo.direction) || (moveInfo.direction = <span class="built_in">this</span>.character.battleMoveComp.direction));</span><br><span class="line">    moveInfo &amp;&amp; (notNull(moveInfo.moveTime) || (moveInfo.moveTime = <span class="number">0</span>));</span><br><span class="line">    moveInfo &amp;&amp; (notNull(moveInfo.isMoveToTarget) || (moveInfo.isMoveToTarget = <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">this</span>._skillMoveInfo = moveInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CharSkillTeleportInfo = &#123;</span><br><span class="line">  <span class="comment">/** 上次传送位置 */</span></span><br><span class="line">  lastPos?: Vector3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> setSkillTeleportInfo(teleportInfo: CharSkillTeleportInfo): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._skillTeleportInfo = teleportInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二) 战斗管理</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C)-%E6%88%98%E6%96%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  卡牌类游戏中会有各种战斗模式，包括PVE模式：推进式刷怪副本，塔防类副本等等，PVP模式：5v5，15v15等等，每种战斗模式的流程不一样，战斗胜利失败条件等等都不一样，需要将这些战斗模式组织好关系。</p>
<h1 id="基础战斗设计"><a href="#基础战斗设计" class="headerlink" title="基础战斗设计"></a>基础战斗设计</h1><p>  设计BaseBattle代表所有战斗类型的基类，将所有类型战斗都需要的信息放在基类里，比如战斗加载场景资源名（pve一般跟随章节表格，pvp一般固定几张地图），战斗限制时间，战斗是否结束等等。<br>  其他战斗类型战斗继承BaseBattle，复写BaseBattle中生命周期的函数，即可以实现不同战斗类型下战斗流程各自的管理<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBattle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 战斗是否自动 */</span></span><br><span class="line">    <span class="keyword">private</span> _isAuto: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/** 战斗倍速 */</span></span><br><span class="line">    <span class="keyword">private</span> _curSpeed: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 准备资源 */</span></span><br><span class="line">    <span class="keyword">public</span> prepare(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onPrepare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> start(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.battleEnd)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">handleCharacterDying</span>(<span class="params">character: BattleCharacter</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onHandleCharacterDying(character);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">handleCharacterDie</span>(<span class="params">character: BattleCharacter</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onHandleCharacterDie(character);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 准备资源 */</span></span><br><span class="line">    <span class="keyword">protected</span> onPrepare(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">    <span class="comment">/** 战斗开始 */</span></span><br><span class="line">    <span class="keyword">protected</span> onStart(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 战斗更新 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123; &#125;;</span><br><span class="line">    <span class="comment">/** 战斗销毁 */</span></span><br><span class="line">    <span class="keyword">protected</span> onDestroy(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 有角色血量归零播放死亡动作时候处理 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onHandleCharacterDying</span>(<span class="params">character: BattleCharacter</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 有角色从战场移除以后处理 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onHandleCharacterDie</span>(<span class="params">character: BattleCharacter</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 战斗场景ID */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> resID: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">/** 战斗是否结束 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> battleEnd: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 战斗类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> battleType: BattleType;</span><br><span class="line">    <span class="comment">/** 战斗限制时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> limitTime: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 战场的位置 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">position</span>(): <span class="title">Vector3</span> &#123; <span class="keyword">return</span> Vector3.zero; &#125;</span><br><span class="line">    <span class="comment">/** 是否强制自动战斗 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">forceAuto</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="战斗创建设计"><a href="#战斗创建设计" class="headerlink" title="战斗创建设计"></a>战斗创建设计</h1><p>  在BattleSP中根据服务器传来的数据判断开启不同的战斗，并在自己的生命周期中对开启的战斗进行调度即可。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleSP</span> <span class="keyword">extends</span> <span class="title">SceneProcessorBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _curBattle: BaseBattle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onPrepare(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">/** 后端验证后开启的战斗信息 */</span></span><br><span class="line">      <span class="keyword">let</span> curBattleInfo;</span><br><span class="line">      <span class="comment">// 省略细节</span></span><br><span class="line">      <span class="keyword">if</span> (curBattleInfo.type === BattleType.Adventure) &#123;</span><br><span class="line">          <span class="built_in">this</span>._curBattle = <span class="keyword">new</span> AdventureBattle(<span class="built_in">this</span>, curBattleInfo);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curBattleInfo.type === BattleType.Explore) &#123;</span><br><span class="line">          <span class="built_in">this</span>._curBattle = <span class="keyword">new</span> ExploreBattle(<span class="built_in">this</span>, curBattleInfo);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curBattleInfo.type === BattleType.Arena) &#123;</span><br><span class="line">          <span class="built_in">this</span>._curBattle = <span class="keyword">new</span> ArenaBattle(<span class="built_in">this</span>, curBattleInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>._curBattle.prepare();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onLateInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._curBattle.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override <span class="function"><span class="title">onUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._curBattle.update(dt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._curBattle.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">curBattle</span>(): <span class="title">BaseBattle</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._curBattle; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二十) 技能设计-Action攻击实体</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%94%BB%E5%87%BB%E5%AE%9E%E4%BD%93/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从前文中可以看出，<code>Entity</code>（攻击实体）在<code>Action</code>中由<code>Emit</code>产生，用于搜集目标单位，下面主要讲一些<code>Entity</code>的实现。</p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>  和<code>Emit</code>设计一样，通过几个游戏中常见的技能，根据这些技能来设计<code>Entity</code></p>
<ul>
<li>战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。</li>
<li>剑士用手上的剑，朝前方发射一道刀光，刀光向前推进，被刀光打中的敌方单位都会受到伤害。</li>
<li>刺客朝着生命值最低的敌方单位扔了一把匕首，匕首打到瞄准的单位后造成伤害。</li>
<li>弓箭手朝着前方射了一只箭，箭会击中最先碰到的敌方单位并造成伤害（没碰到则一定时间后消失）。</li>
</ul>
<p>  从<code>Entity</code>角度简单分析上面列举的几个技能，会发现有些<code>Entity</code>是在同一帧搜集目标单位（挥舞的刀碰到的敌人），有些<code>Entity</code>会移动并在移动过程中搜集敌人（移动的刀光碰到的敌人），有些<code>Entity</code>会朝着事先设定好的目标移动直到碰到敌人为止（刺客扔出指定目标的匕首），有些<code>Entity</code>会带有物理碰撞，可以碰到第一个可被视为目标的单位（弓箭手射出的箭）。当然还有很多其他的技能，根据这些信息下面来设计基础的<code>Entity</code>。</p>
<h1 id="实体设计"><a href="#实体设计" class="headerlink" title="实体设计"></a>实体设计</h1><h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><p>  战斗中，实体需要根据一些规则确定目标单位，同样继承<code>IBattleTargetCfg</code><br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IEntityCfg <span class="keyword">extends</span> IBattleTargetCfg &#123;</span><br><span class="line">   <span class="comment">/** 实体生效的延迟时间，如定时炸弹 */</span></span><br><span class="line">   <span class="keyword">readonly</span> Delay: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实体实现"><a href="#实体实现" class="headerlink" title="实体实现"></a>实体实现</h2>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span>&lt;<span class="title">TEntityCfg</span> <span class="keyword">extends</span> <span class="title">IEntityCfg</span> </span>= IEntityCfg&gt; &#123;</span><br><span class="line">    <span class="comment">/** 实体所属Action */</span></span><br><span class="line">    <span class="keyword">private</span> b_action: BaseBattleAction;</span><br><span class="line">    <span class="comment">/** 实体配置 */</span></span><br><span class="line">    <span class="keyword">private</span> b_entityCfg: TEntityCfg;</span><br><span class="line">    <span class="comment">/** 实体延迟发射时间 */</span></span><br><span class="line">    <span class="keyword">private</span> b_delayTime: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 实体创建结束 */</span></span><br><span class="line">    <span class="keyword">private</span> b_buildFinished: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 实体死亡 */</span></span><br><span class="line">    <span class="keyword">private</span> b_isEntityDead: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 实体初始位置 */</span></span><br><span class="line">    <span class="keyword">protected</span> startPosition: Vector3;</span><br><span class="line">    <span class="comment">/** 实体初始方向 */</span></span><br><span class="line">    <span class="keyword">protected</span> startDirection: Vector3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">action: BaseBattleAction</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_action = action;</span><br><span class="line">        <span class="built_in">this</span>.b_entityCfg = action.actionCfg.EntityProperty <span class="keyword">as</span> TEntityCfg;</span><br><span class="line">        <span class="built_in">this</span>.b_isEntityDead = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.b_delayTime = <span class="built_in">this</span>.entityCfg.Delay;</span><br><span class="line">        <span class="built_in">this</span>.b_buildFinished = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> init(startPosition: Vector3, <span class="attr">startDirection</span>: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startPosition = startPosition;</span><br><span class="line">        <span class="built_in">this</span>.startDirection = startDirection;</span><br><span class="line">        <span class="built_in">this</span>.onInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> dispose(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setEntityDead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">/** 延迟规定时间后创建实体 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEntityDead) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.b_delayTime &gt; dt) &#123;</span><br><span class="line">            <span class="built_in">this</span>.b_delayTime -= dt;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.b_buildFinished) &#123;</span><br><span class="line">            <span class="built_in">this</span>.b_buildFinished = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.onBuildEntity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 寻找一组敌人 */</span></span><br><span class="line">    <span class="keyword">protected</span> searchTargets(pos: Vector3, <span class="attr">direction</span>: Vector3, <span class="attr">nums</span>: <span class="built_in">number</span>): <span class="built_in">Array</span>&lt;BattleCharacter&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> searchFinder = <span class="built_in">this</span>.onSearchFinder(<span class="built_in">this</span>.allList, pos, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.owner.battleComp.filterTargetsByNums(searchFinder, nums, <span class="built_in">this</span>.entityCfg);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 寻找单个敌人 */</span></span><br><span class="line">    <span class="keyword">protected</span> searchTarget(pos: Vector3, <span class="attr">direction</span>: Vector3, <span class="attr">orderNum</span>: <span class="built_in">number</span>): BattleCharacter &#123;</span><br><span class="line">        <span class="keyword">let</span> searchFinder = <span class="built_in">this</span>.onSearchFinder(<span class="built_in">this</span>.allList, pos, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.owner.battleComp.filterTargetByNum(searchFinder, orderNum, <span class="built_in">this</span>.entityCfg);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实体死亡 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">setEntityDead</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDestroyEntity();</span><br><span class="line">        <span class="built_in">this</span>.b_isEntityDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onInit(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onBuildEntity(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onDestroyEntity(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 筛选敌人 to override */</span></span><br><span class="line">    <span class="keyword">protected</span> onSearchFinder(finder: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, pos: Vector3, <span class="attr">direction</span>: Vector3): <span class="built_in">Array</span>&lt;BattleCharacter&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> finder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">owner</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_action.actionOwner; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">allList</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.owner.battleComp.allList; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">entityCfg</span>(): <span class="title">TEntityCfg</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_entityCfg; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">targetList</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_action.targetList; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isEntityDead</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_isEntityDead; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实体分类"><a href="#实体分类" class="headerlink" title="实体分类"></a>实体分类</h1><p>  可以从之前的技能看出来，实体按功能分类可能有<code>FrameEntity</code>（在同一帧搜集目标单位），<code>MoveEntity</code>（移动并在移动过程中搜集敌人），<code>FollowEntity</code>（朝着事先设定好的目标移动直到碰到敌人为止），<code>PhysicalEntity</code>（带有物理碰撞，可以碰到第一个可被视为目标的单位）等等<br>  按范围分类可能有<code>CircleEntity</code>（指定位置周围一圈圆形范围），<code>QuadEntity</code>（指定位置周围方形范围），<code>FullEntity</code>（从所有可能选择目标单位中选取）<br>  这里将功能一样的放在一起，便于拓展：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EEntityType &#123;</span><br><span class="line">  None = <span class="string">&quot;None&quot;</span>,</span><br><span class="line">  <span class="comment">/** 逐帧判定-&gt;全部范围 */</span></span><br><span class="line">  FrameFull = <span class="string">&quot;FrameFull&quot;</span>,</span><br><span class="line">  <span class="comment">/** 逐帧判定-&gt;圆形范围 */</span></span><br><span class="line">  FrameCircle = <span class="string">&quot;FrameCircle&quot;</span>,</span><br><span class="line">  <span class="comment">/** 逐帧判定-&gt;扇形范围 */</span></span><br><span class="line">  FrameFan = <span class="string">&quot;FrameFan&quot;</span>,</span><br><span class="line">  <span class="comment">/** 逐帧判定-&gt;四边形范围 */</span></span><br><span class="line">  FrameQuad = <span class="string">&quot;FrameQuad&quot;</span>,</span><br><span class="line">  <span class="comment">/** 物理实体-&gt;碰撞Trigger */</span></span><br><span class="line">  Physical = <span class="string">&quot;Physical&quot;</span>,</span><br><span class="line">  <span class="comment">/** 带位移实体-&gt;圆形范围 */</span></span><br><span class="line">  MoveCircle = <span class="string">&quot;MoveCircle&quot;</span>,</span><br><span class="line">  <span class="comment">/** 带位移实体-&gt;四边形范围 */</span></span><br><span class="line">  MoveQuad = <span class="string">&quot;MoveQuad&quot;</span>,</span><br><span class="line">  <span class="comment">/** 追踪目标实体-&gt;全部范围 */</span></span><br><span class="line">  FollowFull = <span class="string">&quot;FollowFull&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实体实例"><a href="#实体实例" class="headerlink" title="实体实例"></a>实体实例</h1><h2 id="FrameEntity"><a href="#FrameEntity" class="headerlink" title="FrameEntity"></a>FrameEntity</h2><p>  <code>FrameEntity</code>在创建后第一帧搜集敌人并且直接结束<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> FrameEntityCfg <span class="keyword">extends</span> IEntityCfg &#123;</span><br><span class="line">    <span class="comment">/** 帧实体搜集的目标数量 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Nums: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameEntity</span>&lt;<span class="title">TFrameEntity</span> <span class="keyword">extends</span> <span class="title">FrameEntityCfg</span> </span>= FrameEntityCfg&gt; <span class="keyword">extends</span> BaseEntity&lt;TFrameEntity&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> finder = <span class="built_in">this</span>.searchTargets(<span class="built_in">this</span>.startPosition, <span class="built_in">this</span>.startDirection, <span class="built_in">this</span>.entityCfg.Nums);</span><br><span class="line">        <span class="built_in">this</span>.targetList.contact(finder);</span><br><span class="line">        <span class="built_in">this</span>.setEntityDead();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FrameCircleEntity"><a href="#FrameCircleEntity" class="headerlink" title="FrameCircleEntity"></a>FrameCircleEntity</h3><p>  <code>FrameCircleEntity</code>在<code>FrameEntity</code>基础上根据半径筛选<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> FrameCircleEntityCfg <span class="keyword">extends</span> FrameEntityCfg &#123;</span><br><span class="line">    <span class="comment">/** 半径 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameCircleEntity</span> <span class="keyword">extends</span> <span class="title">FrameEntity</span>&lt;<span class="title">FrameCircleEntityCfg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onSearchFinder(finder: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, pos: Vector3, <span class="attr">direction</span>: Vector3): <span class="built_in">Array</span>&lt;BattleCharacter&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> retFinder: <span class="built_in">Array</span>&lt;BattleCharacter&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BattleCharacter&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.entityCfg.Radius &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.allList.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 根据半径判断(省略)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FrameQuadEntity"><a href="#FrameQuadEntity" class="headerlink" title="FrameQuadEntity"></a>FrameQuadEntity</h3><p>  <code>FrameQuadEntity</code>在<code>FrameEntity</code>基础上根据长和宽筛选<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> FrameQuadEntityCfg <span class="keyword">extends</span> FrameEntityCfg &#123;</span><br><span class="line">    <span class="comment">/** 长 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Length: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 宽 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameQuadEntity</span> <span class="keyword">extends</span> <span class="title">FrameEntity</span>&lt;<span class="title">FrameQuadEntityCfg</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onSearchFinder(finder: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, pos: Vector3, <span class="attr">direction</span>: Vector3): <span class="built_in">Array</span>&lt;BattleCharacter&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> retFinder: <span class="built_in">Array</span>&lt;BattleCharacter&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BattleCharacter&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.entityCfg.Length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.entityCfg.Width &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finder.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 根据长和宽判断(省略)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MoveEntity"><a href="#MoveEntity" class="headerlink" title="MoveEntity"></a>MoveEntity</h2><p>  MoveEntity在移动中搜集敌人<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MoveEntityCfg <span class="keyword">extends</span> IEntityCfg &#123;</span><br><span class="line">  <span class="comment">/** 搜集的目标数量 */</span></span><br><span class="line">  <span class="keyword">readonly</span> Nums: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 攻击体模型 */</span></span><br><span class="line">  <span class="keyword">readonly</span> ModlePrefab: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** 攻击触发特效 */</span></span><br><span class="line">  <span class="keyword">readonly</span> EntityTriggerEffect: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** 触发延迟[首次触发时间](s) */</span></span><br><span class="line">  <span class="keyword">readonly</span> StartTime: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 触发间隔(s) */</span></span><br><span class="line">  <span class="keyword">readonly</span> Interval: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 实体移动速度 */</span></span><br><span class="line">  <span class="keyword">readonly</span> Speed: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 实体移动时间(s) */</span></span><br><span class="line">  <span class="keyword">readonly</span> Time: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 每个目标只攻击一次 */</span></span><br><span class="line">  <span class="keyword">readonly</span> HitOnlyOnce: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MoveEntity</span>&lt;<span class="title">TMoveCfg</span> <span class="keyword">extends</span> <span class="title">MoveEntityCfg</span> </span>= MoveEntityCfg&gt; <span class="keyword">extends</span> BaseEntity&lt;TMoveCfg&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> _entity: GameObject;</span><br><span class="line">    <span class="keyword">private</span> _entityPosition: Vector3;</span><br><span class="line">    <span class="keyword">private</span> _firstTime: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> _entityTimer: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> _delayTimer: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _speed: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _time: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 已受击的target */</span></span><br><span class="line">    <span class="keyword">private</span> _hasHitTargetList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onBuildEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._entityPosition = <span class="built_in">this</span>.startPosition;</span><br><span class="line">        <span class="built_in">this</span>._delayTimer = <span class="built_in">this</span>.entityCfg.StartTime;</span><br><span class="line">        <span class="built_in">this</span>._speed = <span class="built_in">this</span>.entityCfg.Speed;</span><br><span class="line">        <span class="built_in">this</span>._time = <span class="built_in">this</span>.entityCfg.Time;</span><br><span class="line">        <span class="built_in">this</span>._hasHitTargetList = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BattleCharacter&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成模型(省略)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroyEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 销毁模型(省略)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(fTick: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._time === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setEntityDead();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._time &gt;= fTick) &#123;</span><br><span class="line">            <span class="built_in">this</span>._time -= fTick;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fTick = <span class="built_in">this</span>._time;</span><br><span class="line">            <span class="built_in">this</span>._time = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._delayTimer &gt; fTick) &#123;</span><br><span class="line">            <span class="built_in">this</span>._delayTimer -= fTick;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> offset: Vector3 = Vector3.mul(<span class="built_in">this</span>.startDirection, <span class="built_in">this</span>._speed * fTick);</span><br><span class="line">            <span class="built_in">this</span>._entityPosition = Vector3.add(<span class="built_in">this</span>._entityPosition, offset);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 更新模型位置(省略)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">this</span>._delayTimer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._firstTime || <span class="built_in">this</span>._entityTimer &gt;= <span class="built_in">this</span>.entityCfg.Interval) &#123;</span><br><span class="line">                <span class="built_in">this</span>._processEntity();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 播放模型特效(省略)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._firstTime)</span><br><span class="line">                    <span class="built_in">this</span>._firstTime = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">this</span>._entityTimer -= <span class="built_in">this</span>.entityCfg.Interval;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>._entityTimer += fTick;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> finder = <span class="built_in">this</span>.searchTargets(<span class="built_in">this</span>._entityPosition, <span class="built_in">this</span>.startDirection, <span class="built_in">this</span>.entityCfg.Nums);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否每个目标只打一次（省略）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.targetList.contact(finder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MoveCircleEntity"><a href="#MoveCircleEntity" class="headerlink" title="MoveCircleEntity"></a>MoveCircleEntity</h3><p>  <code>MoveCircleEntity</code>在<code>MoveEntity</code>基础上根据半径筛选<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MoveEntityCircleCfg <span class="keyword">extends</span> MoveEntityCfg &#123;</span><br><span class="line">    <span class="comment">/** 半径 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MoveCircleEntity</span> <span class="keyword">extends</span> <span class="title">MoveEntity</span>&lt;<span class="title">MoveEntityCircleCfg</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onSearchFinder(finder: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, pos: Vector3, <span class="attr">direction</span>: Vector3): <span class="built_in">Array</span>&lt;BattleCharacter&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> retFinder: <span class="built_in">Array</span>&lt;BattleCharacter&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BattleCharacter&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.entityCfg.Radius &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.allList.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 根据半径判断(省略)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FollowEntity"><a href="#FollowEntity" class="headerlink" title="FollowEntity"></a>FollowEntity</h2><p>  <code>FollowEntity</code>在创建时候确定目标，朝着目标移动，直到碰撞到目标单位为止<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> FollowEntityCfg <span class="keyword">extends</span> IEntityCfg &#123;</span><br><span class="line">    <span class="comment">/** 实体按规则锁定的第几个敌人（从1开始计数） */</span></span><br><span class="line">    <span class="keyword">readonly</span> OrderNum: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 实体模型 */</span></span><br><span class="line">    <span class="keyword">readonly</span> ModlePrefab: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">/** 实体速度 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Speed: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 实体最大持续时间 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Time: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FollowEntity</span>&lt;<span class="title">TFollowEntity</span> <span class="keyword">extends</span> <span class="title">FollowEntityCfg</span> </span>= FollowEntityCfg&gt; <span class="keyword">extends</span> BaseEntity&lt;TFollowEntity&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> _entity: GameObject;</span><br><span class="line">    <span class="keyword">private</span> _target: BattleCharacter;</span><br><span class="line">    <span class="keyword">private</span> _speed: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _time: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _entityPosition: Vector3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onBuildEntity(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>._target = <span class="built_in">this</span>.searchTarget(<span class="built_in">this</span>.startPosition, <span class="built_in">this</span>.startDirection, <span class="built_in">this</span>.entityCfg.OrderNum);</span><br><span class="line">        <span class="built_in">this</span>._speed = <span class="built_in">this</span>.entityCfg.Speed;</span><br><span class="line">        <span class="built_in">this</span>._time = <span class="built_in">this</span>.entityCfg.Time;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._entityPosition = <span class="built_in">this</span>.startPosition;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成模型(省略)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroyEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 销毁模型(省略)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._time === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setEntityDead();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._time &gt;= dt) &#123;</span><br><span class="line">            <span class="built_in">this</span>._time -= dt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dt = <span class="built_in">this</span>._time;</span><br><span class="line">            <span class="built_in">this</span>._time = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 没有敌人或者敌人死亡就朝着既定方向飞去 */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._target || <span class="built_in">this</span>._target.battleHPComp.isDying) &#123;</span><br><span class="line">            <span class="keyword">let</span> offset: Vector3 = Vector3.mul(<span class="built_in">this</span>.startDirection, <span class="built_in">this</span>._speed * dt);</span><br><span class="line">            <span class="built_in">this</span>._entityPosition = Vector3.add(<span class="built_in">this</span>._entityPosition, offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._entityPosition = Vector3.moveTowards(<span class="built_in">this</span>._entityPosition, <span class="built_in">this</span>._target.animComp.hitPosition, <span class="built_in">this</span>._speed * dt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新模型位置(省略)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._processEntity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否击中目标，途中可能目标死亡，或者无敌隐身等等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实体拓展"><a href="#实体拓展" class="headerlink" title="实体拓展"></a>实体拓展</h1><p>  以上列出了一些<code>Entity</code>供参考，可以根据技能需求设计各种实体，如<code>BounceEntity</code>（传播实体，子弹可以在目标之前传导），<code>HookEntity</code>（钩子实体，可以像绳索一样套住目标），每一种实体也可以根据形状，发射轨迹等等因素不断拓展，如<code>FollowEntity</code>可以有弧形轨迹，直线轨迹等等，具体可以根据项目不断拓展。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二十一) 技能设计-Action受击反馈</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%80)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%97%E5%87%BB%E5%8F%8D%E9%A6%88/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从前文中可以看出，<code>HitFeedback</code>（受击反馈）是对<code>Entity</code>搜集的目标施加的效果，下面主要讲一些<code>HitFeedback</code>的实现。</p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>  和前面的设计一样，通过几个游戏中常见的技能，根据这些技能来设计<code>HitFeedback</code></p>
<ul>
<li>战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。</li>
<li>奶妈举起手上的权杖，给生命值最低的己方单位加了一次血。</li>
<li>辅助扔出手上的药剂，给敌方全体单位上了一层持续一定时间的破防效果。</li>
<li>魔法师挥舞手上的法杖，在己方最前排召唤了一个侍从。</li>
</ul>
<p>  从<code>HitFeedback</code>角度简单分析上面列举的几个技能，可以发现有些<code>HitFeedback</code>是对目标造成伤害，有些<code>HitFeedback</code>是给目标治疗，有些<code>HitFeedback</code>是给目标上Buff，有些<code>HitFeedback</code>是在目标位置召唤生物，下面我们来根据这些分析来设计<code>HitFeedback</code>。</p>
<h1 id="受击反馈设计"><a href="#受击反馈设计" class="headerlink" title="受击反馈设计"></a>受击反馈设计</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>  我们似乎可以参照前面<code>Emit</code>和<code>Entity</code>写出如下这个基类<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IHitFeedbackCfg &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseHitFeedback</span>&lt;<span class="title">THitFeedbackCfg</span> <span class="keyword">extends</span> <span class="title">IHitFeedbackCfg</span> </span>= IHitFeedbackCfg&gt; &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> onHit(target: BattleCharacter): <span class="built_in">void</span>;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  然后继承实现出HitDamage，HitAddBuff，HitHeal即可<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IHitDamageCfg <span class="keyword">extends</span> IHitFeedbackCfg &#123;</span><br><span class="line">    <span class="comment">/** 伤害数值 */</span></span><br><span class="line">    <span class="attr">DamageValue</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 伤害类型 */</span></span><br><span class="line">    DamageType: EDamageType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HitDamage</span> <span class="keyword">extends</span> <span class="title">BaseHitFeedback</span>&lt;<span class="title">IHitDamageCfg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> onHit(target: BattleCharacter): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 省略细节 造成伤害</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样看起来是一个比较合理的实现方式，但是做项目的话似乎不太合适，我们站在<code>策划</code>的角度思考一下这个需求，<code>Emit</code>和<code>Entity</code>的配置信息都是配置在技能的Json中的，一个技能的实际效果，比如在动作第20ms选择自身半径范围内最近的敌方目标造成xxx伤害，一般来说，一个技能设计完成以后<code>第20ms选择自身半径范围内最近的敌方目标造成伤害</code>这些内容在随着版本迭代过程中是不会更改的，需要更改的是<code>XXX伤害</code>，这里需要加入数值运算，技能等级等因素，所以如果跟随<code>Emit</code>和<code>Entity</code>的配置信息一起配在Json中会非常麻烦，并且对于<code>策划</code>来说，他们更青睐于Excel，所以有必要把<code>&quot;不变&quot;</code>（不会经常变）的技能信息放在Json中，讲<code>&quot;易变&quot;</code>（数值等容易改变）的信息放入Excel中</p>
<h2 id="受击反馈配置"><a href="#受击反馈配置" class="headerlink" title="受击反馈配置"></a>受击反馈配置</h2><h3 id="表格部分"><a href="#表格部分" class="headerlink" title="表格部分"></a>表格部分</h3><p>  设计一张新表SkillAction 如图所示<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%80)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%97%E5%87%BB%E5%8F%8D%E9%A6%88/img1.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>DamageValue</code>：技能固定伤害数值</li>
<li><code>DamageRatio</code>：技能固定与属性计算伤害比例</li>
<li><code>DamageUpgradeRatio</code>：技能每级提升与属性伤害比例</li>
<li><code>DamageType</code>: 伤害类型 这里用位运算<ul>
<li>-1 不造成伤害</li>
<li>0 普通攻击</li>
<li>1 必定暴击</li>
<li>2 不可闪避</li>
<li>4 必定不暴击</li>
<li>8 无视防御</li>
<li>3 = 1 + 2 必定暴击不可闪避</li>
</ul>
</li>
<li><code>HealValue</code> 技能固定治疗数值</li>
<li><code>HealRatio</code>：技能固定与属性计算治疗比例</li>
<li><code>HealUpgradeRatio</code>: 技能每级提升与属性治疗比例</li>
<li><code>HealType</code>: 治疗类型 这里用位运算<ul>
<li>-1 不产生治疗</li>
<li>0 普通治疗</li>
<li>1 必定暴击</li>
</ul>
</li>
<li><code>BuffIDs</code>：所加Buff列表 1001|1002 表示 1001和1002两个Buff</li>
<li><code>SummonID</code>: 召唤物ID</li>
<li><code>SummonOverlay</code>: 召唤物叠加层数</li>
<li><code>SummonRatio</code>: 召唤物属性比例</li>
<li><code>SummonOffset</code>: 召唤物与选定位置的偏移</li>
<li><code>ClearBuffType</code>: 驱散Buff类型<ul>
<li>1 Buff</li>
<li>2 Debuff</li>
<li>3 所有Buff</li>
</ul>
</li>
</ul>
<h3 id="Json配置部分"><a href="#Json配置部分" class="headerlink" title="Json配置部分"></a>Json配置部分</h3>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IHitFeedbackCfg &#123;</span><br><span class="line">  <span class="keyword">readonly</span> SkillActionID: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 受击音效 */</span></span><br><span class="line">  <span class="keyword">readonly</span> Sound: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/** 受击特效 */</span></span><br><span class="line">  <span class="keyword">readonly</span> Effect: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="受击反馈实现"><a href="#受击反馈实现" class="headerlink" title="受击反馈实现"></a>受击反馈实现</h2>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HitFeedback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _action: BaseBattleAction;</span><br><span class="line">    <span class="keyword">private</span> _hitFeedbackCfg: IHitFeedbackCfg;</span><br><span class="line">    <span class="keyword">private</span> _attackerAttr: BaseAttr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">action: BaseBattleAction</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._action = action;</span><br><span class="line">        <span class="built_in">this</span>._hitFeedbackCfg = action.actionCfg.HitFeedbackProperty;</span><br><span class="line">        <span class="comment">// 子弹类伤害，在发射时就记录释放者的属性</span></span><br><span class="line">        <span class="built_in">this</span>._attackerAttr = action.actionOwner.attrComp.attr.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">hitApply</span>(<span class="params">target: BattleCharacter</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._processDamage();</span><br><span class="line">        <span class="built_in">this</span>._processHeal();</span><br><span class="line">        <span class="built_in">this</span>._processBuff();</span><br><span class="line">        <span class="built_in">this</span>._processClearBuff();</span><br><span class="line">        <span class="built_in">this</span>._processSummon();</span><br><span class="line">        <span class="built_in">this</span>._processPlaySound();</span><br><span class="line">        <span class="built_in">this</span>._processPlayEffect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_processDamage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 造成伤害（省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_processHeal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 加治疗（省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_processBuff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 加Buff（省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processClearBuff(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 驱散Buff（省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processSummon(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 召唤（省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _processPlaySound(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 播放声音 （省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_processPlayEffect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 播放特效 （省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="受击反馈拓展"><a href="#受击反馈拓展" class="headerlink" title="受击反馈拓展"></a>受击反馈拓展</h1><p>  以上列出的<code>HitFeedback</code>仅供参考，可以根据项目需求设计各种<code>HitFeedback</code>，了解整个机制流程之后，可以不拘泥于伤害治疗，例如召唤等都可以做到<code>HitFeedback</code>里面。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二十三) 相机管理</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%89)-%E7%9B%B8%E6%9C%BA%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  相机算是这类战斗的表现部分，市面上目前也提供了很多插件工具，直接导入项目调用API即可，这里主要介绍一下设计思想，项目当中对于相机使用比较轻量的话，也可以参照这种思想进行设计。</p>
<h1 id="CameraAction设计"><a href="#CameraAction设计" class="headerlink" title="CameraAction设计"></a>CameraAction设计</h1><p>  在游戏中对于会有很多行为，如改变相机Fov，改变相机角度，改变相机位置，相机跟随目标，相机震动等等，这些行为有时候会单独使用，有时候会组合使用，如果不能有效设计，将会造成大量代码冗余。这里我们可以通过设计一个<code>CameraAction</code>代表所有相机行为的基类:<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCameraAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> cameraSP: BattleCameraSP;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">cameraSP: BattleCameraSP</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cameraSP = cameraSP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">init</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onInit.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">update</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cameraSP.cancelCameraAction(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>interrupt 是否强制取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> cancel(interrupt: <span class="built_in">boolean</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onInit</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CameraAction管理"><a href="#CameraAction管理" class="headerlink" title="CameraAction管理"></a>CameraAction管理</h1><p>  通过CameraSP对所有的CameraAction进行管理：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCameraSP</span> <span class="keyword">extends</span> <span class="title">SceneProcessorBase</span>&lt;<span class="title">BattleScene</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _cameraActions: BattleCameraAction[];</span><br><span class="line">    <span class="keyword">private</span> _cameraObj: GameObject;</span><br><span class="line">    <span class="keyword">private</span> _cameraTrans: Transform;</span><br><span class="line">    <span class="keyword">private</span> _camera: Camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._cameraActions = [];</span><br><span class="line">        <span class="comment">// 初始化获取地图上的相机 （省略细节）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> cameraAction <span class="keyword">of</span> <span class="built_in">this</span>._cameraActions) &#123;</span><br><span class="line">            cameraAction.update(dt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 跟随目标 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">followTarget</span>(<span class="params">target: ICameraTarget, followSpeed: <span class="built_in">number</span> = <span class="number">1</span>, offset: Vector3 = Vector3.zero</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._createCameraAction(BattleCameraFollowAciton, target, followSpeed, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 改变fov */</span></span><br><span class="line">    <span class="keyword">public</span> changeFov(targetFov: <span class="built_in">number</span>, <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">1</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._createCameraAction(BattleCameraFovAciton, targetFov, speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 改变角度 */</span></span><br><span class="line">    <span class="keyword">public</span> changeRotation(targetRot: Quaternion, <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">1</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._createCameraAction(BattleCameraRotateAction, targetRot, speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 相机震动 */</span></span><br><span class="line">    <span class="keyword">public</span> shake(intensity: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span> = <span class="number">0</span>, <span class="attr">disableX</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>, <span class="attr">disableY</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>, <span class="attr">delayTime</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._createCameraAction(BattleCameraShakeAction, intensity, duration, disableX, disableY, delayTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 同类型action只能存在一个 */</span></span><br><span class="line">    <span class="keyword">private</span> _createCameraAction&lt;T <span class="keyword">extends</span> BattleCameraAction&gt;(<span class="keyword">type</span>: <span class="keyword">new</span> (BattleCameraSP) =&gt; T&gt;, ...args: <span class="built_in">any</span>[]): T &#123;</span><br><span class="line">        <span class="keyword">let</span> action = <span class="built_in">this</span>.getCameraAction(<span class="keyword">type</span>);</span><br><span class="line">        <span class="keyword">if</span> (!action) &#123;</span><br><span class="line">            action = <span class="keyword">new</span> <span class="keyword">type</span>(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>._cameraActions.push(action);</span><br><span class="line">        &#125;</span><br><span class="line">        action.init(...args);</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getCameraAction&lt;T <span class="keyword">extends</span> BattleCameraAction&gt;(<span class="keyword">type</span>: <span class="keyword">new</span> (BattleCameraSP) =&gt; T): T &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> action <span class="keyword">of</span> <span class="built_in">this</span>._cameraActions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action <span class="keyword">instanceof</span> <span class="keyword">type</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> action;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">cancelCameraAction</span>(<span class="params">action: BattleCameraAction, interrupt: <span class="built_in">boolean</span> = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">        ArrayUtil.removeFirstIf(<span class="built_in">this</span>._cameraActions, <span class="function">(<span class="params">ac</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ac === action;</span><br><span class="line">        &#125;);</span><br><span class="line">        action &amp;&amp; action.cancel(interrupt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">cancelAllAction</span>(<span class="params">interrupt: <span class="built_in">boolean</span> = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._cameraActions.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">this</span>._cameraActions[i].cancel(interrupt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._cameraActions.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">camera</span>(): <span class="title">Camera</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._camera; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">position</span>(): <span class="title">Vector3</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._cameraTrans.position; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">set</span> <span class="title">position</span>(<span class="params">pos: Vector3</span>) &#123; <span class="built_in">this</span>._cameraTrans.position = pos; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">rotation</span>(): <span class="title">Quaternion</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._cameraTrans.rotation; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">set</span> <span class="title">rotation</span>(<span class="params">rat: Quaternion</span>) &#123; <span class="built_in">this</span>._cameraTrans.rotation = rat; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">set</span> <span class="title">fov</span>(<span class="params">fov: <span class="built_in">number</span></span>) &#123; <span class="built_in">this</span>._camera.fov = fov; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">fov</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._camera.fov; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CameraAction具体实现"><a href="#CameraAction具体实现" class="headerlink" title="CameraAction具体实现"></a>CameraAction具体实现</h1><p>  这样就可以在对应的CameraAction实现相应功能，下面举几个例子：</p>
<h2 id="改变FOV"><a href="#改变FOV" class="headerlink" title="改变FOV"></a>改变FOV</h2><p>  一个比较简单的改变FOV的实现<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCameraFovAciton</span> <span class="keyword">extends</span> <span class="title">BattleCameraAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _targetFov: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _speed: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">onInit</span>(<span class="params">targetFov: <span class="built_in">number</span>, speed: <span class="built_in">number</span> = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._targetFov = targetFov;</span><br><span class="line">        <span class="built_in">this</span>._speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.is_equal(<span class="built_in">this</span>.cameraSP.fov, <span class="built_in">this</span>._targetFov, <span class="number">0.01</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.complete();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.cameraSP.fov = <span class="built_in">Math</span>.lerp(<span class="built_in">this</span>.cameraSP.fov, <span class="built_in">this</span>._targetFov, <span class="built_in">this</span>._speed * dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="相机跟随"><a href="#相机跟随" class="headerlink" title="相机跟随"></a>相机跟随</h2><p>  对于相机跟随，这里要注意，相机是一个通用模块，不能指定目标，所以需要一个接口<code>ICameraTarget</code><br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICameraTarget &#123;</span><br><span class="line">    <span class="comment">/** 目标位置 */</span></span><br><span class="line">    <span class="attr">position</span>: Vector3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样再去实现相机跟随<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCameraFollowAciton</span> <span class="keyword">extends</span> <span class="title">BattleCameraAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _target: ICameraTarget;</span><br><span class="line">    <span class="keyword">private</span> _targetOffset: Vector3;</span><br><span class="line">    <span class="keyword">private</span> _followSpeed: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">onInit</span>(<span class="params">target: ICameraTarget, followSpeed: <span class="built_in">number</span> = <span class="number">1</span>, offset: Vector3 = Vector3.zero</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._target = target;</span><br><span class="line">        <span class="built_in">this</span>._followSpeed = followSpeed;</span><br><span class="line">        <span class="built_in">this</span>._targetOffset = Vector3.create(offset.x, offset.y, offset.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">onUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cameraSP.position = Vector3.lerp(<span class="built_in">this</span>.cameraSP.position, Vector3.add(<span class="built_in">this</span>._target.position, <span class="built_in">this</span>._targetOffset), dt * <span class="built_in">this</span>._followSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h1><p>  可以参照上面的写法将很多相机的行为进行包装成对应的<code>CameraAction</code>，这里相机所采用的<code>Action思想</code>同样可以运用于地图模块等其他模块，这里就不再一一赘述了。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二十二) 技能设计-总结</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%BA%8C)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  前面我们将技能拆分成了<code>Action</code>和<code>ActionEvent</code>，并对其中的每一个构成部分进行了详解，下面结合样例进行一下总结。</p>
<h1 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;EventList&quot;</span>  : [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">&quot;TriggerTime&quot;</span> : <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;EventType&quot;</span>   : <span class="string">&quot;PlayAnim&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;EventData&quot;</span>   : &#123;</span><br><span class="line">              <span class="attr">&quot;AnimName&quot;</span> : <span class="string">&quot;BattleAttack&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;AnimSpeed&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">              <span class="attr">&quot;FadeTime&quot;</span>  : <span class="number">0.0</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">&quot;TriggerTime&quot;</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">&quot;EventType&quot;</span>   : <span class="string">&quot;PlayEffect&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;EventData&quot;</span>   : &#123;</span><br><span class="line">              <span class="attr">&quot;EffectName&quot;</span> : <span class="string">&quot;XXX&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;IsLoop&quot;</span>     : <span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;ActionList&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">&quot;EmitType&quot;</span> : <span class="string">&quot;Normal&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;EmitProperty&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;TargetSideType&quot;</span> : <span class="string">&quot;MySide&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;TargetSummonType&quot;</span> : <span class="string">&quot;None&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;IncludeSelf&quot;</span>      : <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">&quot;CondsSortType&quot;</span>    : <span class="string">&quot;Self&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;CondsSummonSortType&quot;</span> : <span class="string">&quot;None&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;OrderNum&quot;</span>            : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;Num&quot;</span>                 : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;Interval&quot;</span>            : <span class="number">0.0</span>,</span><br><span class="line">              <span class="attr">&quot;Type&quot;</span>                : <span class="string">&quot;Interval&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;DirType&quot;</span>             : <span class="string">&quot;SelfDir&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;EntityType&quot;</span>   : <span class="string">&quot;FrameCircle&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;EntityProperty&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;TargetSideType&quot;</span> : <span class="string">&quot;OtherSide&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;TargetSummonType&quot;</span> : <span class="string">&quot;None&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;IncludeSelf&quot;</span>      : <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">&quot;CondsSortType&quot;</span>    : <span class="string">&quot;NearToMe&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;CondsSummonSortType&quot;</span> : <span class="string">&quot;None&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;Delay&quot;</span>               : <span class="number">0.0</span>,</span><br><span class="line">              <span class="attr">&quot;Nums&quot;</span>                : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;Radius&quot;</span>              : <span class="number">3.6</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;HitFeedbackProperty&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;SkillActionID&quot;</span> : <span class="number">101101001</span>,</span><br><span class="line">              <span class="attr">&quot;Sound&quot;</span>         : <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;Effect&quot;</span>        : <span class="string">&quot;YYY&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;TriggerTime&quot;</span>         : <span class="number">391</span>,</span><br><span class="line">          <span class="attr">&quot;Delay&quot;</span>               : <span class="number">0.0</span>,</span><br><span class="line">          <span class="attr">&quot;DeadActionChanged&quot;</span>   : <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p> 如图中这样一个技能，可以看到会<br> 在<code>0ms</code>时候<code>PlayAnim</code>，<code>AnimName</code>为<code>BattleAttack</code>，<br> 在<code>20m</code>时候<code>PlayEffect</code>，<code>EffectName</code>为<code>XXX</code>，<br> 在<code>391ms</code>时候启动一个<code>Action</code>，发射一个<code>Normal</code>发射器，发射器选择位置为我方（<code>MySide</code>）最终选择自己（<code>Self</code>），发射一个<code>FrameCircle</code>实体并搜集实体周围半径（Radius)<code>3.6</code>的敌方（<code>OtherSide</code>）离我最近（<code>NearToMe</code>）的一个（<code>1</code>）单位，对该单位进行SkillActionID = <code>101101001</code>的反馈，受击特效为<code>YYY</code>。<br> <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%BA%8C)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-%E6%80%BB%E7%BB%93/img1.png" alt="在这里插入图片描述"><br> 打开SkillAction表找到对应行数，可以看到技能为造成伤害并加上<code>300103</code>（击退buff）的Buff<br> 技能最终效果即为，对在我半径3.6范围内的最近的敌方单位造成一次伤害并使其被击退。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  通过样例和之前的介绍，可以发现各种组合搭配起来，可以设计出很多技能，这里列举几个游戏中常见技能</p>
<ul>
<li>对攻击力最高的敌人造成大伤害，并使其沉默，持续5秒<ul>
<li>（FrameFullEntity 排序选取攻击最高 伤害 并 加沉默Buff）</li>
</ul>
</li>
<li>对最远处的敌人施放一个小范围区域，对区域内的敌人每0.5秒造成伤害，并中幅(30%)降低防御力，持续4秒<ul>
<li>（MoveEntity 速度设为0，持续4秒，间隔0.5秒 造成伤害并增加减防Buff）</li>
</ul>
</li>
<li>治疗生命值最低的队友并清除他们的异常效果<ul>
<li>（FrameFullEntity 排序选取生命值最低 治疗并清除Debuff）</li>
</ul>
</li>
</ul>
<p>  当然游戏中还有更多更复杂的技能，也需要根据项目慢慢迭代拓展。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(八) 角色设计-战斗基础</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AB)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在以往的设计中，战斗中会有大量的判断角色所处阵营然后根据所处阵营获取是用playerlist还是enemylist，使得代码整体非常的混乱，需要一种合理的设计避免这种大量的判断。</p>
<h1 id="组件无状态化"><a href="#组件无状态化" class="headerlink" title="组件无状态化"></a>组件无状态化</h1><p>  在战斗组件的设计上采取一种<code>无状态</code>的方式，即不管组件使用者是谁，所有逻辑都是既使用友方阵营，也适用敌方阵营。能够做到这种方式的方法即在初始化时候定义好firendList和targetList，这样通过在角色绑定组件的时候，也顺带绑定好友方和敌方列表，就可以不用再在其他地方判断角色所处阵营。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _target: BattleCharacter;</span><br><span class="line">  <span class="keyword">private</span> _firendList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">  <span class="keyword">private</span> _targetList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">  <span class="keyword">private</span> _decoyTarget: BattleCharacter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override <span class="function"><span class="title">onInit</span>(<span class="params">firendList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, targetList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._targetList = targetList;</span><br><span class="line">      <span class="built_in">this</span>._firendList = firendList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._target = <span class="built_in">this</span>.getNearestOtherSide();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 判断能否选中目标 */</span></span><br><span class="line">  <span class="keyword">public</span> judgeCanSelectTarget(target: BattleCharacter): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 受到一次攻击 */</span></span><br><span class="line">  <span class="keyword">public</span> processBeDamage():<span class="built_in">void</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 受到一次治疗 */</span></span><br><span class="line">  <span class="keyword">public</span> processBeHeal():<span class="built_in">void</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置嘲讽目标 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">setDecoyTarget</span>(<span class="params">decoyTarget: BattleCharacter</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 根据条件筛选出一群单位 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">filterTargetsByNums</span>(<span class="params">toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, nums: <span class="built_in">number</span>, battleTargetCfg: IBattleTargetCfg</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 根据条件筛选出一个单位 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">filterTargetByNum</span>(<span class="params">toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, orderNum: <span class="built_in">number</span>, battleTargetCfg: IBattleTargetCfg</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 获得最近的敌方 */</span></span><br><span class="line">  <span class="keyword">public</span> getNearestOtherSide(): BattleCharacter &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  战斗基础组件中主要包含了战斗中的计算，锁敌相关，包含了所有和目标相关的信息，组件无状态化，会省去很多无用代码，也会方便拓展所有锁敌相关的设计，如嘲讽技能，魅惑技能等等。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(二十四) 完结</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E5%9B%9B)-%E5%AE%8C%E7%BB%93/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  到这里，对于放置类卡牌战斗的开发记录也算告一段落了，当然其中的很多模块也主要集中在设计思想和机制层面，对于很多表现层面的开发还没有做到精细，这些都是需要在后面项目迭代过程中不断优化的。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>  回看这两年来的学习，从一开始代码堆砌在一个文件一个类到后来慢慢接触<code>设计模式</code>，再到花时间思考，慢慢将项目中的一些代码整理重构，并在过程中学习和运用设计模式，也算这一路的收获和成长吧。</p>
<h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>  代码能力和接口设计能力是开发中必不可少的一部分，这部分的能力说实话不是看书或者看视频看资料就能一下学会的，这个需要在日常开发中不断积累，就算看完二十三种设计模式，也是需要在不断的实战中才能逐步理解的。在我们每一个需求到来时，如果我们都花上一天时间或者更多时间，不写代码，先做分析和设计，理清其中的需求点，再分析需求点中通用部分，在我看来，面向对象的精髓就是抽象和多态，把代码做成一个相对通用的框架结构绝对是开发中最爽的事情，当策划每扔过来一个需求，你都可以通过建一个子类，加一两行代码，或者干脆可以通过配置文件灵活配置，这个时候，你会有满满的成就感，因为你的代码是一个通用的代码。相反，任何时候，你看到那些一大堆if else代码的时候，都会很烦躁，因为每次加需求，你都需要把原先代码的逻辑整个捋一遍，才知道要怎么加，不仅影响心情，也影响工作效率。在我看来，用好继承和多态，在代码设计层面来说是必不可少的一项技能。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(五) 角色设计-属性</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%94)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  属性模块基本算是战斗的基础模块了，战斗中角色很多机制都依赖于属性，战斗中的属性一般分为战前属性，战斗中临时属性，有效的管理好这些属性之间的关系，在战斗中显得尤为重要。</p>
<h1 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h1><p>  设计上需要先将属性编号，如：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AttrID</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 最大血量 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> MaxHP: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/** 血量百分比 0-1 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HPPer: <span class="built_in">number</span> = <span class="number">101</span>;</span><br><span class="line">  <span class="comment">/** 攻击 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Attack: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/** 攻击百分比 0-1 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> AttackPer: <span class="built_in">number</span> = <span class="number">102</span>;</span><br><span class="line">  <span class="comment">/** 防御 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Defence: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/** 防御（百分比）0-1  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DefencePer: <span class="built_in">number</span> = <span class="number">103</span>;</span><br><span class="line">  <span class="comment">/** 暴击率（百分比）0-1  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> CritRate: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="属性基础组织"><a href="#属性基础组织" class="headerlink" title="属性基础组织"></a>属性基础组织</h1><p>  然后需要设计一个通用的属性基类，将属性组织起来，提供各种属性接口，在拓展新属性的时候只需要加上不同的ID并且提供对应的计算接口即可<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAttr</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _dict: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._dict = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> attr = <span class="keyword">new</span> BaseAttr();</span><br><span class="line">      attr._dict = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>._dict) &#123;</span><br><span class="line">          attr._dict[key] = <span class="built_in">this</span>._dict[key];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> attr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">addAttr</span>(<span class="params">other: BaseAttr</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> other._dict) &#123;</span><br><span class="line">          <span class="built_in">this</span>.addValue(key, other._dict[key]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">removeAttr</span>(<span class="params">other: BaseAttr</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> other._dict) &#123;</span><br><span class="line">          <span class="built_in">this</span>.removeValue(key, other._dict[key]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">addAttrArray</span>(<span class="params">attrArray: <span class="built_in">Array</span>&lt;&#123; <span class="keyword">type</span>: <span class="built_in">number</span>, value: <span class="built_in">number</span>; &#125;&gt;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!attrArray) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">of</span> attrArray) &#123;</span><br><span class="line">          <span class="built_in">this</span>.addValue(attr.type, attr.value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">removeAttrArray</span>(<span class="params">attrArray: <span class="built_in">Array</span>&lt;&#123; <span class="keyword">type</span>: <span class="built_in">number</span>, value: <span class="built_in">number</span>; &#125;&gt;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!attrArray) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">of</span> attrArray) &#123;</span><br><span class="line">          <span class="built_in">this</span>.removeValue(attr.type, attr.value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">addValue</span>(<span class="params">attrKey: <span class="built_in">number</span> | <span class="built_in">string</span>, value: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (notNull(<span class="built_in">this</span>._dict[attrKey])) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dict[attrKey] += value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>._dict[attrKey] = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">removeValue</span>(<span class="params">attrKey: <span class="built_in">number</span> | <span class="built_in">string</span>, value: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isNull(<span class="built_in">this</span>._dict[attrKey])) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>._dict[attrKey] = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">this</span>._dict[attrKey] - value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">getValue</span>(<span class="params">key: <span class="built_in">number</span>, defaultValue: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isNull(<span class="built_in">this</span>._dict[key]) ? defaultValue : <span class="built_in">this</span>._dict[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">getPositiveValue</span>(<span class="params">key: <span class="built_in">number</span>, defaultValue: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">this</span>.getValue(key, defaultValue));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">getRatioValue</span>(<span class="params">key: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">this</span>.getValue(key);</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">1</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">getNegativeRatioValue</span>(<span class="params">key: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">this</span>.getValue(key);</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">1</span> - value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">setValue</span>(<span class="params">key: <span class="built_in">number</span>, value: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._dict[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._dict = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hp</span>() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">this</span>.getPositiveValue(AttrID.MaxHP) * <span class="built_in">this</span>.getRatioValue(AttrID.HPPer)); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">attack</span>() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">this</span>.getPositiveValue(AttrID.Attack) * <span class="built_in">this</span>.getRatioValue(AttrID.AttackPer)); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">defence</span>() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">this</span>.getPositiveValue(AttrID.Defence) * <span class="built_in">this</span>.getRatioValue(AttrID.DefencePer)); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">critRate</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.getValue(AttrID.CritRate); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="角色属性组件设计"><a href="#角色属性组件设计" class="headerlink" title="角色属性组件设计"></a>角色属性组件设计</h1>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IAttrProvider &#123;</span><br><span class="line">  getAttr(): BaseAttr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  由于战斗中会存在各种来源的属性，如buff的属性，各种战斗模式给所有角色加的全局属性等等，设计一个<code>IAttrProvider</code>接口用于属性组件中注册属性来源。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharAttrComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Events = &#123;</span><br><span class="line">        <span class="comment">/** 属性改变 */</span></span><br><span class="line">        <span class="attr">AttrChange</span>: <span class="string">&#x27;AttrChange&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 角色总属性 */</span></span><br><span class="line">    <span class="keyword">private</span> _attr: BaseAttr;</span><br><span class="line">    <span class="comment">/** 角色基础属性 */</span></span><br><span class="line">    <span class="keyword">private</span> _baseAttr: BaseAttr;</span><br><span class="line">    <span class="comment">/** 属性提供者 */</span></span><br><span class="line">    <span class="keyword">private</span> _attrProviders: <span class="built_in">Array</span>&lt;IAttrProvider&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(baseAttr: BaseAttr): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._attrProviders = [];</span><br><span class="line">        <span class="built_in">this</span>._attr = <span class="keyword">new</span> BaseAttr();</span><br><span class="line">        <span class="built_in">this</span>._baseAttr = baseAttr;</span><br><span class="line">        <span class="built_in">this</span>.syncAttr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">registerAttrProvider</span>(<span class="params">provider: IAttrProvider</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._attrProviders.push(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> syncAttr(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._attr.clear();</span><br><span class="line">        <span class="built_in">this</span>._attr.addAttr(<span class="built_in">this</span>._baseAttr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> provider <span class="keyword">of</span> <span class="built_in">this</span>._attrProviders) &#123;</span><br><span class="line">            <span class="built_in">this</span>._attr.addAttr(provider.getAttr());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.event(CharAttrComponent.Events.AttrChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">attr</span>(): <span class="title">BaseAttr</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._attr; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">baseAttr</span>(): <span class="title">BaseAttr</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._baseAttr; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化时将角色的入场属性作为基础属性，注册其他来源属性，计算总属性的时候将所有来源属性统计好，并播报属性改变的事件。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十) 角色设计-战斗Buff</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97Buff/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  buff模块也是角色设计中必不可少的模块，游戏中角色一半以上的技能机制都需要依赖buff模块支持，一个稳定健壮的buff系统才能更好的保证游戏逻辑自洽。</p>
<h1 id="Buff基础"><a href="#Buff基础" class="headerlink" title="Buff基础"></a>Buff基础</h1><h2 id="表格设计"><a href="#表格设计" class="headerlink" title="表格设计"></a>表格设计</h2><p>  游戏中Buff是需要策划配表做成Buff库，Buff表需要设计合理，才能方便程序和策划使用，如图所示<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97Buff/img1.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>BuffType</code>表示Buff种类，如<ul>
<li>属性类: 基础属性（如：固定+10%攻击），动态属性（如：根据当前攻击50% 转化成防御）</li>
<li>状态类：束缚，晕眩，冰冻，嘲讽等等</li>
<li>位移类：被击退，被击飞，被吸附</li>
<li>变身类：改变普攻，改变模型</li>
</ul>
</li>
<li><code>BuffClass</code>表示Buff分类，这里用位运算处理：<ul>
<li>1：增益Buff</li>
<li>2：减益Buff</li>
<li>4：不可驱散Buff</li>
<li>5：增益不可驱散Buff</li>
<li>6：减益不可驱散Buff</li>
</ul>
</li>
<li><code>OverlayType</code> 叠加类型<ul>
<li>1：不刷新时间（第一层3秒 加入第二层8秒）</li>
<li>2：刷新时间（第一层3秒 加入第二层8秒 把第一层也变成了8秒）</li>
</ul>
</li>
<li><code>OverlayMax</code> 叠加层数 -1为无限层，层数溢出时默认清除最早添加的Buff</li>
<li><code>Duration</code> Buff持续时间</li>
<li><code>AttrArr</code> Buff所添加的属性数组 对照前面属性表ID，如<ul>
<li>102=0.2 表示一个攻击+20%的Buff （102 攻击百分比）</li>
<li>102=0.3|103=0.2 表示一个攻击+30%和防御+20%的buff （102 攻击百分比， 103防御百分比）<br>通过属性字段，可以配游戏中大量的Buff，也方便Buff之间的组合，如一个狂暴Buff是同时加攻速攻击等等</li>
</ul>
</li>
<li><code>Params</code> 表示一些buff类型需要的独特字段 如<ul>
<li>动态属性Buff约定<ul>
<li>第一个数字 1 施法者 2 受击者</li>
<li>第二个数字 要使用的属性id</li>
<li>第三个数字 要使用的属性比例</li>
<li>第四个数字 增加属性id<br>1|2|0.2|3 表示将施法者<code>（第一个数字 1）</code> 攻击<code>（第二个数字 2）</code>的20%<code>（第三个数字 0.2）</code>变成防御<code>(第四个数字 3)</code></li>
</ul>
</li>
<li>击退 就可以表示 击退距离或者击退速度</li>
<li>变身 就可以表示 变身的技能ID 模型名称等等</li>
</ul>
</li>
<li><code>Effect</code> 表示Buff持续期间加在角色身上的特效相关</li>
</ul>
<h2 id="Buff基类"><a href="#Buff基类" class="headerlink" title="Buff基类"></a>Buff基类</h2><p>  代码层面基本就是表格的封装处理，设计一个Buff基类，让子类继承生命周期函数<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EBuffType &#123;</span><br><span class="line">    BaseAttr = <span class="number">1001</span>,        <span class="comment">/** 基础属性 */</span></span><br><span class="line">    DynamicAttr = <span class="number">1002</span>,     <span class="comment">/** 动态属性 */</span></span><br><span class="line">    Dizzy = <span class="number">2001</span>,           <span class="comment">/** 晕眩 */</span></span><br><span class="line">    Silence = <span class="number">2002</span>,         <span class="comment">/** 沉默 */</span></span><br><span class="line">    Decoy = <span class="number">2003</span>,           <span class="comment">/** 嘲讽 */</span></span><br><span class="line">    PushBack = <span class="number">3001</span>,        <span class="comment">/** 击退 */</span></span><br><span class="line">    PushFly = <span class="number">3002</span>,         <span class="comment">/** 击飞 */</span></span><br><span class="line">    ChangeAttack = <span class="number">4001</span>,    <span class="comment">/** 改变普攻 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EBuffClass &#123;</span><br><span class="line">    Gain = <span class="number">1</span>, <span class="comment">/** 增益 */</span></span><br><span class="line">    DeBuff = <span class="number">2</span>,  <span class="comment">/** 减益 */</span></span><br><span class="line">    NoClear = <span class="number">4</span>, <span class="comment">/** 不可驱散 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBuff</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> character: BattleCharacter;</span><br><span class="line">    <span class="keyword">protected</span> buffDef: BuffDefine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _leftTime: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _caster: IBattleActionOwner;</span><br><span class="line">    <span class="keyword">private</span> _attrArr: <span class="built_in">Array</span>&lt;&#123; <span class="attr">type</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>; &#125;&gt;;</span><br><span class="line">    <span class="keyword">private</span> _loopEffect: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">b_reset</span>(<span class="params">character: BattleCharacter, buffDef: BuffDefine, caster: IBattleActionOwner</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.character = character;</span><br><span class="line">        <span class="built_in">this</span>._caster = caster;</span><br><span class="line">        <span class="built_in">this</span>.buffDef = buffDef;</span><br><span class="line">        <span class="built_in">this</span>._attrArr = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buffDef.AttrArr) &#123;</span><br><span class="line">            <span class="keyword">let</span> vals = buffDef.AttrArr.split(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> vals) &#123;</span><br><span class="line">                <span class="keyword">let</span> v = val.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>._attrArr.push(&#123; <span class="attr">type</span>: toNumber(v[<span class="number">0</span>]), <span class="attr">value</span>: toNumber(v[<span class="number">1</span>]) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._playKeepEffect();</span><br><span class="line">        <span class="built_in">this</span>.refreshLeftTime(buffDef.Duration);</span><br><span class="line">        <span class="built_in">this</span>.onReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> b_destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._stopKeepEffect();</span><br><span class="line">        <span class="built_in">this</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">b_update</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._leftTime -= dt;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 刷新剩余时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">refreshLeftTime</span>(<span class="params">leftTime: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._leftTime = leftTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _playKeepEffect(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> _stopKeepEffect(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** buff加上之前检查是否结束，比如自身免疫Debuff，则直接无视Debuff */</span></span><br><span class="line">    <span class="keyword">public</span> checkFinishedBeforeAdd(): <span class="built_in">boolean</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="comment">/** buff更新前检查结束 比如护盾buff次数被消耗殆尽 */</span></span><br><span class="line">    <span class="keyword">public</span> checkFinishedBeforeUpdate(): <span class="built_in">boolean</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="comment">/** buff更新后检查已经结束 一般非永久buff时间用完 */</span></span><br><span class="line">    <span class="keyword">public</span> checkFinishedAfterUpdate(): <span class="built_in">boolean</span> &#123; <span class="keyword">return</span> (<span class="built_in">this</span>.buffDef.Duration &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>._leftTime &lt; <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onReset(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onDestroy(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** buff 剩余时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">leftTime</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._leftTime; &#125;</span><br><span class="line">    <span class="comment">/** buff 来源 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">caster</span>(): <span class="title">IBattleActionOwner</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._caster; &#125;</span><br><span class="line">    <span class="comment">/** buff 类型 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">buffType</span>(): <span class="title">EBuffType</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.buffDef.BuffType; &#125;</span><br><span class="line">    <span class="comment">/** buff ID */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">buffID</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.buffDef.ID; &#125;</span><br><span class="line">    <span class="comment">/** buff 属性数组 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">attrArr</span>(): <span class="title">Array</span>&lt;&#123; <span class="keyword">type</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>; &#125;&gt; &#123; <span class="keyword">return</span> <span class="built_in">this</span>._attrArr; &#125;</span><br><span class="line">    <span class="comment">/** buff 分类 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">buffClass</span>(): <span class="title">EBuffClass</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.buffDef.BuffClass; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  子类继承实现具体细节即可，如一个嘲讽Buff<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 嘲讽 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoyBuff</span> <span class="keyword">extends</span> <span class="title">BaseBuff</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onReset(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.character.battleComp.setDecoyTarget(<span class="built_in">this</span>.caster <span class="keyword">as</span> BattleCharacter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.character.battleComp.setDecoyTarget(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Buff工厂"><a href="#Buff工厂" class="headerlink" title="Buff工厂"></a>Buff工厂</h2><p>  同时也需要一个Buff工厂对Buff进行回收管理，毕竟游戏中Buff对象还是比较多的，用一个Pool池管理方便Buff对象重置回收<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BuffFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _buffDic = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> create(character: BattleCharacter, <span class="attr">buffDef</span>: ssBuffDefine, <span class="attr">caster</span>: IBattleActionOwner): BaseBuff &#123;</span><br><span class="line">        <span class="keyword">let</span> buff: BaseBuff = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> buffType: EBuffType = buffDef.BuffType;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._buffDic[buffType] &amp;&amp; <span class="built_in">this</span>._buffDic[buffType].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buff = <span class="built_in">this</span>._buffDic[buffType].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (buffType) &#123;</span><br><span class="line">                <span class="keyword">case</span> EBuffType.BaseAttr:</span><br><span class="line">                    buff = <span class="keyword">new</span> BaseAttrBuff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EBuffType.DynamicAttr:</span><br><span class="line">                    buff = <span class="keyword">new</span> DynamicAttrBuff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EBuffType.Dizzy:</span><br><span class="line">                    buff = <span class="keyword">new</span> DizzyBuff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EBuffType.Silence:</span><br><span class="line">                    buff = <span class="keyword">new</span> SilenceBuff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 其他buff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buff) &#123;</span><br><span class="line">            buff.b_reset(character, buffDef, caster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">garbage</span>(<span class="params">buff: BaseBuff</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">this</span>._buffDic[buff.buffType];</span><br><span class="line">        <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">            arr = [];</span><br><span class="line">            <span class="built_in">this</span>._buffDic[buff.buffType] = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        buff.b_destroy();</span><br><span class="line">        arr.push(buff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="角色Buff组件"><a href="#角色Buff组件" class="headerlink" title="角色Buff组件"></a>角色Buff组件</h1><p>角色Buff组件主要是将角色身上的Buff组织起来进行有效管理，注意Buff在战斗中是属性的一个提供者，需要在属性组件中注册，并且在添加和移除Buff时候需要调用<code>syncAttr</code>同步属性组件中的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleBuffComponent</span> <span class="keyword">extends</span> <span class="title">CharBattleBaseComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _buffList: <span class="built_in">Array</span>&lt;BaseBuff&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._buffList = [];</span><br><span class="line">        <span class="built_in">this</span>.character.attrComp.registerAttrProvider(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">onUpdate</span>(<span class="params">dt: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="built_in">this</span>._buffList.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> buff = <span class="built_in">this</span>._buffList[index];</span><br><span class="line">            <span class="keyword">if</span> (buff.checkFinishedBeforeUpdate()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.removeBuff(buff);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buff.b_update(dt);</span><br><span class="line">                <span class="keyword">if</span> (buff.checkFinishedAfterUpdate()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.removeBuff(buff);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> buff <span class="keyword">of</span> <span class="built_in">this</span>._buffList) &#123;</span><br><span class="line">            BuffFactory.garbage(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._buffList = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加buff</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>buffID buff表id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>caster buff释放来源，可为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">addBuff</span>(<span class="params">buffDef: ssBuffDefine, caster?: IBattleActionOwner</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先处理同ID buff 叠加层数</span></span><br><span class="line"><span class="comment">         * 这里注意叠加层数 是某一个ID Buff的叠加</span></span><br><span class="line"><span class="comment">         * 有叠加上限且达到叠加上限且不是永久buff,刷新当前最早添加的buff</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再处理同ID buff 刷新时间</span></span><br><span class="line"><span class="comment">         * 判断需要刷新同ID其他buff时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 有些buff例如 击退 击飞 嘲讽 等</span></span><br><span class="line"><span class="comment">         * 不管叠加层数，该类型buff永远只能共存一个</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._addBuff(buffDef, caster);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_addBuff</span>(<span class="params">buffDef: ssBuffDefine, caster: IBattleActionOwner</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> buff = BuffFactory.create(<span class="built_in">this</span>.character, buffDef, caster);</span><br><span class="line">        <span class="keyword">if</span> (buff.checkFinishedBeforeAdd()) &#123;</span><br><span class="line">            BuffFactory.garbage(buff);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._buffList.push(buff);</span><br><span class="line">            <span class="built_in">this</span>.character.attrComp.syncAttr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getAttr(): BaseAttr &#123;</span><br><span class="line">        <span class="keyword">let</span> finalAttr = <span class="keyword">new</span> BaseAttrBaseAttr();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> buff <span class="keyword">of</span> <span class="built_in">this</span>._buffList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buff.attrArr) &#123;</span><br><span class="line">                finalAttr.addAttrArray(buff.attrArr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">removeBuff</span>(<span class="params">buff: BaseBuff</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">removeBuffByType</span>(<span class="params">buffType: EBuffType</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">removeBuffByCaster</span>(<span class="params">buffCaster: IBattleActionOwner</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">removeBuffByClass</span>(<span class="params">buffClass: EBuffClass</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> hasBuff(buffType: EBuffType): <span class="built_in">boolean</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 进入被击状态（晕眩冰冻等等） */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">enterBeHit</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 可以被移动 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canBeMove</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 可以被击飞 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canBePushFly</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 可以被击退 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canBePushBack</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 束缚击退击飞情况下不可以移动 特指自己主观想动 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canMove</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 可以被敌人选中 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canSelect</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 可以使用技能（沉默和晕眩放不出技能） */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">canUseSkill</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** 在变身阶段 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">inModeChange</span>(): <span class="title">boolean</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h1><p>  游戏中经常有物理伤害，魔法伤害，真实伤害等等，也会对应的有免疫伤害护盾，只免疫物理伤害护盾，只免疫魔法伤害护盾等等，做这些设计的时候，例如可以在BaseBuff中加入<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 真正受到伤害前的处理 比如免伤护盾 减伤护盾 */</span></span><br><span class="line"><span class="keyword">public</span> processBeforeBeDamage(damageValue: <span class="built_in">number</span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> damageValue; &#125;</span><br></pre></td></tr></table></figure><br>  然后在 CharBattleBuffComponent中加入<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">processBeforeBeDamage</span>(<span class="params">damageValue: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._buffList) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> buff <span class="keyword">of</span> <span class="built_in">this</span>._buffList) &#123;</span><br><span class="line">        damageValue = buff.processBeforeBeDamage(damageValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> damageValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  比如免伤护盾中就可以这样实现<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 免伤护盾 有次数 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NoDamageShieldBuff</span> <span class="keyword">extends</span> <span class="title">BaseBuff</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 免疫次数 */</span></span><br><span class="line">    <span class="keyword">private</span> _noDamageCount: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">protected</span> override onReset(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._noDamageCount = RatelUtil.toNumber(<span class="built_in">this</span>.buffDef.Params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 次数归零就可以清除了 */</span></span><br><span class="line">    <span class="keyword">public</span> override checkFinishedBeforeUpdate(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._noDamageCount &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 免伤护盾消耗一次次数将伤害归零 */</span></span><br><span class="line">    <span class="keyword">public</span> override <span class="function"><span class="title">processBeforeBeDamage</span>(<span class="params">damageValue: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (damageValue &lt;= <span class="number">0</span> || <span class="built_in">this</span>._noDamageCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> damageValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --<span class="built_in">this</span>._noDamageCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  当有物理魔法伤害之分时，可以将damageValue改为一个结构，都是可以根据需求慢慢拓展的。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>  角色的Buff模块在开发中会有各种拓展，对逻辑要求比较高，需要理清逻辑再开发，如各个buff优先级，buff间的抵消等等，在buff中会给玩家加各种状态，如被束缚不能移动，被沉默晕眩不能释放技能，在比较小型的项目Buff数量不是特别多，可以通过在bufflist中判断有无对应buff，当逻辑比较复杂以后，可以考虑用位运算，给角色加上标记信息，可以更方便管理。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> BuffFlag &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/**禁止移动 */</span></span><br><span class="line">    OccMove = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/**禁止放技能 */</span></span><br><span class="line">    OccCast = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/**禁止转向 */</span></span><br><span class="line">    OccTurn = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(六) 角色设计-模型</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AD)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  角色设计中的模型模块属于表现部分，游戏中会有设置模型位置，朝向，大小，模型播放动作等需求，并且在表现上也会伴随各种位置，整体位置，受击位置，特效位置，释放技能位置，飘字位置等等，在模型组件中将这些信息统一管理使得其他模块可以直接调用。</p>
<h1 id="基础模型组件"><a href="#基础模型组件" class="headerlink" title="基础模型组件"></a>基础模型组件</h1><p>  基础模型组件中管理了角色模型的各种信息，包括<code>碰撞体(CapsuleCollider)</code>,<code>层级(LayerMask)</code>,<code>DOTween</code>等都可以在这里封装接口供外部使用<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharAnimComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 设置角色的位置 */</span></span><br><span class="line">  <span class="keyword">public</span> setPosition(pos: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置角色方向 1 */</span></span><br><span class="line">  <span class="keyword">public</span> setDirection1(yaw: <span class="built_in">number</span>, <span class="attr">degree</span>: <span class="built_in">boolean</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置角色方向 2 */</span></span><br><span class="line">  <span class="keyword">public</span> setDirection2(dir: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置角色方向 3 */</span></span><br><span class="line">  <span class="keyword">public</span> setDirection3(qat: Quaternion): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 播放动画 */</span></span><br><span class="line">  <span class="keyword">public</span> playAnimation(animName: <span class="built_in">string</span>, <span class="attr">animSpeed</span>: <span class="built_in">number</span>, <span class="attr">fadeTime</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 角色的位置信息 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">position</span>(): <span class="title">Vector3</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色的朝向信息 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">rotation</span>(): <span class="title">Vector3</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色的Trans根节点信息 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">rootTran</span>(): <span class="title">Transform</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色root gameobject */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">rootGO</span>(): <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色的正方向 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">forward</span>(): <span class="title">Vector3</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色的角度信息 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">yaw</span>(): <span class="title">number</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色碰撞体的范围半径 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">radius</span>(): <span class="title">number</span> &#123; &#125;</span><br><span class="line">  <span class="comment">/** 角色的身高 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">height</span>(): <span class="title">number</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="战斗模型组件"><a href="#战斗模型组件" class="headerlink" title="战斗模型组件"></a>战斗模型组件</h1><p>  基础模型组件是方便其他类型角色共有，战斗中有些特殊的位置信息，还需要额外封装一层CharBattleAnimComponent，方便战斗时候使用<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleAnimComponent</span> <span class="keyword">extends</span> <span class="title">CharAnimComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 受击位置 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hitPosition</span>(): <span class="title">Vector3</span> &#123;</span><br><span class="line">    <span class="comment">//省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 技能释放位置 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">actionPosition</span>(): <span class="title">Vector3</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 血条位置 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpPosition</span>(): <span class="title">Vector3</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 飘字位置 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">numPosition</span>(): <span class="title">Vector3</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 特效位置 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">EffectPosition</span>(): <span class="title">Vector3</span> &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十一) 角色设计-战斗血量</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%80)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E8%A1%80%E9%87%8F/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  血量模块（即血条，有些游戏还会有能量条，蓝条等等），几乎是每个游戏都会有的设计了，将血量模块单独划分出来，专门处理战斗中血量的变化，并管理角色存活死亡状态，有助于代码上的解耦。</p>
<h1 id="血量-护盾-管理"><a href="#血量-护盾-管理" class="headerlink" title="血量(护盾)管理"></a>血量(护盾)管理</h1><p>  由于战斗中会有护盾Buff的存在，有护盾Buff时会代替血量扣除，将护盾做成属性，并且和血量一起管理，对外统一暴露changeHP接口会比较方便，并且需要注册监听属性改变消息，当最大血量或者最大护盾改变时，需要对应调整数值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleHPComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 角色处于血量归零 播放死亡动作状态 */</span></span><br><span class="line">    <span class="keyword">private</span> _isDying: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 角色已经播放完死亡动作 */</span></span><br><span class="line">    <span class="keyword">private</span> _isDead: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _maxHP: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _curHP: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _maxShiled: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _curShield: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._isDying = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>._isDead = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>._maxHP = <span class="built_in">this</span>._curHP = <span class="built_in">this</span>.character.attrComp.attr.hp;</span><br><span class="line">        <span class="comment">// 血条</span></span><br><span class="line">        <span class="comment">// 监听角色的属性改变事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一扣血接口 血量归零就死亡</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">changeHP</span>(<span class="params">num: <span class="built_in">number</span>, ignoreSheild: <span class="built_in">boolean</span> = <span class="literal">false</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣护盾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">_changeHPShield</span>(<span class="params">num: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理角色属性改变</span></span><br><span class="line">    <span class="keyword">private</span> _onHandleAttrChange(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 处理护盾最大值改变</span></span><br><span class="line">        <span class="comment">// 处理血量最大值改变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hp</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>._curHP; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpShield</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>._curShield; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isDead</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._isDead; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isDying</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._isDying; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时回血（扣血）"><a href="#定时回血（扣血）" class="headerlink" title="定时回血（扣血）"></a>定时回血（扣血）</h1><p>  游戏中会有一些定时回血Buff（奶妈的缓回Buff等等），定时扣血Buff（毒Buff等等），因为和血量息息相关，并且适合统一做成属性，也可以放到血量模块中<br>  在AttrID中定义属性字段<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 每秒回血 (固定值) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HPAddSecond: <span class="built_in">number</span> = <span class="number">31</span>;</span><br><span class="line"><span class="comment">/** 每秒回血 (百分比) 0-1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HPAddPerSecond: <span class="built_in">number</span> = <span class="number">131</span>;</span><br><span class="line"><span class="comment">/** 每秒掉血（固定值） */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HPReduceSecond: <span class="built_in">number</span> = <span class="number">32</span>;</span><br><span class="line"><span class="comment">/** 每秒掉血（百分比）0-1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HPReducePerSecond: <span class="built_in">number</span> = <span class="number">132</span>;</span><br></pre></td></tr></table></figure><br>  并在BaseAttr中注册接口<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpAddSecond</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.getValue(AttrID.HPAddSecond); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpAddPerSecond</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.getValue(AttrID.HPAddPerSecond); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpReduceSecond</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.getValue(AttrID.HPReduceSecond); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hpReducePerSecond</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.getValue(AttrID.HPReducePerSecond); &#125;</span><br></pre></td></tr></table></figure><br>  在血量模块的update中每秒刷新<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._nextRecoverTime -= dt;</span><br><span class="line">    <span class="built_in">this</span>._nextReduceTime -= dt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._nextRecoverTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._nextRecoverTime = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>._checkRecover();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._nextReduceTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._nextReduceTime = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>._checkReduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 定时回血 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="title">_checkRecover</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> charAttr = <span class="built_in">this</span>.character.attrComp.attr;</span><br><span class="line">    <span class="keyword">if</span> (charAttr.hpAddSecond &gt; <span class="number">0</span> || charAttr.hpAddPerSecond &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isDying) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isMaxHP) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最多回到满血</span></span><br><span class="line">        <span class="keyword">let</span> hpAdd = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.maxHP * charAttr.hpAddPerSecond + charAttr.hpAddSecond, <span class="built_in">this</span>.maxHP - <span class="built_in">this</span>._curHP);</span><br><span class="line">        <span class="built_in">this</span>.changeHP(hpAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 定时扣血 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="title">_checkReduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> charAttr = <span class="built_in">this</span>.character.attrComp.attr;</span><br><span class="line">    <span class="keyword">if</span> (charAttr.hpReduceSecond &gt; <span class="number">0</span> || charAttr.hpReducePerSecond &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isDying) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最多扣剩余血量和剩余护盾值</span></span><br><span class="line">        <span class="keyword">let</span> hpReduce = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.maxHP * charAttr.hpReducePerSecond + charAttr.hpReduceSecond, <span class="built_in">this</span>._curShield + <span class="built_in">this</span>._curHP);</span><br><span class="line">        <span class="comment">// 扣血前 buff模块判断有没有免伤护盾等等</span></span><br><span class="line">        hpReduce = <span class="built_in">this</span>.character.battleBuffComp.processBeforeBeDamage(hpReduce);</span><br><span class="line">        <span class="keyword">if</span> (hpReduce &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.changeHP(-hpReduce);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十三) 宝物管理</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%89)-%E5%AE%9D%E7%89%A9%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在介绍角色具体技能的实现机制之前，需要先介绍项目中另外一项机制——<code>宝物</code>，因为宝物的存在，导致技能实现机制在一定程度上需要做出调整。</p>
<h1 id="机制介绍"><a href="#机制介绍" class="headerlink" title="机制介绍"></a>机制介绍</h1><p>  战斗中玩家可以携带最多三种宝物，每种宝物可以释放一种技能，宝物分被动宝物和主动宝物，被动宝物自动生效，主动宝物自动战斗情况下满足条件自动释放，非自动情况下可以由玩家手动释放。</p>
<ul>
<li>被动宝物如：<ul>
<li>使攻击力最高的2个角色，攻击力增加x%。（有角色死亡自动更换目标）</li>
<li>使所有角色的攻击力增加x%。</li>
<li>本局对战金币额外增加x%。</li>
</ul>
</li>
<li>主动宝物如：<ul>
<li>使我方当前体力最低的角色恢复所有角色攻击力x%的体力。</li>
<li>在最近的人处释放一团火炬，并对火炬附近的敌人造成攻击力x%的持续伤害。</li>
<li>使最近的敌人防御降低x%。</li>
</ul>
</li>
</ul>
<h1 id="宝物管理"><a href="#宝物管理" class="headerlink" title="宝物管理"></a>宝物管理</h1><p>  从需求来看，宝物相当于一个隐藏角色跟在队伍身边，设计上也需要像角色一样对宝物进行生命周期的管理，并且也需要区分我方宝物和敌方宝物（pvp）。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleTreasureSP</span> <span class="keyword">extends</span> <span class="title">SceneProcessorBase</span>&lt;<span class="title">BattleScene</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> playerTreasures: <span class="built_in">Array</span>&lt;BattleTreasure&gt; = [];</span><br><span class="line">  <span class="keyword">public</span> enemyTreasures: <span class="built_in">Array</span>&lt;BattleTreasure&gt; = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.playerTreasures = [];</span><br><span class="line">      <span class="built_in">this</span>.enemyTreasures = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> playerTreasure <span class="keyword">of</span> <span class="built_in">this</span>.playerTreasures) &#123;</span><br><span class="line">          playerTreasure.update(dt);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> enemyTreasure <span class="keyword">of</span> <span class="built_in">this</span>.enemyTreasures) &#123;</span><br><span class="line">          enemyTreasure.update(dt);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">createTreasure</span>(<span class="params">sideType: BattleSideType, treasureID: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> treasure: BattleTreasure;</span><br><span class="line">     <span class="comment">// 省略细节</span></span><br><span class="line">     <span class="keyword">if</span> (treasure.isPlayerSide) &#123;</span><br><span class="line">         <span class="built_in">this</span>.playerTreasures.push(treasure);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.enemyTreasures.push(treasure);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> treasure;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="宝物基础"><a href="#宝物基础" class="headerlink" title="宝物基础"></a>宝物基础</h1><p>  和角色的设计一样，也采取<code>组件</code>机制。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _treasure: BattleTreasure;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">treasure</span>(): <span class="title">TTreasure</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._treasure; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">treasure: BattleTreasure</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>._treasure = treasure;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> init(args?: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onInit.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> onInit(...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">  <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">  <span class="keyword">protected</span> onDestroy(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  由于宝物没有实际的载体，所以在例如最近的敌人之类的计算上，需要将宝物绑定上对应的角色列表，并在角色列表种选取最靠前的角色作为释放技能的载体，即<code>宿主</code>，所以宝物也有部分组件依赖于宿主。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 宝物属性 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> attrComp: TreasureAttrCompontent;</span><br><span class="line"><span class="comment">/** 宝物战斗 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleComp: TreasureBattleCompontent;</span><br><span class="line"><span class="comment">/** 宝物技能 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> skillComp: TreasureSkillComponent;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十二) 角色设计-战斗移动</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  角色的移动是否做成组件取决于项目本身的复杂度，如果项目本身只有一个方向的移动，或者移动比较简单，是可以不用单独做成一个组件的，这里笔者根据项目需求在迭代过程中慢慢整合到了一个单独的组件。</p>
<h1 id="组件无状态"><a href="#组件无状态" class="headerlink" title="组件无状态"></a>组件无状态</h1><p>  由于一般情况下战斗是左右双方交战，战斗中会存在大量判断是否朝左朝右，这里采取和前面战斗组件相同的<code>无状态</code>方式，在组件初始化时，将角色默认初始方向传入，将判断左右的信息由<code>xFactor</code>代替。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleMoveComponent</span> <span class="keyword">extends</span> <span class="title">CharacterComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _defaultSpeedRatio: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> _defaultDirection: Vector3;</span><br><span class="line">  <span class="keyword">private</span> _tempDirection: Vector3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onInit(direction = Vector3.right, <span class="attr">speedRatio</span>: <span class="built_in">number</span> = <span class="number">1</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      speedRatio || (speedRatio = <span class="number">1</span>);</span><br><span class="line">      direction || (direction = Vector3.right);</span><br><span class="line">      <span class="built_in">this</span>._defaultSpeedRatio = speedRatio;</span><br><span class="line">      <span class="built_in">this</span>._defaultDirection = direction;</span><br><span class="line">      <span class="built_in">this</span>.character.setDirection(<span class="built_in">this</span>._defaultDirection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 朝着目标移动一段距离 */</span></span><br><span class="line">  <span class="keyword">public</span> moveToPos(dt: <span class="built_in">number</span>, <span class="attr">moveDistance</span>: <span class="built_in">number</span> = <span class="number">0</span>, <span class="attr">position</span>: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">// 角色朝着目标移动一定距离</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 没有目标移动 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">move</span>(<span class="params">dt: <span class="built_in">number</span>, moveDistance: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 角色朝着既定方向移动一段距离</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 倒退一段距离 */</span></span><br><span class="line">  <span class="keyword">public</span> moveBack(x: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">// 角色后退一段距离</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置临时方向 */</span></span><br><span class="line">  <span class="keyword">public</span> setTempDirection(direction: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._tempDirection = direction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 速度 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">speed</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.character.attrComp.attr.moveSpeed; &#125;</span><br><span class="line">  <span class="comment">/** 加速比例 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">speedRatio</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._defaultSpeedRatio; &#125;</span><br><span class="line">  <span class="comment">/** 方向 有临时方向用临时方向 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">direction</span>(): <span class="title">Vector3</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._tempDirection ? <span class="built_in">this</span>._tempDirection : <span class="built_in">this</span>._defaultDirection; &#125;</span><br><span class="line">  <span class="comment">/** x轴系数 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">xFactor</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._defaultDirection.x &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="角色方阵"><a href="#角色方阵" class="headerlink" title="角色方阵"></a>角色方阵</h1><h2 id="需求剖析"><a href="#需求剖析" class="headerlink" title="需求剖析"></a>需求剖析</h2><p>  这里由于项目有其他需求还有一些额外的内容，虽然是根据具体项目而来，但是在其中的设计花了不少心思，还是记录一下，先花一点篇幅介绍一下需求，这里需要引入一个新的概念<code>角色方阵</code>。<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img1.png" alt="在这里插入图片描述"><br>  角色在行走过程中会按照如图所示的方阵行走，注意以上图中所有方块都是一个spaceX*spaceZ的方块，角色是站在方块正中间的，如下图所示：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img7.png" alt="在这里插入图片描述"><br>  根据所处位置，会分为前排(1,2,3)，中排(4,5,6)，后排(7,8,9)，角色按照一定的阵形位置入场，每一排最多两个角色，当每排角色为两个时，角色会站在两边，当每排角色为一个时，会站在中间，此规则战斗中有角色死亡也会实时调整。<br>  比如上阵四个角色，前排两个，中排一个，后排一个，他们站位将会是前排站在两边位置(1,3)，中排站在中间位置(5)，后排站在中间位置(8)。如下图所示：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img2.png" alt="在这里插入图片描述"><br>  当在战斗中1号位角色死亡时，3号位角色会顺势调整到2号位，如下图所示：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img3.png" alt="在这里插入图片描述"><br>  角色会按照方阵阵形行走，当方阵中有人员掉队时，掉队的人员会按照设定好的加速倍率加速追上大部队，如下图所示：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img4.png" alt="在这里插入图片描述"><br>  这里有一个细节，也是坑点，由于角色行走是按一定顺序依次执行的，如1号位-&gt;3号位-&gt;5号位-&gt;8号位的顺序，所以需要在所有人行走前计算谁才是最靠前的角色（这里的最靠前指的是<code>方阵相对位置</code>最靠前，并不是物理位置最靠前），如下图是8号位最靠前，而不是物理位置最前面的3号位最靠前：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img5.png" alt="在这里插入图片描述"><br>  所以这里需要先计算出8号位是方阵相对位置最靠前的，然后以8号位为基准，其他人全部加速行走到虚线位置。（注意此时8号位玩家也是往前走的，所以其他人必须加速行走才能走到虚线位置）<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/img6.png" alt="在这里插入图片描述"></p>
<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>  可以看出，需要一个地方存储方阵的很多信息，并且存在很多定制化代码，并且当竞技场中出现敌方也有方阵时，会有很多冗余代码并且难以维护，之前的设计中会在BaseBattle中定义Static变量存储方阵信息，代码会非常丑陋。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>  这里在重构了很多次以后，总算有了比较合适的解决方案:</p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><p>  定义接口<code>IBattleSquareMember</code>代表方阵成员<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBattleSquareMember &#123;</span><br><span class="line">    <span class="comment">/** 成员出生位置 */</span></span><br><span class="line">    <span class="attr">bornIndex</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 成员是否有效（参与方阵计算） */</span></span><br><span class="line">    isValid: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 以该成员为基准的方阵X轴坐标 */</span></span><br><span class="line">    frontlineX: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h3><p>  设计一个角色方阵<code>BattleSquare</code>用来组织角色方阵内的各种计算<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个战斗方阵(只做了X轴方向的) */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleSquare</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 方正朝向 */</span></span><br><span class="line">    <span class="keyword">private</span> _xFactor: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 方阵成员 */</span></span><br><span class="line">    <span class="keyword">private</span> _squareMembers: <span class="built_in">Array</span>&lt;IBattleSquareMember&gt;;</span><br><span class="line">    <span class="comment">/** 方阵前方线位置 */</span></span><br><span class="line">    <span class="keyword">private</span> _squarelinePos: Vector3;</span><br><span class="line">    <span class="comment">/** 方阵x间距 */</span></span><br><span class="line">    <span class="keyword">private</span> _squareSpaceX: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 方阵z间距 */</span></span><br><span class="line">    <span class="keyword">private</span> _squareSpaceZ: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 方阵推进速度 */</span></span><br><span class="line">    <span class="keyword">private</span> _squareSpeed: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">frontlinePos: Vector3, xFactor: <span class="built_in">number</span>, speed: <span class="built_in">number</span>, spaceX: <span class="built_in">number</span>, spaceZ: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._squarelinePos = frontlinePos;</span><br><span class="line">        <span class="built_in">this</span>._xFactor = xFactor;</span><br><span class="line">        <span class="built_in">this</span>._squareSpeed = speed;</span><br><span class="line">        <span class="built_in">this</span>._squareSpaceX = spaceX;</span><br><span class="line">        <span class="built_in">this</span>._squareSpaceZ = spaceZ;</span><br><span class="line">        <span class="built_in">this</span>._squareMembers = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">addSquareMember</span>(<span class="params">squareMember: IBattleSquareMember</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._squareMembers.push(squareMember);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> updateFrontline(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 计算当前最前方位置以及下一次可能的最前方位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getSquareMovePos(bornIndex: <span class="built_in">number</span>): Vector3 &#123;</span><br><span class="line">       <span class="comment">// 获取方阵中角色应该在的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">xFactor</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._xFactor; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">squarelinePos</span>(): <span class="title">Vector3</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._squarelinePos; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">squareSpeed</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._squareSpeed; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关联角色"><a href="#关联角色" class="headerlink" title="关联角色"></a>关联角色</h3><p>  现在需要将方阵和角色关联上，也算是整个设计的核心，抽象一层<code>CharBattleSquareMoveComponent</code>，并且将move和moveToPos接口覆盖实现<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 专门用于战斗中的方阵移动 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleSquareMoveComponent</span> <span class="keyword">extends</span> <span class="title">CharBattleMoveComponent</span> <span class="title">implements</span> <span class="title">IBattleSquareMember</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 方阵出生位置 */</span></span><br><span class="line">    <span class="keyword">private</span> _bornIndex: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 所处战斗方阵 */</span></span><br><span class="line">    <span class="keyword">private</span> _battleSquare: BattleSquare;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(direction = Vector3.right, <span class="attr">speedRatio</span>: <span class="built_in">number</span> = <span class="number">1</span>, battleSquare?: BattleSquare, bornIndex?: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onInit(direction, speedRatio);</span><br><span class="line">        <span class="built_in">this</span>._battleSquare = battleSquare;</span><br><span class="line">        <span class="built_in">this</span>._bornIndex = bornIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> override moveToPos(dt: <span class="built_in">number</span>, <span class="attr">moveDistance</span>: <span class="built_in">number</span> = <span class="number">0</span>, <span class="attr">position</span>: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否落后于应该在的位置 加速 （省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> override <span class="function"><span class="title">move</span>(<span class="params">dt: <span class="built_in">number</span>, moveDistance: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否落后于应该在的位置 加速 （省略实现）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方阵角色有死亡修正一下bornIndex */</span></span><br><span class="line">    <span class="keyword">private</span> _amendBornIndex(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._bornIndex = <span class="built_in">this</span>._battleSquare.getAmendBornIndex(<span class="built_in">this</span>._bornIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实现接口，成员出生位置 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">bornIndex</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._bornIndex; &#125;</span><br><span class="line">    <span class="comment">/** 实现接口，角色存活则有效 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isValid</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> !<span class="built_in">this</span>.character.battleHPComp.isDying; &#125;</span><br><span class="line">    <span class="comment">/** 实现接口，以该成员为基准的方阵X轴坐标 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">frontlineX</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.character.position.x + <span class="built_in">this</span>._battleSquare.getOffsetX(<span class="built_in">this</span>._bornIndex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="游戏中应用"><a href="#游戏中应用" class="headerlink" title="游戏中应用"></a>游戏中应用</h3><p>  这样就可以创建一个方阵<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> BattleSquare(bornPos, xFactor, speed, spaceX, spaceZ);</span><br><span class="line"><span class="keyword">let</span> allBornPos = square.getSquareBornPos();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; characterIDs.length; ++i) &#123;</span><br><span class="line">  <span class="keyword">let</span> character;</span><br><span class="line">  <span class="comment">// 省略细节</span></span><br><span class="line">  character.battleMoveComp = character.addComponent(CharBattleSquareMoveComponent, Vector3.create(xFactor, <span class="number">0</span>, <span class="number">0</span>), speedRatio, square, bornIndexs[i]);</span><br><span class="line">  square.addSquareMember(character.getComponent(CharBattleSquareMoveComponent));</span><br><span class="line">  <span class="comment">// 省略细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样所有的信息全部内聚在BattleSquare中，并且对于move组件来说，也无需关注使用的是CharBattleSquareMoveComponent还是CharBattleMoveComponent。调用统一的接口move和moveToPos即可。当然这里也可以把move组件包装成抽象组件baseMove，分别实现normalMove和squareMove。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十九) 技能设计-Action发射器</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B9%9D)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%91%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从前文中可以看出，<code>Emit</code>（发射器）在<code>Action</code>初始化阶段就生成用于产生<code>Entity</code>（攻击实体），下面主要讲一些<code>Emit</code>的实现。</p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>  下面通过几个游戏中常见的技能，根据这些技能来设计<code>Emit</code></p>
<ul>
<li>战士挥舞手上的刀，对自身周围一圈半径5m的范围的敌方单位造成一次伤害。</li>
<li>药师在我方阵形最中间的单位脚下播种一块治疗草，处于治疗草范围的友方单位每秒回血。</li>
<li>朝前方连续射三支箭，分别打向随机的敌人。</li>
</ul>
<p> 从<code>Emit</code>角度简单分析上面列举的几个技能，会发现<code>Action</code>需要先根据一定的规则选择一个目标单位，以该目标单位为基准点架设<code>Emit</code>（也可能会在该基准点周围一定偏移位置，如最近的友方单位前5米处释放xxx），并设置好发射的实体数量（一次伤害，5秒内每秒回血），按照某种规则，如每隔一段时间发射（治疗草每秒回血），一次性发射完（射三支箭）等等，并且需要给发射的实体设置位置，方向等信息。</p>
<h1 id="发射器设计"><a href="#发射器设计" class="headerlink" title="发射器设计"></a>发射器设计</h1><h2 id="发射器配置"><a href="#发射器配置" class="headerlink" title="发射器配置"></a>发射器配置</h2><p>  下面来实现一个通用的发射器，首先是发射器的配置。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 发射规则 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EmitRuleType &#123;</span><br><span class="line">  <span class="comment">/** 间隔发射 */</span></span><br><span class="line">  Interval = <span class="string">&quot;Interval&quot;</span>,</span><br><span class="line">  <span class="comment">/** 同时发射 */</span></span><br><span class="line">  SameTime = <span class="string">&quot;SameTime&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 发射器方向类型 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EEmitterDirType &#123;</span><br><span class="line">  <span class="comment">/** 自己朝向 */</span></span><br><span class="line">  SelfDir = <span class="string">&quot;SelfDir&quot;</span>,</span><br><span class="line">  <span class="comment">/** 目标朝向 */</span></span><br><span class="line">  TargetDir = <span class="string">&quot;TargetDir&quot;</span>,</span><br><span class="line">  <span class="comment">/** 自己和目标连线朝向 */</span></span><br><span class="line">  SelfAndTargetDir = <span class="string">&quot;SelfAndTargetDir&quot;</span>,</span><br><span class="line">  <span class="comment">/** 目标和自己连线朝向 */</span></span><br><span class="line">  TargetAndSelfDir = <span class="string">&quot;TargetAndSelfDir&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 发射器需要根据规则选择某一个单位 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IEmitTargetCfg <span class="keyword">extends</span> IBattleTargetCfg &#123;</span><br><span class="line">    <span class="comment">/** 第几个单位 */</span></span><br><span class="line">    <span class="keyword">readonly</span> OrderNum: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 简单的发射器规则 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IEmitCfg <span class="keyword">extends</span> IEmitTargetCfg &#123;</span><br><span class="line">    <span class="comment">/** 发射数量 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Num: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 发射间隔 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Interval: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 发射类型 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Type: EmitRuleType;</span><br><span class="line">    <span class="comment">/** 发射器初始方向类型 */</span></span><br><span class="line">    <span class="keyword">readonly</span> DirType: EEmitterDirType;</span><br><span class="line">    <span class="comment">/** 发射器初始位置相对位置 */</span></span><br><span class="line">    <span class="keyword">readonly</span> EmitOffset: Vector3;</span><br><span class="line">    <span class="comment">/** 发射器初始位置相对朝向 */</span></span><br><span class="line">    <span class="keyword">readonly</span> EmitRotation: Vector3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="发射器实现"><a href="#发射器实现" class="headerlink" title="发射器实现"></a>发射器实现</h2>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEmit</span>&lt;<span class="title">TCfg</span> <span class="keyword">extends</span> <span class="title">IEmitCfg</span> </span>= IEmitCfg&gt; &#123;</span><br><span class="line">    <span class="comment">/** 属于Action */</span></span><br><span class="line">    <span class="keyword">private</span> b_action: BaseBattleAction;</span><br><span class="line">    <span class="comment">/** 发射器配置 */</span></span><br><span class="line">    <span class="keyword">private</span> b_emitCfg: TCfg;</span><br><span class="line">    <span class="comment">/** 发射时间计数 */</span></span><br><span class="line">    <span class="keyword">private</span> b_emitTimer: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 是否第一次发射 */</span></span><br><span class="line">    <span class="keyword">private</span> b_firstTime: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/** 发射数量计数 */</span></span><br><span class="line">    <span class="keyword">private</span> b_curNum: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">action: BaseBattleAction</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_action = action;</span><br><span class="line">        <span class="built_in">this</span>.b_emitCfg = action.actionCfg.EmitProperty <span class="keyword">as</span> TCfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> init(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_curNum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.b_emitTimer = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.b_firstTime = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.onInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmitDead)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/** 第一次直接发射，有间隔则延迟间隔发射 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.b_firstTime || <span class="built_in">this</span>.b_emitTimer &gt;= <span class="built_in">this</span>.emitCfg.Interval) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.emitCfg.Type) &#123;</span><br><span class="line">                <span class="keyword">case</span> EmitRuleType.Interval:</span><br><span class="line">                    <span class="built_in">this</span>._createActionEntity();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EmitRuleType.SameTime:</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.emitCfg.Num; ++i) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._createActionEntity();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.b_firstTime)</span><br><span class="line">                <span class="built_in">this</span>.b_firstTime = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">this</span>.b_emitTimer -= <span class="built_in">this</span>.emitCfg.Interval;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.b_emitTimer += dt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创造攻击实体 */</span></span><br><span class="line">    <span class="keyword">private</span> _createActionEntity(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_action.createActionEntity(<span class="built_in">this</span>.calStartPosition(), <span class="built_in">this</span>.calStartRotation());</span><br><span class="line">        <span class="built_in">this</span>.b_curNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onDispose();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onInit(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> onDispose(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> calStartPosition(): Vector3;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> calStartRotation(): Vector3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">emitCfg</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_emitCfg; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发射完所有实体死亡 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isEmitDead</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_curNum === <span class="built_in">this</span>.emitCfg.Num; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="发射器分类"><a href="#发射器分类" class="headerlink" title="发射器分类"></a>发射器分类</h1><p>   可以看到抽象出了三个计算位置方向信息的函数用于子类实现，实际运用中可以根据发射的类型，给发射器分类，如:<br>   <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EEmitType &#123;</span><br><span class="line">    None = <span class="string">&quot;None&quot;</span>,</span><br><span class="line">    <span class="comment">/** 普通攻击 */</span></span><br><span class="line">    Normal = <span class="string">&quot;Normal&quot;</span>,</span><br><span class="line">    <span class="comment">/** 弧状攻击 */</span></span><br><span class="line">    ARC = <span class="string">&quot;ARC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   下面实现一个普通发射器<code>NormalEmit</code>，根据锁敌规则计算出target并得出方向信息<br>   <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> INormalEmitCfg <span class="keyword">extends</span> IEmitCfg &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalEmit</span> <span class="keyword">extends</span> <span class="title">BaseEmit</span>&lt;<span class="title">INormalEmitCfg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _target: BattleCharacter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 根据规则计算出target</span></span><br><span class="line">        <span class="built_in">this</span>._target = <span class="built_in">this</span>.owner.battleComp.filterTargetByNum(<span class="built_in">this</span>.owner.battleComp.allList, <span class="built_in">this</span>.emitCfg.OrderNum, <span class="built_in">this</span>.emitCfg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算初始的发射位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> calStartPosition(): Vector3 &#123;</span><br><span class="line">       <span class="comment">// 根据target 计算初始位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算初始的发射朝向</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> calStartRotation(isUseEmitRotation: <span class="built_in">boolean</span> = <span class="literal">true</span>): Vector3 &#123;</span><br><span class="line">      <span class="comment">// 根据target 计算初始朝向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="发射器拓展"><a href="#发射器拓展" class="headerlink" title="发射器拓展"></a>发射器拓展</h1><p>  以上只是简单列举了一些思路，具体实现还需要结合实际表现进行调整，发射器的配置也是可以不断拓展的，如可以选择一块区域随机发射。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十七) 技能设计-ActionEvent</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%83)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-ActionEvent/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  前面介绍了<code>ActionEvent</code>代表了技能中的无生命周期的行为，一般用来实现技能中例如播放动作，播放特效的行为，下面介绍几个简单的实现。</p>
<h1 id="角色ActionEvent基类"><a href="#角色ActionEvent基类" class="headerlink" title="角色ActionEvent基类"></a>角色ActionEvent基类</h1>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ECharActionEventType &#123;</span><br><span class="line">  <span class="comment">/** 播放动作 */</span></span><br><span class="line">  PlayAnim = <span class="string">&quot;PlayAnim&quot;</span>,</span><br><span class="line">  <span class="comment">/** 播放特效 */</span></span><br><span class="line">  PlayEffect = <span class="string">&quot;PlayEffect&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICharActionEventCfg <span class="keyword">extends</span> IActionEventCfg &#123;</span><br><span class="line">    <span class="comment">/** 触发时间 */</span></span><br><span class="line">    <span class="attr">TriggerTime</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 事件类型 */</span></span><br><span class="line">    EventType: ECharActionEventType;</span><br><span class="line">    <span class="comment">/** 事件数据 */</span></span><br><span class="line">    EventData: ICharActionEventData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICharActionEventData &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCharActionEvent</span>&lt;<span class="title">TData</span> <span class="keyword">extends</span> <span class="title">ICharActionEventData</span> </span>= ICharActionEventData, TOwner <span class="keyword">extends</span> BaseCharacter = BaseCharacter&gt; <span class="keyword">extends</span> BaseActionEvent&lt;TOwner, ICharActionEventCfg&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">data</span>(): <span class="title">TData</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cfg.EventData <span class="keyword">as</span> TData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>  这里实现一个角色播放动作的样例：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> EventPlayAnimData <span class="keyword">extends</span> ICharActionEventData &#123;</span><br><span class="line">    <span class="comment">/** 动作 */</span></span><br><span class="line">    <span class="keyword">readonly</span> AnimName: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">/** 播放速度 */</span></span><br><span class="line">    <span class="keyword">readonly</span> AnimSpeed: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 融合时间 */</span></span><br><span class="line">    <span class="keyword">readonly</span> FadeTime: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPlayAnim</span> <span class="keyword">extends</span> <span class="title">BaseCharActionEvent</span>&lt;<span class="title">EventPlayAnimData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override onExecute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.owner.animComp.playAnimation(<span class="built_in">this</span>.data.AnimName, <span class="built_in">this</span>.data.AnimSpeed, <span class="built_in">this</span>.data.FadeTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>  游戏中很多行为都可以是<code>ActionEvent</code>，如：释放技能中的播放声音，播放特效，镜头抖动等等，也可以修改角色位移参数，角色传送参数，角色方向参数等等</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十五) 宝物设计-战斗技能</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%94)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  宝物的技能组件也是负责宝物的技能释放时机，具体的技能实现机制会在后面和角色技能一起阐述，<br>  宝物的技能分为主动技能和被动技能，在释放时机的处理上需要区分开来。</p>
<h1 id="技能基类"><a href="#技能基类" class="headerlink" title="技能基类"></a>技能基类</h1><p>  不管主动宝物还是被动宝物，技能的释放接口是一致的。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureSkillComponent</span> <span class="keyword">extends</span> <span class="title">TreasureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 技能释放目标集合 */</span></span><br><span class="line">  <span class="keyword">public</span> skillTargetList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">  <span class="comment">/** 释放技能 */</span></span><br><span class="line">  <span class="keyword">public</span> castSkill(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="comment">// 省略细节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="被动技能"><a href="#被动技能" class="headerlink" title="被动技能"></a>被动技能</h1><p>  目前仅根据需求实现了被动Buff技能组件，需要在角色死亡时更换技能释放目标。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasurePassiveBuffSkillComponent</span> <span class="keyword">extends</span> <span class="title">TreasureSkillComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.skillTargetList = [];</span><br><span class="line">      <span class="comment">// 监听宿主列表的角色死亡事件</span></span><br><span class="line">      <span class="built_in">this</span>.castSkill();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 处理角色死亡事件 */</span></span><br><span class="line">  <span class="keyword">private</span> _onHandelCharacterChange(character: BattleCharacter): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (character.sideType !== <span class="built_in">this</span>.treasure.sideType) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> target <span class="keyword">of</span> <span class="built_in">this</span>.skillTargetList) &#123;</span><br><span class="line">          target.battleBuffComp.removeBuffByCaster(<span class="built_in">this</span>.treasure);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.skillTargetList = [];</span><br><span class="line">      <span class="built_in">this</span>.castSkill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="主动技能"><a href="#主动技能" class="headerlink" title="主动技能"></a>主动技能</h1><p>  主动技能需要满足条件后释放（目前只有cd，可以空放），并且在释放完以后需要重置宝物技能cd<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureActiveSkillComponent</span> <span class="keyword">extends</span> <span class="title">TreasureSkillComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 技能总CD时间 */</span></span><br><span class="line">    <span class="keyword">private</span> _totalCoolDown: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 技能剩余CD时间 */</span></span><br><span class="line">    <span class="keyword">private</span> _coolDown: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resetCoolDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._coolDown &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._coolDown = <span class="built_in">this</span>._coolDown &gt; dt ? <span class="built_in">this</span>._coolDown - dt : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查自动战斗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 重置cd */</span></span><br><span class="line">    <span class="keyword">private</span> _resetCoolDown(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._totalCoolDown = <span class="built_in">this</span>.treasure.treasureDef.CoolDown;</span><br><span class="line">        <span class="built_in">this</span>._coolDown = <span class="built_in">this</span>.treasure.treasureDef.CoolDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断宝物技能是否可以释放 */</span></span><br><span class="line">    <span class="keyword">public</span> judgeCanTreasureCast(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.inCoolDown) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 释放技能并重置cd */</span></span><br><span class="line">    <span class="keyword">public</span> override castSkill(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.castSkill();</span><br><span class="line">        <span class="built_in">this</span>._resetCoolDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">inCoolDown</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._coolDown &gt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">coolDown</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._coolDown; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">coolDownPer</span>(): <span class="title">number</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._totalCoolDown === <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">this</span>._coolDown / <span class="built_in">this</span>._totalCoolDown; &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<h1 id="组件应用"><a href="#组件应用" class="headerlink" title="组件应用"></a>组件应用</h1><p>  在创建时候可以根据宝物类型添加不同的技能组件<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">treasure.battleComp = treasure.addComponent(TreasureBattleCompontent, hostList);</span><br><span class="line">treasure.attrComp = treasure.addComponent(TreasureAttrCompontent);</span><br><span class="line"><span class="keyword">if</span> (treasureDef.TreasureType === TreasureType.Active) &#123;</span><br><span class="line">    treasure.skillComp = treasure.addComponent(TreasureActiveSkillComponent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (treasureDef.TreasureType === TreasureType.PassiveBuff) &#123;</span><br><span class="line">    treasure.skillComp = treasure.addComponent(TreasurePassiveBuffSkillComponent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 其他类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十八) 技能设计-Action整体</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AB)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%95%B4%E4%BD%93/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  相对于无生命周期的<code>ActionEvent</code>，有生命周期的<code>Action</code>就会复杂很多，这里需要引入三个新概念<code>Emit</code>（发射器），<code>Entity</code>（攻击实体），<code>HitFeedback</code>（受击反馈），下面将会逐一介绍这些概念。</p>
<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>  在解释这些名词之前，先举几个例子帮助理解：</p>
<ul>
<li>一名厨师手拿厨刀朝着砧板上的食物剁了一刀，食物被剁成两半。</li>
<li>一名猎人手拿猎枪朝着远方的猎物发射了一颗子弹，片刻之后，子弹击中猎物，猎物受伤倒下。</li>
<li>一名医生手拿针管朝着面前的病人注射了一针麻醉药，病人被打完针以后睡着了。</li>
</ul>
<p>  下面把这几个例子都当作<code>Action</code>，可以找寻他们的共同点，这些<code>Action</code>都有<code>ActionOwner</code>（厨师，猎人，医生），并且都用<code>Emit发射器</code>（厨师的刀，猎人的枪，医生的针）发射出了<code>Entity攻击实体</code>（厨刀挥出的一刀，猎枪发射的子弹，针管注射的一针），并且都依靠<code>Entity攻击实体</code>搜寻到了目标单位（厨刀剁到的食物，子弹击中的猎物，针管注射到的病人），并对这些目标单位施加了<code>HitFeedback受击反馈</code>（食物被剁成了两半，猎物中枪受伤了，病人被打完针睡着了）。<br>  由上面的例子，可以看出一个<code>Action</code>会由<code>ActionOwner</code>执行，并且产生一个<code>Emit发射器</code>，<code>Emit发射器</code>会发射出<code>Entity攻击实体</code>，<code>Entity攻击实体</code>会依照一定条件搜寻目标，并对找寻的目标施加一定的受击反馈。</p>
<ul>
<li><code>ActionOwner</code>：Action执行者</li>
<li><code>Emit</code>: <code>Action</code>的依托载体，用于按照一定规则产生<code>Entity</code></li>
<li><code>Entity</code>: 由<code>Emit</code>发射出，用于按照一定规则搜集目标单位</li>
<li><code>HitFeedback</code>: 对<code>Entity</code>搜集到的目标单位施加的一定反馈</li>
</ul>
<h1 id="战斗Action"><a href="#战斗Action" class="headerlink" title="战斗Action"></a>战斗Action</h1><h2 id="战斗Action选取目标规则"><a href="#战斗Action选取目标规则" class="headerlink" title="战斗Action选取目标规则"></a>战斗Action选取目标规则</h2><p>  战斗中Action的规则可以有如下几个维度，目标站边类型，目标召唤物选取类型，按规则排序，<br>  召唤物规则排序等等<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ETargetSideType &#123;</span><br><span class="line">    <span class="comment">/** 我方 */</span></span><br><span class="line">    MySide = <span class="string">&quot;MySide&quot;</span>,</span><br><span class="line">    <span class="comment">/** 敌方 */</span></span><br><span class="line">    OtherSide = <span class="string">&quot;OtherSide&quot;</span>,</span><br><span class="line">    <span class="comment">/** 所有人 */</span></span><br><span class="line">    AllSide = <span class="string">&quot;AllSide&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ECondsSortType &#123;</span><br><span class="line">    <span class="comment">/** 自己 */</span></span><br><span class="line">    Self = <span class="string">&quot;Self&quot;</span>,</span><br><span class="line">    <span class="comment">/** 离我最近-&gt;离我最远 */</span></span><br><span class="line">    NearToMe = <span class="string">&quot;NearToMe&quot;</span>,</span><br><span class="line">    <span class="comment">/** 离我最远-&gt;离我最近 */</span></span><br><span class="line">    FarToMe = <span class="string">&quot;FarToMe&quot;</span>,</span><br><span class="line">    <span class="comment">/** 血量百分比低-&gt;高 */</span></span><br><span class="line">    HPPer_LowToHigh = <span class="string">&quot;HPPer_LowToHigh&quot;</span>,</span><br><span class="line">    <span class="comment">/** 血量百分比高-&gt;低 */</span></span><br><span class="line">    HPPer_HighToLow = <span class="string">&quot;HPPer_HighToLow&quot;</span>,</span><br><span class="line">    <span class="comment">/** 攻击力百分比低-&gt;高 */</span></span><br><span class="line">    ATK_LowToHigh = <span class="string">&quot;ATK_LowToHigh&quot;</span>,</span><br><span class="line">    <span class="comment">/** 攻击力百分比高-&gt;低 */</span></span><br><span class="line">    ATK_HighToLow = <span class="string">&quot;ATK_HighToLow&quot;</span>,</span><br><span class="line">    <span class="comment">/** 防御百分比低-&gt;高 */</span></span><br><span class="line">    DEF_LowToHigh = <span class="string">&quot;DEF_LowToHigh&quot;</span>,</span><br><span class="line">    <span class="comment">/** 防御百分比高-&gt;低 */</span></span><br><span class="line">    DEF_HighToLow = <span class="string">&quot;DEF_HighToLow&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBattleTargetCfg &#123;</span><br><span class="line">    <span class="comment">/** 目标站边类型 */</span></span><br><span class="line">    <span class="keyword">readonly</span> TargetSideType: ETargetSideType;</span><br><span class="line">    <span class="comment">/** 是否包含我自己 */</span></span><br><span class="line">    <span class="keyword">readonly</span> IncludeSelf: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 按规则排序 */</span></span><br><span class="line">    <span class="keyword">readonly</span> CondsSortType: ECondsSortType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="战斗Action释放者"><a href="#战斗Action释放者" class="headerlink" title="战斗Action释放者"></a>战斗Action释放者</h2><p>  由于战斗中的Action释放者可能由很多种（目前来说是角色和宝物），所以需要抽象一层接口<br>  <code>IBattleActionOwner</code>，（这也是为什么宝物设计和角色设计高度相似的原因之一）。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBattleActionOwner <span class="keyword">extends</span> IActionOwner &#123;</span><br><span class="line">    <span class="comment">/** 站边类型 */</span></span><br><span class="line">    <span class="attr">sideType</span>: BattleSideType;</span><br><span class="line">    battleComp: &#123;</span><br><span class="line">        <span class="comment">/** 所有目标单位 */</span></span><br><span class="line">        <span class="attr">allList</span>: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">        <span class="comment">/** 判断是否可以选中目标 */</span></span><br><span class="line">        judgeCanSelectTarget(target: BattleCharacter): <span class="built_in">boolean</span>;</span><br><span class="line">        <span class="comment">/** 根据一定规则选择一群目标 */</span></span><br><span class="line">        filterTargetsByNums(toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, nums: <span class="built_in">number</span>, <span class="attr">battleTargetCfg</span>: IBattleTargetCfg): <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">        <span class="comment">/** 根据一定规则选择一个目标 */</span></span><br><span class="line">        filterTargetByNum(toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, orderNum: <span class="built_in">number</span>, <span class="attr">battleTargetCfg</span>: IBattleTargetCfg): BattleCharacter;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** 属性 */</span></span><br><span class="line">    attrComp: &#123;</span><br><span class="line">        <span class="attr">attr</span>: BaseAttr;</span><br><span class="line">        baseAttr: BaseAttr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 战斗角色实现 IBattleActionOwner 接口 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleCharacter</span> <span class="keyword">extends</span> <span class="title">BaseCharacter</span> <span class="title">implements</span> <span class="title">IBattleActionOwner</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/** 战斗宝物实现 IBattleActionOwner 接口 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BattleTreasure</span> <span class="title">implements</span> <span class="title">IBattleActionOwner</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="战斗Action配置"><a href="#战斗Action配置" class="headerlink" title="战斗Action配置"></a>战斗Action配置</h2><p>  战斗Action的配置可以分为三个模块，发射器配置模块，实体配置模块，受击反馈配置模块<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBattleActionCfg <span class="keyword">extends</span> IActionCfg &#123;</span><br><span class="line">  <span class="comment">/** 发射器类型 */</span></span><br><span class="line">  <span class="keyword">readonly</span> EmitType: EEmitType;</span><br><span class="line">  <span class="comment">/** 发射器配置 */</span></span><br><span class="line">  <span class="keyword">readonly</span> EmitProperty: IEmitCfg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 发射的实体类型 */</span></span><br><span class="line">  <span class="keyword">readonly</span> EntityType: EEntityType;</span><br><span class="line">  <span class="comment">/** 发射的实体配置 */</span></span><br><span class="line">  <span class="keyword">readonly</span> EntityProperty: IEntityCfg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 受击反馈配置 */</span></span><br><span class="line">  <span class="keyword">readonly</span> HitFeedbackProperty: IHitFeedbackCfg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="战斗Action实现"><a href="#战斗Action实现" class="headerlink" title="战斗Action实现"></a>战斗Action实现</h2><p>  根据之前的剖析，可以将战斗Action轮廓给勾勒出来，具体的<code>Emit</code>，<code>Entity</code>，<code>HitFeedback</code>留在后文阐述。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBattleAction</span>&lt;<span class="title">TOwner</span> <span class="keyword">extends</span> <span class="title">IBattleActionOwner</span> </span>= IBattleActionOwner, TCfg <span class="keyword">extends</span> IBattleActionCfg = IBattleActionCfg&gt; <span class="keyword">extends</span> BaseAction&lt;TOwner, TCfg&gt; &#123;</span><br><span class="line">    <span class="comment">/** 发射器 */</span></span><br><span class="line">    <span class="keyword">private</span> _emit: BaseEmit;</span><br><span class="line">    <span class="comment">/** 攻击体 */</span></span><br><span class="line">    <span class="keyword">private</span> _entityList: <span class="built_in">Array</span>&lt;BaseEntity&gt;;</span><br><span class="line">    <span class="comment">/** 目标列表 */</span></span><br><span class="line">    <span class="keyword">private</span> _targetList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">    <span class="comment">/** 受击反馈 */</span></span><br><span class="line">    <span class="keyword">protected</span> hitFeedback: HitFeedback;</span><br><span class="line">    <span class="comment">/** 延迟时间 */</span></span><br><span class="line">    <span class="keyword">protected</span> delayTime: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(args?: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._entityList = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BaseEntity&gt;();</span><br><span class="line">        <span class="built_in">this</span>._targetList = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BattleCharacter&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化的时候根据EmitType类型创建发射器的类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._emit &amp;&amp; <span class="built_in">this</span>._emit.init();</span><br><span class="line">        <span class="built_in">this</span>.hitFeedback = <span class="keyword">new</span> HitFeedback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.onBattleInit(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.delayTime &gt; dt) &#123;</span><br><span class="line">            <span class="built_in">this</span>.delayTime -= dt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._updateEmit(dt);</span><br><span class="line">            <span class="built_in">this</span>._updateEntity(dt);</span><br><span class="line">            <span class="built_in">this</span>.updateHit();</span><br><span class="line">            <span class="built_in">this</span>.checkDead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> createActionEntity(startPosition: Vector3, <span class="attr">startDirection</span>: Vector3): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> entity: BaseEntity = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据实体类型创建实体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entity) &#123;</span><br><span class="line">            <span class="comment">// 实体初始化位置方向信息</span></span><br><span class="line">            entity.init(startPosition, startDirection);</span><br><span class="line">            <span class="built_in">this</span>._entityList.push(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发射器驱动，以创建新的实体 */</span></span><br><span class="line">    <span class="keyword">private</span> _updateEmit(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._emit.update(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实体驱动，以收集受到实体影响的目标单位 */</span></span><br><span class="line">    <span class="keyword">private</span> _updateEntity(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._entityList.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">this</span>._entityList[i].update(dt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对受到实体影响的目标单位 加以受击反馈 */</span></span><br><span class="line">    <span class="keyword">protected</span> updateHit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._targetList.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onHit(<span class="built_in">this</span>._targetList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._targetList.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onHit(target: BattleCharacter): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hitFeedback.hitApply(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 检查Action结束，发射器发射完所有实体，所有实体搜集完目标 则结束 */</span></span><br><span class="line">    <span class="keyword">protected</span> checkDead(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dead: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._entityList.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>._entityList[i].isEntityDead) &#123;</span><br><span class="line">                dead = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dead &amp;&amp; <span class="built_in">this</span>._emit.isEmitDead)</span><br><span class="line">            <span class="built_in">this</span>.setActionEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDispose(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._emit) &#123;</span><br><span class="line">            <span class="built_in">this</span>._emit.dispose();</span><br><span class="line">            <span class="built_in">this</span>._emit = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._entityList.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">this</span>._entityList[i].dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._entityList.length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>._targetList.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">onBattleInit</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">targetList</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>._targetList; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="战斗Action应用"><a href="#战斗Action应用" class="headerlink" title="战斗Action应用"></a>战斗Action应用</h1><h2 id="角色Action"><a href="#角色Action" class="headerlink" title="角色Action"></a>角色Action</h2><p>  角色的Action主要考虑当角色技能被打断（眩晕，冰冻等）时，就终止整个技能中Action<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 角色战斗action */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICharBattleActionCfg <span class="keyword">extends</span> IBattleActionCfg, ICharActionCfg &#123;</span><br><span class="line">    <span class="comment">/** 是否在Action切换后消失 */</span></span><br><span class="line">    <span class="keyword">readonly</span> DeadActionChanged: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="comment">/** 事件的触发时间 */</span></span><br><span class="line">    <span class="keyword">readonly</span> TriggerTime: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 延迟时间发射 */</span></span><br><span class="line">    <span class="keyword">readonly</span> Delay: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharBattleAction</span> <span class="keyword">extends</span> <span class="title">BaseBattleAction</span>&lt;<span class="title">BattleCharacter</span>, <span class="title">ICharBattleActionCfg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _aiState: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> override onBattleInit(aiState: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._aiState = aiState;</span><br><span class="line">        <span class="built_in">this</span>.delayTime = <span class="built_in">this</span>.actionCfg.Delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override checkDead(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">/** 如果动作过程中被打断，则攻击也会被判定失效 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.actionCfg.DeadActionChanged &amp;&amp; <span class="built_in">this</span>.actionOwner.aiComp.curAIState.aiStateConfig.AIState !== <span class="built_in">this</span>._aiState) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setActionEnd();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.checkDead();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="宝物Action"><a href="#宝物Action" class="headerlink" title="宝物Action"></a>宝物Action</h2><p>  宝物的Action主要是对于被动属性宝物需要记录一下搜集的目标列表，用于角色死亡时需要重新选择目标单位，并将之前的目标单位的属性Buff移除。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ITreasureActionCfg <span class="keyword">extends</span> IBattleActionCfg &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureAction</span> <span class="keyword">extends</span> <span class="title">BaseBattleAction</span>&lt;<span class="title">BattleTreasure</span>, <span class="title">ITreasureActionCfg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">updateHit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.actionOwner.isActive) &#123;</span><br><span class="line">            <span class="keyword">let</span> skillComp = <span class="built_in">this</span>.actionOwner.skillComp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.targetList.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skillComp.skillTargetList.indexOf(<span class="built_in">this</span>.targetList[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    skillComp.skillTargetList.push(<span class="built_in">this</span>.targetList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.updateHit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十六) 技能基础和管理</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AD)-%E6%8A%80%E8%83%BD%E5%9F%BA%E7%A1%80%E5%92%8C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  前面的章节中讲述了角色和宝物的技能释放时机，接下来的几个章节会详细讲述技能的具体实现。</p>
<h1 id="Action和ActionEvent"><a href="#Action和ActionEvent" class="headerlink" title="Action和ActionEvent"></a>Action和ActionEvent</h1><p>  从前面角色AI相关的介绍中，我们可以看出来角色的技能是由若干<code>Action</code>（有生命周期行为，如发射一颗子弹，子弹是具有生命周期的）和若干<code>ActionEvent</code>（无生命周期行为，如播放一个动作，是没有生命周期的），这里先有个概念，后面会详细说明，例如一个简单的技能配置可能为：<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ActionEventList&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;TriggerTime&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;EventType&quot;</span>   : <span class="string">&quot;PlayAnim&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;EventData&quot;</span>   : &#123;</span><br><span class="line">          <span class="attr">&quot;AnimName&quot;</span> : <span class="string">&quot;BattleSkill&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;TriggerTime&quot;</span> : <span class="number">40</span>,</span><br><span class="line">      <span class="attr">&quot;EventType&quot;</span>   : <span class="string">&quot;PlayEffect&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;EventData&quot;</span>   : &#123;</span><br><span class="line">          <span class="attr">&quot;EffectName&quot;</span> : <span class="string">&quot;XXX&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;ActionList&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="attr">&quot;TriggerTime&quot;</span>    : <span class="number">40</span>,</span><br><span class="line">       <span class="attr">&quot;TargetSideType&quot;</span> : <span class="string">&quot;OtherSide&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;CondsSortType&quot;</span>  : <span class="string">&quot;NearToMe&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;Nums&quot;</span>           : <span class="number">1</span>,</span><br><span class="line">       <span class="attr">&quot;HitDamage&quot;</span>      : <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  如图上的配置表示一个技能<br>  在0ms时候播放一个”BattleSkill”的动作，<br>  在40ms时候播放一个”XXX”的特效，<br>  在40ms时候朝着敌方(OtherSide)离我最近(NearToMe)的一个(1)单位发射一颗子弹打出10点(10)伤害。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>  有了对<code>Action</code>和<code>ActionEvent</code>大概印象，现在分析项目中的需求，如图所示：<br>  <img src="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AD)-%E6%8A%80%E8%83%BD%E5%9F%BA%E7%A1%80%E5%92%8C%E7%AE%A1%E7%90%86/img1.png" alt="在这里插入图片描述"><br>  需要一个基类BaseAction和BaseActionEvent，并且需要有一个<code>Action</code>和<code>ActionEvent</code>工厂，并对他们的生命周期进行管理。</p>
<h1 id="ActionEvent实现"><a href="#ActionEvent实现" class="headerlink" title="ActionEvent实现"></a>ActionEvent实现</h1><p>  需要含有事件的拥有者和事件的配置：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 事件拥有者 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IActionEventOwner &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 事件配置 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IActionEventCfg &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActionEvent</span>&lt;<span class="title">TOwner</span> <span class="keyword">extends</span> <span class="title">IActionEventOwner</span> </span>= IActionEventOwner, TCfg <span class="keyword">extends</span> IActionEventCfg = IActionEventCfg&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> actionSP: ActionSP;</span><br><span class="line">    <span class="keyword">protected</span> owner: TOwner;</span><br><span class="line">    <span class="keyword">protected</span> cfg: TCfg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">actionSP: ActionSP, owner: IActionEventOwner, cfg: IActionEventCfg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actionSP = actionSP;</span><br><span class="line">        <span class="built_in">this</span>.owner = owner <span class="keyword">as</span> TOwner;</span><br><span class="line">        <span class="built_in">this</span>.cfg = cfg <span class="keyword">as</span> TCfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 事件执行 */</span></span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onExecute(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Action实现"><a href="#Action实现" class="headerlink" title="Action实现"></a>Action实现</h1><p>  同样Action也需要拥有者和配置信息：<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Action基础配置 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IActionCfg &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Action拥有者 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IActionOwner &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span>&lt;<span class="title">TOwner</span> <span class="keyword">extends</span> <span class="title">IActionOwner</span> </span>= IActionOwner, TCfg <span class="keyword">extends</span> IActionCfg = IActionCfg&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> b_actionSP: ActionSP;</span><br><span class="line">    <span class="comment">/** action拥有者 */</span></span><br><span class="line">    <span class="keyword">private</span> b_actionOwner: TOwner;</span><br><span class="line">    <span class="comment">/** action配置 */</span></span><br><span class="line">    <span class="keyword">private</span> b_actionCfg: TCfg;</span><br><span class="line">    <span class="comment">/** action结束 */</span></span><br><span class="line">    <span class="keyword">private</span> b_isActionDead: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">actionSP: ActionSP, owner: IActionOwner, actionCfg: IActionCfg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_actionSP = actionSP;</span><br><span class="line">        <span class="built_in">this</span>.b_actionOwner = owner <span class="keyword">as</span> TOwner;</span><br><span class="line">        <span class="built_in">this</span>.b_actionCfg = actionCfg <span class="keyword">as</span> TCfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> init(args?: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_isActionDead = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.onInit.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> dispose(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_actionCfg = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.b_actionOwner = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onDispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> setActionEnd(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b_isActionDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> onInit(...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">protected</span> onDispose(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">isActionDead</span>(): <span class="title">boolean</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_isActionDead; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">actionSP</span>(): <span class="title">ActionSP</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_actionSP; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">actionOwner</span>(): <span class="title">TOwner</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_actionOwner; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">actionCfg</span>(): <span class="title">TCfg</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b_actionCfg; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Action和ActionEvent管理"><a href="#Action和ActionEvent管理" class="headerlink" title="Action和ActionEvent管理"></a>Action和ActionEvent管理</h1><p>  同角色宝物一样，需要提供一个工厂和生命周期管理的类<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EActionType &#123;</span><br><span class="line">    Invalid = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/** 角色 **/</span></span><br><span class="line">    BattleCharacter = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** 宝物 **/</span></span><br><span class="line">    BattleTreasure = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EActionEventType &#123;</span><br><span class="line">    Character = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSP</span> <span class="keyword">extends</span> <span class="title">SceneProcessorBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _actionList: <span class="built_in">Array</span>&lt;BaseAction&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionList = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;BaseAction&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 更新所有Action 并移除已经死亡的Action</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onDestroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">       <span class="comment">// 销毁所有Action</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> createAction(actionType: EActionType, <span class="attr">actionOwner</span>: IActionOwner, <span class="attr">actionCfg</span>: IActionCfg, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> action: BaseAction;</span><br><span class="line">        <span class="keyword">switch</span> (actionType) &#123;</span><br><span class="line">            <span class="keyword">case</span> EActionType.BattleCharacter:</span><br><span class="line">                action = <span class="keyword">new</span> CharBattleAction(<span class="built_in">this</span>, actionOwner, actionCfg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EActionType.BattleTreasure:</span><br><span class="line">                action = <span class="keyword">new</span> TreasureAction(<span class="built_in">this</span>, actionOwner, actionCfg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他类型Action</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (action) &#123;</span><br><span class="line">            action.init(args);</span><br><span class="line">            <span class="built_in">this</span>._actionList.push(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 事件是一种一触即发的action */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">createActionEvent</span>(<span class="params">actionEventType: EActionEventType, eventOwner: IActionEventOwner, eventCfg: IActionEventCfg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (actionEventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> EActionEventType.Character:</span><br><span class="line">                <span class="keyword">switch</span> ((eventCfg <span class="keyword">as</span> ICharActionEventCfg).EventType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ECharActionEventType.PlayAnim:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> EventPlayAnim(<span class="built_in">this</span>, eventOwner, eventCfg);</span><br><span class="line">                    <span class="keyword">case</span> ECharActionEventType.PlayEffect:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> EventPlayEffect(<span class="built_in">this</span>, eventOwner, eventCfg);</span><br><span class="line">                    <span class="comment">// 其他角色ActionEvent</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他类型ActionEvent</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(十四) 宝物设计-战斗宿主</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%9B%9B)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%AE%BF%E4%B8%BB/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  前文也说过宝物在战斗中需要依赖宿主，虽然大多数信息是可以直接从宿主身上获取，但是类似锁敌机制是需要有宝物独立的一套机制，例如：宝物是不会被嘲讽的，宝物也不会选取自己为目标等等。</p>
<h1 id="绑定宿主"><a href="#绑定宿主" class="headerlink" title="绑定宿主"></a>绑定宿主</h1><p>  宝物的战斗组件主要实现的机制为根据给定的宿主列表寻找最前方的宿主，并提供锁敌机制。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureBattleCompontent</span> <span class="keyword">extends</span> <span class="title">TreasureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _hostList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;;</span><br><span class="line">    <span class="keyword">private</span> _host: BattleCharacter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override <span class="function"><span class="title">onInit</span>(<span class="params">hostList: <span class="built_in">Array</span>&lt;BattleCharacter&gt;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._hostList = hostList;</span><br><span class="line">        <span class="built_in">this</span>._host = <span class="built_in">this</span>._getFrontHost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> override onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._host = <span class="built_in">this</span>._getFrontHost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> judgeCanSelectTarget(target: BattleCharacter): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host.battleComp.judgeCanSelectTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 绑定最前排的宿主 */</span></span><br><span class="line">    <span class="keyword">private</span> _getFrontHost(): BattleCharacter &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根据条件筛选出一群单位 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">filterTargetsByNums</span>(<span class="params">toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, nums: <span class="built_in">number</span>, battleTargetCfg: IBattleTargetCfg</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根据条件筛选出一个单位 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">filterTargetByNum</span>(<span class="params">toFilters: <span class="built_in">Array</span>&lt;BattleCharacter&gt;, orderNum: <span class="built_in">number</span>, battleTargetCfg: IBattleTargetCfg</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 宿主 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">host</span>(): <span class="title">BattleCharacter</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._host; &#125;</span><br><span class="line">    <span class="comment">/** 宿主列表 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">hostList</span>(): <span class="title">Array</span>&lt;<span class="title">BattleCharacter</span>&gt; &#123; <span class="keyword">return</span> <span class="built_in">this</span>._hostList; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h1><p>  宝物的基础属性是由所有宿主的基础属性相加所得，并且需要根据角色死亡增加实时更新。<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureAttrCompontent</span> <span class="keyword">extends</span> <span class="title">TreasureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 总属性 */</span></span><br><span class="line">  <span class="keyword">private</span> _attr: ssBaseAttr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> override onInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._attr = <span class="keyword">new</span> ssBaseAttr();</span><br><span class="line">      <span class="built_in">this</span>.syncAttr();</span><br><span class="line">      <span class="comment">// 监听角色死亡事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 目前只有攻击，攻击为宿主的攻击总和 */</span></span><br><span class="line">  <span class="keyword">public</span> syncAttr(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._attr.clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> host <span class="keyword">of</span> <span class="built_in">this</span>.treasure.battleComp.hostList) &#123;</span><br><span class="line">          <span class="keyword">if</span> (host.battleHPComp.isDying)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          <span class="built_in">this</span>._attr.addValue(AttrID.Attack, host.attrComp.baseAttr.attack);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 有角色改变时需要同步属性 */</span></span><br><span class="line">  <span class="keyword">private</span> _onHandelCharacterChange(character: BattleCharacter): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (character.sideType !== <span class="built_in">this</span>.treasure.sideType) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.syncAttr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">attr</span>(): <span class="title">BaseAttr</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._attr; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">baseAttr</span>(): <span class="title">BaseAttr</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._attr; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗 个人总结</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作为游戏玩家，接触放置类卡牌也很多年了，从最早的刀塔传奇，到后来的公主连结，剑与远征，市面上很多游戏都有这种战斗类型的影子，作为游戏开发者，这两年也一直从事放置类卡牌战斗相关的开发，踩了很多坑，也收获了很多，特此记录一下。</p>
<h1 id="设计思考"><a href="#设计思考" class="headerlink" title="设计思考"></a>设计思考</h1><p>  战斗模块一般是这种卡牌类游戏中相对来说比较核心的模块，游戏中很多玩法都会跟战斗相关，角色卡牌的收集养成也会在战斗中得到验证。对于整个战斗模块来说，早期框架的设计是比较重要的，一方面，由于战斗中各种复杂逻辑的存在，如果设计不合理，逻辑处理的非常混乱，会存在很多逻辑漏洞，一方面，由于随着版本开发，游戏中会不断加入新的战斗机制，同时也会不断的增加新的角色和新的技能机制，如果设计非常杂乱，代码没有进行有效管理，会非常影响后续各种拓展。</p>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>  框架设计中需要遵循的理念为框架本身是服务于项目的，很多设计也是需要基于游戏玩法决定，在框架设计之初，需要和游戏策划团队商量好游戏未来的大方向，以及可能会出现的一些机制，明确了项目的大方向，再着手考虑框架设计，不然就会产生很多冗余设计，也会有很多未曾想到的方面。</p>
<h1 id="设计要点细分"><a href="#设计要点细分" class="headerlink" title="设计要点细分"></a>设计要点细分</h1><p>  整体战斗模块涉及的内容比较多，有些模块因为业务的需求细节部分也比较多，整理了一下大概有以下要点：<br>  （所有代码部分只列出了一部分作为参考，有需要可以根据项目内容补充）</p>
<ul>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%80)-%E5%8A%9F%E8%83%BD%E5%88%86%E5%B7%A5/" title="放置类卡牌战斗(一) 功能分工">放置类卡牌战斗(一) 功能分工</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C)-%E6%88%98%E6%96%97%E7%AE%A1%E7%90%86/" title="放置类卡牌战斗(二) 战斗管理">放置类卡牌战斗(二) 战斗管理</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%89)-%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86/" title="放置类卡牌战斗(三) 角色管理">放置类卡牌战斗(三) 角色管理</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%9B%9B)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%95%B4%E4%BD%93/" title="放置类卡牌战斗(四) 角色设计-整体">放置类卡牌战斗(四) 角色设计-整体</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%94)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E5%B1%9E%E6%80%A7/" title="放置类卡牌战斗(五) 角色设计-属性">放置类卡牌战斗(五) 角色设计-属性</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AD)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%9E%8B/" title="放置类卡牌战斗(六) 角色设计-模型">放置类卡牌战斗(六) 角色设计-模型</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B8%83)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-AI/" title="放置类卡牌战斗(七) 角色设计-AI">放置类卡牌战斗(七) 角色设计-AI</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%85%AB)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%9F%BA%E7%A1%80/" title="放置类卡牌战斗(八) 角色设计-战斗基础">放置类卡牌战斗(八) 角色设计-战斗基础</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%B9%9D)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/" title="放置类卡牌战斗(九) 角色设计-战斗技能">放置类卡牌战斗(九) 角色设计-战斗技能</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97Buff/" title="放置类卡牌战斗(十) 角色设计-战斗Buff">放置类卡牌战斗(十) 角色设计-战斗Buff</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%80)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E8%A1%80%E9%87%8F/" title="放置类卡牌战斗(十一) 角色设计-战斗血量">放置类卡牌战斗(十一) 角色设计-战斗血量</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%8C)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E7%A7%BB%E5%8A%A8/" title="放置类卡牌战斗(十二) 角色设计-战斗移动">放置类卡牌战斗(十二) 角色设计-战斗移动</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%89)-%E5%AE%9D%E7%89%A9%E7%AE%A1%E7%90%86/" title="放置类卡牌战斗(十三) 宝物管理">放置类卡牌战斗(十三) 宝物管理</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%9B%9B)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E5%AE%BF%E4%B8%BB/" title="放置类卡牌战斗(十四) 宝物设计-战斗宿主">放置类卡牌战斗(十四) 宝物设计-战斗宿主</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%BA%94)-%E5%AE%9D%E7%89%A9%E8%AE%BE%E8%AE%A1-%E6%88%98%E6%96%97%E6%8A%80%E8%83%BD/" title="放置类卡牌战斗(十五) 宝物设计-战斗技能">放置类卡牌战斗(十五) 宝物设计-战斗技能</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AD)-%E6%8A%80%E8%83%BD%E5%9F%BA%E7%A1%80%E5%92%8C%E7%AE%A1%E7%90%86/" title="放置类卡牌战斗(十六) 技能基础和管理">放置类卡牌战斗(十六) 技能基础和管理</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B8%83)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-ActionEvent/" title="放置类卡牌战斗(十七) 技能设计-ActionEvent">放置类卡牌战斗(十七) 技能设计-ActionEvent</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E5%85%AB)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%95%B4%E4%BD%93/" title="放置类卡牌战斗(十八) 技能设计-Action整体">放置类卡牌战斗(十八) 技能设计-Action整体</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%8D%81%E4%B9%9D)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%91%E5%B0%84%E5%99%A8/" title="放置类卡牌战斗(十九) 技能设计-Action发射器">放置类卡牌战斗(十九) 技能设计-Action发射器</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E6%94%BB%E5%87%BB%E5%AE%9E%E4%BD%93/" title="放置类卡牌战斗(二十) 技能设计-Action攻击实体">放置类卡牌战斗(二十) 技能设计-Action攻击实体</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%80)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-Action%E5%8F%97%E5%87%BB%E5%8F%8D%E9%A6%88/" title="放置类卡牌战斗(二十一) 技能设计-Action受击反馈">放置类卡牌战斗(二十一) 技能设计-Action受击反馈</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%BA%8C)-%E6%8A%80%E8%83%BD%E8%AE%BE%E8%AE%A1-%E6%80%BB%E7%BB%93/" title="放置类卡牌战斗(二十二) 技能设计-总结">放置类卡牌战斗(二十二) 技能设计-总结</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E4%B8%89)-%E7%9B%B8%E6%9C%BA%E7%AE%A1%E7%90%86/" title="放置类卡牌战斗(二十三) 相机管理">放置类卡牌战斗(二十三) 相机管理</a></li>
<li><a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E4%BA%8C%E5%8D%81%E5%9B%9B)-%E5%AE%8C%E7%BB%93/" title="放置类卡牌战斗(二十四) 完结">放置类卡牌战斗(二十四) 完结</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>放置类卡牌战斗(四) 角色设计-整体</title>
    <url>/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-(%E5%9B%9B)-%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1-%E6%95%B4%E4%BD%93/</url>
    <content><![CDATA[<hr>
  <a href="/%E6%94%BE%E7%BD%AE%E7%B1%BB%E5%8D%A1%E7%89%8C%E6%88%98%E6%96%97-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="点我回到首页">点我回到首页</a>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这种放置类卡牌战斗中的角色模块，基本可以算是战斗中核心了，战斗中角色会有各种模块，包括角色模型（fbx，spine等）控制，角色属性，角色AI，角色技能，角色Buff等等，如果不进行有效管理，最后角色类会非常膨胀。</p>
<h1 id="组件机制"><a href="#组件机制" class="headerlink" title="组件机制"></a>组件机制</h1><p>  根据项目的背景，由于角色在其他场景也有交互AI行为等等，为了达到代码的内聚和复用，采用了组件(Component)的思想对角色各个模块进行封装，后面章节中将逐个对各个模块进行详解，如下设计通用的组件基类<code>CharacterComponent</code><br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterComponent</span>&lt;<span class="title">TCharacter</span> <span class="keyword">extends</span> <span class="title">BaseCharacter</span> </span>= BaseCharacter&gt; <span class="keyword">extends</span> EventDispatcher &#123;</span><br><span class="line">  <span class="keyword">private</span> _character: BaseCharacter;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">get</span> <span class="title">character</span>(): <span class="title">TCharacter</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._character <span class="keyword">as</span> TCharacter; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">character: BaseCharacter</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>._character = character;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> init(args?: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onInit.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> afterInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onAfterInit.apply(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> update(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onUpdate(dt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> destroy(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> onInit(...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">  <span class="keyword">protected</span> onAfterInit(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">  <span class="keyword">protected</span> onUpdate(dt: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">  <span class="keyword">protected</span> onDestroy(): <span class="built_in">void</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="角色绑定组件"><a href="#角色绑定组件" class="headerlink" title="角色绑定组件"></a>角色绑定组件</h1><p>  在角色基类中管理所有添加的组件<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 所有组件 */</span></span><br><span class="line"><span class="keyword">private</span> _components: <span class="built_in">Array</span>&lt;CharacterComponent&gt;;</span><br><span class="line"><span class="comment">/** 组件初始化参数 */</span></span><br><span class="line"><span class="keyword">private</span> _compInitArgs: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> getComponent&lt;T <span class="keyword">extends</span> CharacterComponent&gt;(<span class="keyword">type</span>: <span class="keyword">new</span> (arg0: BaseCharacter) =&gt; T): T &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> comp <span class="keyword">of</span> <span class="built_in">this</span>._components) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comp <span class="keyword">instanceof</span> <span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> addComponent&lt;T <span class="keyword">extends</span> CharacterComponent&gt;(<span class="keyword">type</span>: <span class="keyword">new</span> (arg0: BaseCharacter) =&gt; T, ...args: <span class="built_in">any</span>[]): T &#123;</span><br><span class="line">    <span class="keyword">let</span> component = <span class="keyword">new</span> <span class="keyword">type</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>._components.push(component);</span><br><span class="line">    <span class="built_in">this</span>._compInitArgs.push(args);</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> removeComponent&lt;T <span class="keyword">extends</span> CharacterComponent&gt;(<span class="keyword">type</span>: <span class="keyword">new</span> (arg0: BaseCharacter) =&gt; T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._components.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._components[i] <span class="keyword">instanceof</span> <span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._components[i].destroy();</span><br><span class="line">            <span class="built_in">this</span>._components.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>._compInitArgs.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样在创建角色时，根据所需创建的角色类型，加入需要的组件（绝大多数组件都是必要的），即可以定制不同的角色，如一个基础角色依赖组件<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 角色属性管理 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> attrComp: CharAttrComponent;</span><br><span class="line"><span class="comment">/** 角色模型管理 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> animComp: CharAnimComponent;</span><br><span class="line"><span class="comment">/** 角色AI管理 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> aiComp: CharAIComponent;</span><br></pre></td></tr></table></figure><br>  如一个战斗角色继承基础角色依赖组件<br>  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 战斗中角色模型管理 继承CharAnimComponent */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">public</span> <span class="keyword">readonly</span> animComp: CharBattleAnimComponent;</span><br><span class="line"><span class="comment">/** 管理角色战斗中的一些战斗信息 主要为 战斗中计算 战斗中各种锁敌 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleComp: CharBattleComponent;</span><br><span class="line"><span class="comment">/** 管理角色战斗中移动 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleMoveComp: CharBattleMoveComponent;</span><br><span class="line"><span class="comment">/** 管理角色战斗中技能 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleSkillComp: CharBattleSkillComponent;</span><br><span class="line"><span class="comment">/** 管理角色战斗中血量 护盾 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleHPComp: CharBattleHPComponent;</span><br><span class="line"><span class="comment">/** 管理角色战斗中Buff */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> battleBuffComp: CharBattleBuffComponent;</span><br></pre></td></tr></table></figure><br>  角色组件的划分准则不是绝对的，应该根据项目实时调整，比如最初是没有battleMoveComp组件的，当项目不断迭代以后，角色移动相关比较复杂，就单独划分成了battleMoveComp组件，比如现在战斗锁敌是放在了battleComp，未来项目锁敌复杂以后，也会单独做成battleSearchTargetComp。</p>
<h1 id="组件设计理念"><a href="#组件设计理念" class="headerlink" title="组件设计理念"></a>组件设计理念</h1><p>  <code>下层组件</code>是不应该调用<code>上层组件</code>的，<code>上层组件</code>可以直接调用<code>下层组件</code>，<code>下层组件</code>可以通过事件派发的方式，通过让<code>上层组件</code>监听事件达到调用<code>上层组件</code>的目的，设计的时候应该尽量将<code>无状态（不需要依赖其他组件）组件</code>设计成<code>下层组件</code><br>  这里笔者的设计为</p>
<ul>
<li>第一层：<code>attrComp</code> <code>animComp</code> <code>aiComp</code></li>
<li>第二层：<code>battleComp</code></li>
<li>第三层：<code>battleMoveComp</code> <code>battleSkillComp</code> <code>battleHPComp</code> <code>battleBuffComp</code></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>战斗</category>
        <category>放置类卡牌战斗</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Puerts接入Unity (三) 搭建调试环境(VSCode)</title>
    <url>/Puerts%E6%8E%A5%E5%85%A5Unity-(%E4%B8%89)-%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83(VSCode)/</url>
    <content><![CDATA[<h1 id="创建launch-json"><a href="#创建launch-json" class="headerlink" title="创建launch.json"></a>创建launch.json</h1><p>  在项目根目录下创建<code>.vscode/launch.json</code>写入如下内容<br>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Puerts Debug&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;inspector&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;port&quot;</span>: <span class="number">18080</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这里要关注<code>port</code>监听的端口号</p>
<h1 id="Puerts调试类型"><a href="#Puerts调试类型" class="headerlink" title="Puerts调试类型"></a>Puerts调试类型</h1><p>  Puerts调试一共分三种类型：</p>
<ul>
<li>AnyTime(任意时候): 项目开始后任意时候都可以启动监听调试</li>
<li>Sync(同步阻塞): 只有先启动调试器才会执行<code>Ts(Js)</code>代码和<code>C#</code>代码</li>
<li>Async(异步): 只有先启动调试器才会执行<code>Ts(Js)</code>代码，但是不会影响<code>C#</code>代码</li>
</ul>
<p>  注意<code>Sync</code>和<code>Async</code>的区别在于是否会影响<code>C#</code>代码，<code>Async</code>的意义在于调试器刚起来几秒内是没有办法打断点的，只有借助<code>Async</code>才能帮助调试项目最开始的启动代码，可以参考官方文档<a href="https://github.com/Tencent/puerts/blob/master/doc/unity/vscode_debug.md">vscode debug指引</a></p>
<h1 id="调整入口代码"><a href="#调整入口代码" class="headerlink" title="调整入口代码"></a>调整入口代码</h1><p>  根据三种类型，为了项目中方便使用，我们可以调整代码<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EJavaScriptDebugStyle</span><br><span class="line">&#123;</span><br><span class="line">    AnyTime,    <span class="comment">//任何时候</span></span><br><span class="line">    Sync,       <span class="comment">//同步</span></span><br><span class="line">    Async,      <span class="comment">//异步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JavaScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JsEnv mJsEnv;</span><br><span class="line">    <span class="keyword">private</span> JavaScriptLoader mJsLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> JavaScriptDebugPort = <span class="number">18080</span>;</span><br><span class="line">    <span class="keyword">public</span> EJavaScriptDebugStyle JavaScriptDebugStyle = EJavaScriptDebugStyle.AnyTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.runInBackground = <span class="literal">true</span>;</span><br><span class="line">        mJsLoader = <span class="keyword">new</span> JavaScriptLoader();</span><br><span class="line">        mJsEnv = <span class="keyword">new</span> JsEnv(mJsLoader, JavaScriptDebugPort);</span><br><span class="line">        gameStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gameStart</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 异步</span></span><br><span class="line">        <span class="keyword">if</span> (JavaScriptDebugStyle == EJavaScriptDebugStyle.Sync)</span><br><span class="line">        &#123;</span><br><span class="line">            mJsEnv.WaitDebugger();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (JavaScriptDebugStyle == EJavaScriptDebugStyle.Async)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> mJsEnv.WaitDebuggerAsync();</span><br><span class="line">        &#125;</span><br><span class="line">        mJsEnv.Eval(<span class="built_in">string</span>.Format(<span class="string">&quot;require(&#x27;&#123;0&#125;&#x27;)&quot;</span>, <span class="string">&quot;test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mJsEnv?.Tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  这样即可以启动Puerts Debug前方的小箭头连接打断点进行调试了</p>
<h1 id="无法调试原因"><a href="#无法调试原因" class="headerlink" title="无法调试原因"></a>无法调试原因</h1><ul>
<li>debugPath配置不正确：Puerts借助VSCode调试的原理为将<code>Js</code>文件完整路径告诉VSCode，由VSCode自行根据对应地址寻找<code>Ts</code>代码，所以之前JsLoader中ReadFile的<code>debugPath</code>地址必须为直接地址，形式必须为<br><code>D:\Aorn\BlogTest-TypeScript\JavaScript\ownts\test.js</code><br>类似<code>D:\Aorn\BlogTest-TypeScript\Assets\..\JavaScript\ownts\test.js</code>带有<code>..</code>字样都是不可以的并且注意Windows下需要修改”/“为”\“</li>
<li>端口号不正确或者被占用：注意JsEnv传入的端口号需要与launch.json中端口号一致，并且需要检查是否存在端口号被占用的情况</li>
<li>未设置Application.runInBackground = true：未设置runInBackground有可能会导致点击VSCode的时候Unity停止运行，进而无法调试</li>
<li>未在Update中调用Tick：需要在Update中调用JsEnv的<code>Tick</code>函数，才能保证连接上</li>
</ul>
<p>  参考链接：<a href="https://www.jianshu.com/p/0980e2c50049">https://www.jianshu.com/p/0980e2c50049</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Puerts</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
