<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lua和PureMVC</title>
    <url>/2021/05/10/Lua%E5%92%8CPureMVC/</url>
    <content><![CDATA[<p>参考 <a href="https://blog.csdn.net/wangjiangrong/article/details/107686954">https://blog.csdn.net/wangjiangrong/article/details/107686954</a><br>        <a href="https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html">https://www.cnblogs.com/skynet/archive/2013/03/14/2958644.html</a><br>        <a href="https://blog.csdn.net/qq_29579137/article/details/73692842">https://blog.csdn.net/qq_29579137/article/details/73692842</a></p>
<p>挪用了其他文章中的一些流程图</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近负责项目UI框架部分的搭建，查阅了一些资料以后，借鉴了其他项目的一些想法，在这边整理一下，项目UI部分是用Lua写的，贴的相关代码也是Lua代码，由于是边学习边写的，命名规则是按项目标准命名的（成员变量前加m等）</p>
<h1 id="MVC和PureMVC"><a href="#MVC和PureMVC" class="headerlink" title="MVC和PureMVC"></a>MVC和PureMVC</h1><p>目标：将数据（Model），视图组件（View）和控制逻辑（Control）进行分离。让程序便于修改，更具有扩展性，灵活性，可重用性。高内聚，低耦合，一直是追求的目标。传统经典的MVC模型虽然将数据，视图组件和控制逻辑进行了分离，但耦合性还是比较高。</p>
<p>PureMVC在MVC基础上做了许多的改进，通过结合多个设计模式的应用，让耦合性变得更低，也变得更加的易用，在扩展性，灵活性，重用性方面也做得更好</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式-（Singleton）"><a href="#单例模式-（Singleton）" class="headerlink" title="单例模式 （Singleton）"></a>单例模式 （Singleton）</h2><p> 在PureMVC中，Model,View,Controller是三个单例模式类，三者合称为核心层，实际上是Manager管理类，分别定义了字典用于保存引用</p>
<h2 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h2><p>  在开发的过程中，需要在Contoller中，获取View以及Model的对象，修改Mode，更新View，或是在View，需要获取Model，进行一些初始化或是修改的操作，在业务逻辑很多的情况下，Model, View, Controller之间的频繁的调用就会非常多，耦合性会变高，在PureMVC中，为Model、View、Controller类提供了外观类Façade，主要负责访问和通知 Model、View 和 Controller，即管理这三者。Façade统一对外提供这3者的接口，使用过程成只需要跟Façade打交道就行</p>
<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>为了彻底解耦，避免直接的函数调用，PureMVC使用观察者模式（又称发布/订阅模式）的形式传递消息。在PureMVC中Mediator、Proxy、Command之间的通信，以通知形式实现松散耦合。Mediator、Proxy、Command都是通知者（发布者） 可以调用sendNotification发送消息；Mediator、Command同时也是观察者（订阅者）可以接收来自其它对象的通知。</p>
<p>这里先不用关心Mediator、Proxy、Command是什么，需要注意的是Mediator和Command既是通知者也是观察者，Proxy只是通知者<br>Proxy=&gt;Model            ，Mediator=&gt;View        ， Command=&gt;Controller</p>
<p>所有的通知者（发布者）都继承自Notifier类，故拥有发布通知的功能，而Notifier是使用Façade发布通知的<br>由外观模式可知façade保存了View的引用，View在观察者模式中充当着管理者的角色，保存着所有消息/主题、观察者的映射。当Mediator/Command/Proxy发布通知时，façade调用View的notifyObservers()方法，遍历保存的映射关系，从而通知所有满足条件的观察者</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Notifier:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="keyword">local</span> facade = <span class="built_in">self</span>:GetFacade()</span><br><span class="line">    <span class="keyword">if</span> facade ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        facade:SendNotification(notificationName, body, <span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:SendNotification</span><span class="params">(notificationName, body, type)</span></span></span><br><span class="line">    <span class="built_in">self</span>:NotifyObservers(Notification.New(notificationName, body, <span class="built_in">type</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Facade:NotifyObservers</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mView ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:NotifyObservers(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Command 中调用 Controller的 RegisterCommand 注册通知<br>通过复写Command的Execute方法实现回调</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:RegisterCommand</span><span class="params">(notificationName, commandClassRef)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mCommandMap[notificationName] == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>.mView:RegisterObserver(notificationName, Observer.New(<span class="built_in">self</span>.ExecuteCommand, <span class="built_in">self</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">self</span>.mCommandMap[notificationName] = commandClassRef</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller:ExecuteCommand</span><span class="params">(note)</span></span></span><br><span class="line">    <span class="keyword">local</span> commandClassRef = <span class="built_in">self</span>.mCommandMap[note:GetName()]</span><br><span class="line">    <span class="keyword">if</span>(commandClassRef == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> commandInstance = commandClassRef.New()</span><br><span class="line">    commandInstance:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    commandInstance:Execute(note)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Mediator 中调用 View 的 RegisterMediator<br>通过复写Mediator的ListNotificationInterests方法实现回调</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View:RegisterMediator</span><span class="params">(mediator)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:InitializeNotifier(<span class="built_in">self</span>.mMultitonKey)</span><br><span class="line">    <span class="built_in">self</span>.mMediatorMap[mediator:GetMediatorName()] = mediator</span><br><span class="line">    <span class="keyword">local</span> interests = mediator:ListNotificationInterests()</span><br><span class="line">    <span class="keyword">if</span> #interests &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> observer = Observer.New(mediator.handleNotification, mediator)</span><br><span class="line">        <span class="keyword">for</span> _, i <span class="keyword">in</span> <span class="built_in">pairs</span>(interests) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">self</span>:RegisterObserver(i, observer)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mediator:OnRegister()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img1.png" alt="在这里插入图片描述"></p>
<h2 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h2><p>在PureMVC中，Mediator帮助我们创建或重用已有UI组件，而UI不用知道PureMVC框架相关的东西，UI仅用于显示数据、接收用户输入。Mediator是UI组件与框架的中介，它负责将来自PureMVC框架的消息转接到UI，并将UI的消息转发广播到PureMVC框架。这样通过Mediator解耦了UI与PureMVC框架元素（Proxy、Mediator、Command），而不用互相引用。</p>
<p>一个Mediator只与一个UI绑定（1对1），Mediator构造函数参数传递与之绑定的UI。通过façade的registerMediator方法注册Mediator，以接收PureMVC框架的通知</p>
<p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img2.png" alt="在这里插入图片描述"></p>
<p>Mediator接收PureMVC传来的Notification，调用UI函数<br>接收UI派发的事件，转发Notification传回PureMVC框架</p>
<p>例如 当点击领取邮件按钮，EmailUI发送消息给EmailMediator传给PureMVC，（中间可能涉及服务器交互），之后PureMVC，需要更新背包内容就发送消息给BagMediator，BagMediator接收事件以后更新BagUI，Bag功能和Email功能并没有影响</p>
<h2 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h2><p>在PureMVC中，Proxy帮助我们以更易于重用、修改对应用程序影响最小的方式暴露数据结构、接口给应用程序。Proxy可能只是简单的管理本地数据对象，以同步方式获取或修改数据；也可能是远程服务器数据，以异步方式操作数据，服务器数据返回之后以Notification方式告诉应用程序。</p>
<p>简单来说，Proxy对数据逻辑进行包装，只对外公布操作数据对象的API，例如EmailProxy负责接收来自服务器的邮件内容，当邮件更新时，EmailUI并不需要关心邮件数据是什么形式发来的，当EmailUI需要展示邮件内容，只需要调取EmailProxy公布的API（例如EmaliProxy.GetEmailList）即可，反之，当发送邮件时，EmailUI也不需要关注怎么发送，以什么样数据格式发给服务器，一切逻辑都由EmailProxy处理，这样极大程度实现了对一些处理逻辑的封装，降低了耦合。</p>
<h2 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h2><p>命令模式是对命令的封装，把发出命令的责任和执行命令的责任分割开，委派给不同的对象。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>
<p>在PureMVC中，命令用来检索、操作Proxy，或者与Mediator通信，或者执行其它命令。<br><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img3.png" alt="在这里插入图片描述"></p>
<p>例如:EmailMediator 接收到来自UI的sendEmail的消息，EmailMediator把消息传到SendEmailCommand， SendEmailCommand持有EmailProxy的引用，调用EmailProxy的SendEmail接口发送消息</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img4.png" alt="在这里插入图片描述"></p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> GameFacade = BaseClass(<span class="string">&quot;GameFade&quot;</span>, Facade)</span><br><span class="line"><span class="keyword">local</span> base = Facade</span><br><span class="line"><span class="keyword">local</span> STARTUP = <span class="string">&quot;startUp&quot;</span></span><br><span class="line">GameFacade.KEY = <span class="string">&quot;GameFacade&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:InitializeController</span><span class="params">()</span></span></span><br><span class="line">    base.InitializeController(<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>:RegisterCommand(STARTUP, StartUpCommand)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:StartUp</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>:SendNotification(STARTUP);</span><br><span class="line">    <span class="comment">--PureMVC初始化完成，注销STARTUP命令</span></span><br><span class="line">    <span class="built_in">self</span>:RemoveCommand(STARTUP);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameFacade:GetInstance</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rawget</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>) == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rawset</span>(GameFacade, <span class="string">&quot;Instance&quot;</span>, GameFacade.New(GameFacade.KEY))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> GameFacade.Instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GameFacade</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> StartUpCommand = BaseClass(<span class="string">&#x27;StartUpCommand&#x27;</span>, MacroCommand)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StartUpCommand:InitializeMacroCommand</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> StartUpCommand</span><br></pre></td></tr></table></figure>

<p>一般是继承Facade类注册 开始事件，这里是 STARTUP， 然后继承Command 构造 StartUpCommand<br>这里可以参考网上一些完整样例。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">GameFacade:GetInstance():StartUp()</span><br></pre></td></tr></table></figure>
<p>通过StartUp开启</p>
<h2 id="单模块通信"><a href="#单模块通信" class="headerlink" title="单模块通信"></a>单模块通信</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img5.png" alt="在这里插入图片描述"></p>
<p>红色为直接调用，绿色为事件通信</p>
<p>Proxy只发送消息不接受消息，是通过Command直接调用的，原因是设计时Proxy要负责和服务器交互，再监听其他事件过于繁琐</p>
<h2 id="多模块通信"><a href="#多模块通信" class="headerlink" title="多模块通信"></a>多模块通信</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img6.png" alt="在这里插入图片描述"></p>
<p>黄色线也是可能存在的事件，因为观察者模式不需要关注消息的来源，只要订阅了相关消息就可以触发</p>
<p>例如EmailProxy接收到服务器消息更新时也需要更新BagUI就可以发送消息给BagMediator</p>
<p>或者EmailUI也可以购买物品可以发送消息给<br>EmailMediator转发给BagCommand调用BagProxy</p>
<h2 id="过于强调解耦"><a href="#过于强调解耦" class="headerlink" title="过于强调解耦"></a>过于强调解耦</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img7.png" alt="在这里插入图片描述"></p>
<p>因为都是消息机制，整个流程很长，而且Proxy中对数据进行操作后，发送Notification时，可能需要携带修改后的数据（可能是来自服务器的数据）。这个过程不仅通过次数多，而且带反馈数据的消息增加通信负担。另一方面要调试这个过程，我们只能在编译的时候找出一步一步的通信流程，才能跟踪调试。</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>因为游戏项目本身不需要过于解耦，UI部分不希望出现类爆炸的情况，在此基础上进行了一些修改</p>
<h2 id="UI-和-Mediator-结合"><a href="#UI-和-Mediator-结合" class="headerlink" title="UI 和 Mediator 结合"></a>UI 和 Mediator 结合</h2><p>Mediator和UI之间的通信有点繁琐，可以让UI持有Mediator，这样UI可以通过持有的UIMediator 与PureMVC交互，并且接收到消息时，也可以直接调用自身UI函数，不再需要Mediator持有UI调用</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:ListNotificationInterests</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> result = <span class="built_in">self</span>.mViewComponent:ListNotificationInterests()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIMediator:HandleNotification</span><span class="params">(notification)</span></span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">self</span>.mViewComponent ~= <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>.mViewComponent:HandleNotification(notification)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>UI直接绑定一个公用的UIMediator通过UIMeditaor发送消息和PureMVC交互</p>
<h2 id="Command中介多余"><a href="#Command中介多余" class="headerlink" title="Command中介多余"></a>Command中介多余</h2><p>数据相关部分已经被Proxy封装好，可以考虑不再需要通过Command转发，可以直接由UI（UIMediator）调用Proxy的接口以减少类的数量，Proxy之间的调用可以通过加一个全局注册事件触发</p>
<h2 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img8.png" alt="在这里插入图片描述"></p>
<p>交互过程UI 通过调用自身的成员变量UIMediator发送消息<br>并通过在UIMediator中注册的消息响应来自来自外部的消息<br>UI不再经过Command调用Proxy 而是直接调用Proxy</p>
<h2 id="修改总结"><a href="#修改总结" class="headerlink" title="修改总结"></a>修改总结</h2><p><img src="/2021/05/10/Lua%E5%92%8CPureMVC/img9.png" alt="在这里插入图片描述"></p>
<ul>
<li>对于一个小功能，每个功能对应的文件应该为一个UI和一个Proxy</li>
<li>对于一个大功能，每个功能对应的文件应该为多个UI和一个Proxy  </li>
<li>因为Proxy没有接收消息的接口，一般来说Proxy之间不会有互相调用的情况，但是可能会有如：背包收到服务器更新消息以后先更新背包后更新其他例如邮件等功能数据的情况，可考虑通过外部的Event添加监听<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1></li>
<li>解耦的同时将使项目修改的复杂程度提高，某些解耦的办法还会增加代码量、降低执行效率。PureMVC是一个强解耦的框架，其效率本身不是很高，函数调用层次较深，而有时根本不清楚消息发到了哪里</li>
<li>因为需要外界触发，在游戏上一般只适合用来做UI部分</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity资源管理（一）Asset</title>
    <url>/2021/05/12/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89Asset/</url>
    <content><![CDATA[<h1 id="Asset-和-Object"><a href="#Asset-和-Object" class="headerlink" title="Asset 和 Object"></a>Asset 和 Object</h1><h2 id="Asset（资源文件）"><a href="#Asset（资源文件）" class="headerlink" title="Asset（资源文件）"></a>Asset（资源文件）</h2><p>关于Asset，网上已经有很多解释了，可以去看<a href="https://zhuanlan.zhihu.com/p/96709802">https://zhuanlan.zhihu.com/p/96709802</a></p>
<p>简单来说，Asset是位于Assets目录下，可以在Unity的Projects窗口里看到的单个文件。这些就是平常项目中用到的资源文件，例如纹理，音效文件，预制体等等。</p>
<h2 id="Object-（对象）"><a href="#Object-（对象）" class="headerlink" title="Object （对象）"></a>Object （对象）</h2><p>Object是指从UnityEngine.Object继承的对象，是一个可以序列化的数据，是用来描述一个特定的资源的实例。例如Mesh, Sprite, AudioClip or AnimationClip等等。</p>
<h2 id="Asset和Object"><a href="#Asset和Object" class="headerlink" title="Asset和Object"></a>Asset和Object</h2><p>刚学习时，会把Asset和Object搞混，这里可以去看这篇文章<a href="https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw">https://mp.weixin.qq.com/s/0XFQt8LmqoTxxst_kKDMjw?</a><br>简单来说，对于Asset，无论是纹理、音乐还是预制体，在进入Unity以后，都需要转变成Object，即纹理转变为Texture2D或Sprite，音效文件转变为AudioClip，预制体变成了GameObject等等，这个由Asset(资源文件)转变为Object(对象)，从磁盘进入内存的过程，就是实例化。</p>
<h1 id="Asset-加载和实例化"><a href="#Asset-加载和实例化" class="headerlink" title="Asset 加载和实例化"></a>Asset 加载和实例化</h1><h2 id="Asset加载和实例化原理"><a href="#Asset加载和实例化原理" class="headerlink" title="Asset加载和实例化原理"></a>Asset加载和实例化原理</h2><p>一个Prefab从assetBundle里Load出来 里面可能包括：Gameobject transform mesh texture material shader script和各种其他Assets<br>Instaniate一个Prefab，是一个对Assets进行Clone(复制)+引用结合的过程，GameObject transform 是Clone是新生成的。其他mesh / texture / material / shader 等，这其中些是纯引用的关系的，包括：Texture和TerrainData，还有引用和复制同时存在的，包括：Mesh/material /PhysicMaterial。引用的Asset对象不会被复制，只是一个简单的指针指向已经Load的Asset对象<br>提一下的是一个特殊的东西：Script Asset，看起来很奇怪，Unity里每个Script都是一个封闭的Class定义而已, 并没有写调用代码，光Class的定义脚本是不会工作的。其实Unity引擎就是那个调用代码，Clone一个script asset等于new一个class实例，实例才会完成工作。把他挂到Unity主线程的调用链里去，Class实例里的OnUpdate OnStart等才会被执行。多个物体挂同一个脚本，其实就是在多个物体上挂了那个脚本类的多个实例而已，这样就好理解了。在new class这个过程中，数据区是复制的，代码区是共享的，算是一种特殊的复制+引用关系。<br>你可以再Instaniate一个同样的Prefab, 还是这套mesh/texture/material/shader等等，这时候会有新的GameObject等，但是不会创建新的引用对象比如texture.<br>可以参照下图理解<br><img src="/2021/05/12/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89Asset/img1.png" alt="在这里插入图片描述"></p>
<h2 id="Asset加载方式"><a href="#Asset加载方式" class="headerlink" title="Asset加载方式"></a>Asset加载方式</h2><p>通俗意义上存在三种加载方式<br>静态引用：建一个public的变量，在Inspector里把prefab拉上去，用的时候instantiate<br>Resource.Load: Load以后instantiate<br>AssetBundle.Load: Load以后instantiate</p>
<p>这里进行了一波测试</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放到真机环境下测试以后<br><img src="/2021/05/12/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89Asset/img2.png" alt="在这里插入图片描述"></p>
<p>可以看到Load时候引用类型的Assert（即pic1）已经被加载到内存中，实例化时候只是Clone和对已经加载到内存中的Assert引用</p>
<h2 id="什么时候才是UnusedAssets"><a href="#什么时候才是UnusedAssets" class="headerlink" title="什么时候才是UnusedAssets?"></a>什么时候才是UnusedAssets?</h2><p>从上面例子中可以看到Destory一个Prefab实例以后，这时候Prefab已经没有被实际的物体引用了，但如果这时：<br>Resources.UnloadUnusedAssets();<br>内存并没有被释放，原因：Prefab还被这个变量go所引用这时候：<br>go = null;<br>Resources.UnloadUnusedAssets();<br>这样才能真正释放Assets对象<br>所以：UnusedAssets不但要没有被实际物体引用，也要没有被生命周期内的变量所引用，才可以理解为 Unused(引用计数为0)<br>所以：如果用个全局变量保存Load的Assets，又没有显式的设为null，那在这个变量失效前是无论如何UnloadUnusedAssets也释放不了那些Assets的<br>可以再写下如下代码测试</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">OnTestClick</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//清干净以免影响测试效果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> wait = <span class="number">5f</span>;<span class="comment">//每步都等待5s以便于分析结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Texture tt = Resources.Load(<span class="string">&quot;pic1&quot;</span>) <span class="keyword">as</span> Texture;<span class="comment">//加载贴图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject go = Resources.Load(<span class="string">&quot;prefab1&quot;</span>) <span class="keyword">as</span> GameObject;<span class="comment">//加载Prefab</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    GameObject obj = Instantiate(go) <span class="keyword">as</span> GameObject;<span class="comment">//生成实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Destroy(obj);<span class="comment">//销毁实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();<span class="comment">//卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    go = <span class="literal">null</span>;<span class="comment">//将prefab引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">wait</span>)</span>;</span><br><span class="line"></span><br><span class="line">    tt = <span class="literal">null</span>;<span class="comment">//将texture引用置为空以后卸载无用资源</span></span><br><span class="line"></span><br><span class="line">    Resources.UnloadUnusedAssets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/12/Unity%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89Asset/img3.png" alt="在这里插入图片描述"><br>这里可以确认prefab中加载的Assert pic1直接加载的pic1占有的是同一块内存，并且仅当go和tt都显示的置为null以后，才可以被UnloadUnusedAssets<br>举个例子帮助理解<br>你从Resources里Load了一个prefab并克隆之：obj = Instaniate(Resources.Load(“prefab1”));<br>这个prefab比如是个npc<br>然后你不需要他的时候你用了：Destroy(obj);你以为就释放干净了<br>其实这时候只是释放了Clone对象，通过Load加载的所有引用、非引用Assets对象全都静静的躺在内存里。<br>这种情况应该在Destroy以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>当然如果你是go = Resources.Load(“prefab1”), obj = Instaniate(go);<br>必须先go = null以后再Resources.UnloadUnusedAssets()才能把Assets清除，<br>当然如果这个NPC也是要频繁创建，销毁的 那就应该让那些Assets呆在内存里以加速游戏体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Resources.Load 会把需要的所有Assets加载到内存中，当Instaniate时候会Clone和对已经加载到内存中的Assert引用，这些Assets只有在没有被实际物体引用，也没有被生命周期内的变量所引用，才可以理解为Unused，才能被Resources.UnloadUnusedAssets()<br>同理，静态引用的时候由于始终有一个生命周期的对象引用pic1，只要中途没有把这个变量显示的置为null，pic1会自始至终躺在内存中<br>至于AssetBundle.Load，可以把Resources.Load看作是从一个缺省打进程序包里的AssetBundle里加载资源，AssetBundle.load也是在load时候把Perfab的全部Assets加载到内存中</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>资源管理</tag>
      </tags>
  </entry>
</search>
